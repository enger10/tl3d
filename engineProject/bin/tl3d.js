//tl3dLib
window.__extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
window.tl3d={};
(function (tl3d) {
    var UnitFunction = /** @class */ (function () {
        function UnitFunction() {
        }
        UnitFunction.getUItittleUrl = function (name) {
            return "ui/load/tittle/" + name + ".png";
        };
        UnitFunction.getSkillUrl = function (name) {
            var str = "skill/" + name + tl3d.Util.getBaseUrl() + ".txt";
            return str.replace(".txt", "_byte.txt");
        };
        UnitFunction.getModelUrl = function (name) {
            return "model/" + name + tl3d.Util.getBaseUrl() + ".txt";
        };
        UnitFunction.getModelUIUrl = function (name) {
            return "model/" + name + tl3d.Util.getBaseUrl() + ".txt";
        };
        UnitFunction.getMapUrl = function (name) {
            return "map/" + name + tl3d.Util.getBaseUrl() + ".txt";
        };
        UnitFunction.getBaoxiangUrl = function () {
            return "changjing/baoxiang/100001.txt";
        };
        UnitFunction.getRoleUrl = function (name) {
            return "role/" + name + tl3d.Util.getBaseUrl() + ".txt";
        };
        UnitFunction.getZipMapUrl = function (name) {
            return "map/" + name + "/";
        };
        /**标准化数字 */
        UnitFunction.Snum = function ($num) {
            return "123";
        };
        UnitFunction.getEffectUIUrl = function (name) {
            return "ui/load/effect/" + name + ".png";
        };
        UnitFunction.getKeyProById = function ($id) {
            return "cc";
        };
        return UnitFunction;
    }());
    tl3d.UnitFunction = UnitFunction;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var CharAction = /** @class */ (function () {
        function CharAction() {
        }
        CharAction.STANAD = "stand";
        CharAction.WALK = "walk";
        CharAction.DEATH = "death";
        CharAction.JUMP = "jump";
        CharAction.SIT = "sit";
        CharAction.INJURED = "injured";
        CharAction.ATTACK_01 = "attack_01";
        CharAction.ATTACK_02 = "attack_02";
        CharAction.ATTACK_03 = "attack_03";
        CharAction.ATTACK_04 = "attack_04";
        CharAction.ATTACK_05 = "attack_05";
        CharAction.ATTACK_06 = "attack_06";
        CharAction.ATTACK_010 = "attack_010";
        CharAction.ATTACK_020 = "attack_020";
        CharAction.STAND_MOUNT = "stand_mount_01";
        CharAction.WALK_MOUNT = "walk_mount_01";
        CharAction.s_attack_01 = "s_attack_01"; //移动中行走的特殊技能
        return CharAction;
    }());
    tl3d.CharAction = CharAction;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Engine = /** @class */ (function () {
        function Engine() {
        }
        Engine.init = function ($caves) {
            tl3d.Scene_data.vpMatrix = new tl3d.Matrix3D;
            tl3d.Scene_data.canvas3D = $caves;
            tl3d.Scene_data.context3D = new tl3d.Context3D();
            tl3d.Scene_data.context3D.init($caves);
            tl3d.UIManager.getInstance().init();
            tl3d.Scene_data.cam3D = new tl3d.Camera3D;
            tl3d.Scene_data.focus3D = new tl3d.Object3D;
            tl3d.Scene_data.focus3D.x = 0;
            tl3d.Scene_data.focus3D.y = 0;
            tl3d.Scene_data.focus3D.z = 0;
            tl3d.Scene_data.focus3D.rotationY = 135;
            tl3d.Scene_data.focus3D.rotationX = -45;
            tl3d.Scene_data.light = new tl3d.LightVo();
            Engine.testBlob();
            Engine.resetSize();
            Engine.initShadow();
            tl3d.TimeUtil.init();
            tl3d.PathManager.init();
        };
        Engine.resReady = function () {
            Engine.initPbr();
        };
        Engine.testBlob = function () {
            //Scene_data.supportBlob = false;
            //return;
            //todo packageapp
            // try {
            //     var blob = new Blob();
            // } catch (e) {
            //     Scene_data.supportBlob = false;
            //     return;
            // }
            // Scene_data.supportBlob = true;
        };
        Engine.initPbr = function () {
            if (!tl3d.Scene_data.pubLut) {
                tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + "base/brdf_ltu.jpg", function ($texture) {
                    tl3d.Scene_data.pubLut = $texture.texture;
                }, 1);
            }
            // if (!Scene_data.skyCubeMap) {
            //     TextureManager.getInstance().loadCubeTexture(Scene_data.fileRoot + "base/cube/e", ($ary: any) => {
            //         Scene_data.skyCubeMap = $ary;
            //     })
            // }
        };
        Engine.initShadow = function () {
            tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + "base/shadow.png", function ($texture) {
                tl3d.Display3dShadow.texture = $texture.texture;
            });
        };
        Engine.resetSize = function (a, b) {
            if (a === void 0) { a = 0; }
            if (b === void 0) { b = 0; }
            if (Engine.needInputTxt) {
                return;
            }
            //Scene_data.stageWidth = document.documentElement.clientWidth;
            //Scene_data.stageHeight = document.documentElement.clientHeight;
            //var flag: boolean = false;
            if (document.body.clientWidth > document.body.clientHeight) {
                tl3d.Scene_data.stageWidth = document.body.clientWidth;
                tl3d.Scene_data.stageHeight = document.body.clientHeight;
                tl3d.Scene_data.verticalScene = false;
            }
            else {
                tl3d.Scene_data.stageWidth = document.body.clientHeight;
                tl3d.Scene_data.stageHeight = document.body.clientWidth;
                tl3d.Scene_data.verticalScene = true;
            }
            // Scene_data.stageWidth = document.body.clientWidth;
            // Scene_data.stageHeight = document.body.clientHeight;
            // Scene_data.verticalScene = false;
            if (!this.needVertical) {
                tl3d.Scene_data.stageWidth = document.body.clientWidth;
                tl3d.Scene_data.stageHeight = document.body.clientHeight;
                tl3d.Scene_data.verticalScene = false;
            }
            tl3d.Scene_data.canvas3D.width = tl3d.Scene_data.stageWidth;
            tl3d.Scene_data.canvas3D.height = tl3d.Scene_data.stageHeight;
            tl3d.Scene_data.context3D.resetSize(tl3d.Scene_data.stageWidth, tl3d.Scene_data.stageHeight);
            tl3d.UIManager.getInstance().resize();
            this.resetViewMatrx3D();
            tl3d.Scene_data.canvas3D.style.position = "absolute";
            tl3d.Scene_data.canvas3D.style.left = "0px";
            tl3d.Scene_data.canvas3D.style.top = "0px";
            if (tl3d.Scene_data.verticalScene) {
                tl3d.Scene_data.canvas3D.style.transform = "matrix(0,1,-1,0," + tl3d.Scene_data.stageHeight + ",0)";
                //Scene_data.canvas3D.style.webkitTransform = "matrix(0,1,-1,0," + Scene_data.stageHeight + ",0)";
            }
            else {
                tl3d.Scene_data.canvas3D.style.transform = "matrix(1,0,0,1,0,0)";
                //Scene_data.canvas3D.style.webkitTransform = "matrix(0,1,-1,0," + Scene_data.stageHeight + ",0)";
            }
            tl3d.Scene_data.canvas3D.style.transformOrigin = "0px 0px 0px";
            tl3d.Scene_data.canvas3D.style.top = "0px";
        };
        Engine.resetViewMatrx3D = function () {
            if (tl3d.Scene_data.viewMatrx3D) {
                tl3d.Scene_data.viewMatrx3D.identity();
            }
            else {
                tl3d.Scene_data.viewMatrx3D = new tl3d.Matrix3D;
            }
            var fovw = tl3d.Scene_data.stageWidth;
            var fovh = tl3d.Scene_data.stageHeight;
            tl3d.Scene_data.sceneViewHW = Math.max(fovw, fovh);
            tl3d.Scene_data.viewMatrx3D.perspectiveFieldOfViewLH(this.sceneCamScale, 1, 50, tl3d.Scene_data.camFar);
            tl3d.Scene_data.viewMatrx3D.appendScale(1 * (tl3d.Scene_data.sceneViewHW / fovw * 2), fovw / fovh * (tl3d.Scene_data.sceneViewHW / fovw * 2), 1);
        };
        Engine.update = function () {
            tl3d.TimeUtil.update();
            tl3d.FpsMc.update();
        };
        Engine.unload = function () {
            //NetManager.getInstance().close();
        };
        Engine.needVertical = true;
        Engine.needInputTxt = false; //在输入文本时，将不再可调整大小
        Engine.sceneCamScale = 1.76;
        return Engine;
    }());
    tl3d.Engine = Engine;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var FpsMc = /** @class */ (function () {
        function FpsMc() {
            this.drawNum = 0;
            this.fpsStr = "";
        }
        FpsMc.update = function () {
        };
        FpsMc.prototype.getStr = function () {
            if (true) {
                // FpsMc.fpsNowNum = Math.min(this.drawNum + float2int(this.drawNum / 10 * FpsMc.addFps), 60)
                FpsMc.fpsNowNum = Math.min(this.drawNum, 600);
                this.fpsStr = "Fps:" + String(FpsMc.fpsNowNum) + "-" + FpsMc.tipStr;
            }
            return this.fpsStr;
        };
        FpsMc.addFps = 0;
        FpsMc.fpsNowNum = 0;
        FpsMc.tipStr = "";
        return FpsMc;
    }());
    tl3d.FpsMc = FpsMc;
    var FpsStage = /** @class */ (function () {
        function FpsStage() {
            this.lastTime = 0;
            this.cPos = new tl3d.Vector2D(150, 100);
        }
        FpsStage.getInstance = function () {
            if (!this._instance) {
                this._instance = new FpsStage();
            }
            return this._instance;
        };
        FpsStage.prototype.init = function ($cadves, $loadCav) {
            var _this = this;
            this.canvas2D = $cadves;
            this.loadCav = $loadCav;
            this.fps = new FpsMc();
            this.canvasUi = this.canvas2D.getContext("2d");
            this.loadCtx = this.loadCav.getContext("2d");
            tl3d.TimeUtil.addFrameTick(function () { _this.upData(); });
        };
        FpsStage.prototype.showLoadInfo = function (str) {
            /*
            this.loadCtx.clearRect(0, 0, this.loadCav.width, this.loadCav.height);
            this.loadCtx.font = "40px Helvetica";
            this.loadCtx.fillStyle = "#ffffff";
            this.loadCtx.textBaseline = "top";
            this.loadCtx.textAlign = "left";
            this.loadCtx.fillText(str, 0, 0);
    
            */
        };
        FpsStage.prototype.removeShowLoad = function () {
            if (this.loadCav.parentElement) {
                this.loadCav.parentElement.removeChild(this.loadCav);
            }
            FpsStage.showFps = true;
        };
        FpsStage.prototype.upData = function () {
            this.fps.drawNum++;
            if (this.lastTime >= tl3d.TimeUtil.getTimer() - 1000) {
                return;
            }
            this.lastTime = tl3d.TimeUtil.getTimer();
            if (!FpsStage.showFps) {
                this.canvasUi.clearRect(0, 0, this.canvas2D.width, this.canvas2D.height);
                return;
            }
            this.canvasUi.font = "40px Helvetica";
            var wNum = this.canvasUi.measureText(this.fps.getStr()).width;
            this.canvas2D.width = wNum;
            this.canvas2D.height = 30;
            this.canvasUi.clearRect(50, 0, this.canvas2D.width - 50, this.canvas2D.height);
            this.canvasUi.fillStyle = "#000000"; // text color
            this.canvasUi.fillRect(50, 0, this.canvas2D.width - 50, this.canvas2D.height);
            this.canvasUi.font = "30px Helvetica";
            this.canvasUi.fillStyle = "#ffffff"; // text color
            this.canvasUi.textBaseline = "top";
            this.canvasUi.textAlign = "left";
            this.canvasUi.fillText(this.fps.getStr(), 50, 0);
            this.fps.drawNum = 0;
        };
        FpsStage.prototype.makeXyzLine = function () {
            var xPos = new tl3d.Vector3D(80, 0, 0);
            var yPos = new tl3d.Vector3D(0, 70, 0);
            var zPos = new tl3d.Vector3D(0, 0, 80);
            var $m = new tl3d.Matrix3D;
            $m.appendRotation(tl3d.Scene_data.cam3D.rotationY, tl3d.Vector3D.Y_AXIS);
            $m.appendRotation(tl3d.Scene_data.cam3D.rotationX, tl3d.Vector3D.X_AXIS);
            xPos = $m.transformVector(xPos);
            yPos = $m.transformVector(yPos);
            zPos = $m.transformVector(zPos);
            this.drawLine(new tl3d.Vector2D(0, 0), new tl3d.Vector2D(xPos.x, -xPos.y), "#ff0000");
            this.drawLine(new tl3d.Vector2D(0, 0), new tl3d.Vector2D(yPos.x, -yPos.y), "#00ff00");
            this.drawLine(new tl3d.Vector2D(0, 0), new tl3d.Vector2D(zPos.x, -zPos.y), "#0000ff");
            this.canvasUi.font = "12px Helvetica";
            this.canvasUi.fillStyle = "#ff0000"; // text color
            this.canvasUi.fillText("x", xPos.x + this.cPos.x, -xPos.y + this.cPos.y);
            this.canvasUi.fillStyle = "#00ff00"; // text color
            this.canvasUi.fillText("y", yPos.x + this.cPos.x, -yPos.y + this.cPos.y);
            this.canvasUi.fillStyle = "#0000ff"; // text color
            this.canvasUi.fillText("z", zPos.x + this.cPos.x, -zPos.y + this.cPos.y);
        };
        FpsStage.prototype.drawLine = function (a, b, $color) {
            if ($color === void 0) { $color = "red"; }
            this.canvasUi.beginPath();
            this.canvasUi.lineWidth = 2;
            this.canvasUi.strokeStyle = $color;
            this.canvasUi.moveTo(a.x + this.cPos.x, a.y + this.cPos.y);
            this.canvasUi.lineTo(b.x + this.cPos.x, b.y + this.cPos.y);
            this.canvasUi.stroke();
        };
        FpsStage.prototype.resetSize = function () {
            this.cPos = new tl3d.Vector2D(150, tl3d.Scene_data.stageHeight - 100);
        };
        FpsStage.showFps = false;
        return FpsStage;
    }());
    tl3d.FpsStage = FpsStage;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var BitMapData = /** @class */ (function () {
        function BitMapData($w, $h) {
            this.width = $w;
            this.height = $h;
            var $ctx = tl3d.UIManager.getInstance().getContext2D(this.width, this.height, false);
            this.imgData = $ctx.getImageData(0, 0, this.width, this.height);
            for (var k = 0; k < this.imgData.data.length; k += 4) {
                this.imgData.data[k + 0] = 255;
                this.imgData.data[k + 1] = 255;
                this.imgData.data[k + 2] = 255;
                this.imgData.data[k + 3] = 255;
            }
        }
        BitMapData.prototype.getIndexByPos = function ($tx, $ty) {
            var a = $ty * this.width + $tx;
            return 4 * a;
        };
        BitMapData.prototype.setRgb = function ($tx, $ty, $ve) {
            $tx = Math.round($tx);
            $ty = Math.round($ty);
            var $idx = this.getIndexByPos($tx, $ty);
            this.imgData.data[$idx + 0] = $ve.x * 255;
            this.imgData.data[$idx + 1] = $ve.y * 255;
            this.imgData.data[$idx + 2] = $ve.z * 255;
            this.imgData.data[$idx + 3] = 255;
        };
        BitMapData.prototype.getRgb = function ($tx, $ty) {
            $tx = Math.round($tx);
            $ty = Math.round($ty);
            var $v = new tl3d.Vector3D();
            var $idx = this.getIndexByPos($tx, $ty);
            $v.x = this.imgData.data[$idx + 0] / 255;
            $v.y = this.imgData.data[$idx + 1] / 255;
            $v.z = this.imgData.data[$idx + 2] / 255;
            $v.w = 1;
            return $v;
        };
        return BitMapData;
    }());
    tl3d.BitMapData = BitMapData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var EventDispatcher = /** @class */ (function () {
        function EventDispatcher() {
            this._eventsMap = null;
        }
        EventDispatcher.prototype.addEventListener = function (types, listener, thisObject) {
            if (!this._eventsMap) {
                this._eventsMap = new Object;
            }
            var list = this._eventsMap[types];
            if (!list) {
                list = this._eventsMap[types] = [];
            }
            var eventBin = { listener: listener, thisObject: thisObject };
            for (var i = 0; i < list.length; i++) {
                var bin = list[i];
                if (bin.listener == listener && bin.thisObject == thisObject) {
                    return;
                }
            }
            list.push(eventBin);
        };
        //是否存在监听
        EventDispatcher.prototype.hasEventListener = function (type) {
            return this._eventsMap && this._eventsMap[type] != null;
        };
        EventDispatcher.prototype.removeEventListener = function (type, listener, thisObject) {
            if (this._eventsMap == null) {
                return;
            }
            var list = this._eventsMap[type];
            for (var i = 0; list && i < list.length; i++) {
                var bin = list[i];
                if (bin.listener == listener && bin.thisObject == thisObject) {
                    list.splice(i, 1);
                    return;
                }
            }
        };
        EventDispatcher.prototype.removeEventListenerByName = function (type) {
            if (this._eventsMap == null) {
                return;
            }
            var list = this._eventsMap[type];
            if (list) {
                list.length = 0;
            }
        };
        EventDispatcher.prototype.removeEventListenerByTarget = function (thisObject) {
            if (this._eventsMap == null) {
                return;
            }
            for (var type in this._eventsMap) {
                var list = this._eventsMap[type];
                if (list) {
                    for (var i = 0; list && i < list.length; i++) {
                        var bin = list[i];
                        if (bin.thisObject == thisObject) {
                            list.splice(i, 1);
                            return;
                        }
                    }
                }
            }
        };
        EventDispatcher.prototype.removeEventListenerByNameAndTarget = function (type, thisObject) {
            if (this._eventsMap == null) {
                return;
            }
            var list = this._eventsMap[type];
            if (list) {
                for (var i = 0; list && i < list.length; i++) {
                    var bin = list[i];
                    if (bin.thisObject == thisObject) {
                        list.splice(i, 1);
                        return;
                    }
                }
            }
        };
        EventDispatcher.prototype.dispatchEvent = function (event) {
            var eventMap = this._eventsMap;
            if (!eventMap) {
                return true;
            }
            var list = eventMap[event.type];
            if (!list) {
                return true;
            }
            var length = list.length;
            if (length == 0) {
                return true;
            }
            event.target = this;
            var copyList = [].concat.apply([], list);
            for (var i = 0; i < length; i++) {
                var eventBin = copyList[i];
                if (eventBin) {
                    eventBin.listener.call(eventBin.thisObject, event);
                }
            }
        };
        return EventDispatcher;
    }());
    tl3d.EventDispatcher = EventDispatcher;
})(tl3d || (tl3d = {}));
/// <reference path="../events/EventDispatcher.ts" />

(function (tl3d) {
    var Object3D = /** @class */ (function (_super) {
        __extends(Object3D, _super);
        function Object3D($x, $y, $z) {
            if ($x === void 0) { $x = 0; }
            if ($y === void 0) { $y = 0; }
            if ($z === void 0) { $z = 0; }
            var _this = _super.call(this) || this;
            _this._x = $x;
            _this._y = $y;
            _this._z = $z;
            _this._scaleX = 1;
            _this._scaleY = 1;
            _this._scaleZ = 1;
            _this._rotationX = 0;
            _this._rotationY = 0;
            _this._rotationZ = 0;
            _this.posMatrix = new tl3d.Matrix3D;
            return _this;
        }
        Object3D.prototype.toStringout = function () {
            return "Object3D(" + String(this._x) + "," + String(this._y) + "," + String(this._z) + ")";
        };
        Object.defineProperty(Object3D.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "z", {
            get: function () {
                return this._z;
            },
            set: function (value) {
                this._z = value;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scale", {
            set: function (value) {
                this._scaleX = this._scaleY = this._scaleZ = value;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleX", {
            get: function () {
                return this._scaleX;
            },
            set: function (value) {
                this._scaleX = value;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleY", {
            get: function () {
                return this._scaleY;
            },
            set: function (value) {
                this._scaleY = value;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleZ", {
            get: function () {
                return this._scaleZ;
            },
            set: function (value) {
                this._scaleZ = value;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationX", {
            get: function () {
                return this._rotationX;
            },
            set: function (value) {
                this._rotationX = value;
                this.updateMatrix();
                this.updateRotationMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationY", {
            get: function () {
                return this._rotationY;
            },
            set: function (value) {
                this._rotationY = value;
                this.updateMatrix();
                this.updateRotationMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationZ", {
            get: function () {
                return this._rotationZ;
            },
            set: function (value) {
                this._rotationZ = value;
                this.updateMatrix();
                this.updateRotationMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "px", {
            get: function () { return 0; },
            set: function (val) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "py", {
            get: function () { return 0; },
            set: function (val) { },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "pz", {
            get: function () { return 0; },
            set: function (val) { },
            enumerable: true,
            configurable: true
        });
        Object3D.prototype.updateMatrix = function () {
            this.posMatrix.identity();
            this.posMatrix.appendScale(this._scaleX, this._scaleY, this._scaleZ);
            this.posMatrix.appendRotation(this._rotationX, tl3d.Vector3D.X_AXIS);
            this.posMatrix.appendRotation(this._rotationY, tl3d.Vector3D.Y_AXIS);
            this.posMatrix.appendRotation(this._rotationZ, tl3d.Vector3D.Z_AXIS);
            this.posMatrix.appendTranslation(this._x, this._y, this._z);
        };
        Object3D.prototype.updateRotationMatrix = function () {
        };
        return Object3D;
    }(tl3d.EventDispatcher));
    tl3d.Object3D = Object3D;
})(tl3d || (tl3d = {}));
/// <reference path="Object3D.ts" />

(function (tl3d) {
    var Camera3D = /** @class */ (function (_super) {
        __extends(Camera3D, _super);
        function Camera3D() {
            var _this = _super.call(this) || this;
            _this._distance = 500;
            _this.offset = new tl3d.Vector3D();
            _this.lastFoucs3D = new tl3d.Vector3D;
            _this.needChange = true;
            _this.cameraMatrix = new tl3d.Matrix3D;
            return _this;
        }
        Object.defineProperty(Camera3D.prototype, "distance", {
            get: function () {
                return this._distance;
            },
            set: function (value) {
                this._distance = value;
            },
            enumerable: true,
            configurable: true
        });
        Camera3D.prototype.lookAt = function ($target) {
            this.lookAtTarget = $target;
        };
        Object.defineProperty(Camera3D.prototype, "astarRect", {
            set: function (value) {
                this._astarRect = new tl3d.Rectangle();
                this._astarRect.x = value.x;
                this._astarRect.y = value.y;
                this._astarRect.width = value.width;
                this._astarRect.height = value.height;
                this._midPos = new tl3d.Vector3D();
                this._midPos.x = this._astarRect.x + this._astarRect.width / 2;
                this._midPos.z = this._astarRect.y + this._astarRect.height / 2;
                this._scaleVec = new tl3d.Vector3D();
                this._scaleVec.x = (this._astarRect.width - 100) / this._astarRect.width;
                this._scaleVec.z = (this._astarRect.height - 100) / this._astarRect.height;
            },
            enumerable: true,
            configurable: true
        });
        Camera3D.prototype.update = function () {
            if (this.lookAtTarget) {
                var ty = 28;
                if (this._astarRect && this._astarRect.width < 600) {
                    var $toPos = new tl3d.Vector3D;
                    $toPos.x = ((this.lookAtTarget.px - this._midPos.x) * this._scaleVec.x) + this._midPos.x;
                    $toPos.z = ((this.lookAtTarget.pz - this._midPos.z) * this._scaleVec.z) + this._midPos.z;
                    $toPos.y = this.lookAtTarget.py;
                    tl3d.Scene_data.focus3D.x = $toPos.x;
                    tl3d.Scene_data.focus3D.y = $toPos.y + ty;
                    tl3d.Scene_data.focus3D.z = $toPos.z;
                }
                else {
                    tl3d.Scene_data.focus3D.x = this.lookAtTarget.px;
                    tl3d.Scene_data.focus3D.y = this.lookAtTarget.py + ty;
                    tl3d.Scene_data.focus3D.z = this.lookAtTarget.pz;
                }
                if (this.lastFoucs3D.x != tl3d.Scene_data.focus3D.x || this.lastFoucs3D.y != tl3d.Scene_data.focus3D.y || this.lastFoucs3D.z != tl3d.Scene_data.focus3D.z) {
                    this.lastFoucs3D.x = tl3d.Scene_data.focus3D.x;
                    this.lastFoucs3D.y = tl3d.Scene_data.focus3D.y;
                    this.lastFoucs3D.z = tl3d.Scene_data.focus3D.z;
                    this.needChange = true;
                }
                else {
                    this.needChange = false;
                }
                // Scene_data.focus3D.rotationY = Scene_data.gameAngle;
            }
        };
        Object.defineProperty(Camera3D.prototype, "postion", {
            get: function () {
                return new tl3d.Vector3D(this.x, this.y, this.z);
            },
            enumerable: true,
            configurable: true
        });
        return Camera3D;
    }(tl3d.Object3D));
    tl3d.Camera3D = Camera3D;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ColorType = /** @class */ (function () {
        function ColorType() {
        }
        ColorType.Orange7a2f21 = "[7a2f21]"; //桔
        ColorType.Orange9a683f = "[9a683f]"; //
        ColorType.Orange853d07 = "[853d07]"; //桔
        ColorType.Brown6a4936 = "[6a4936]"; //深棕
        ColorType.Brown623424 = "[623424]"; //深棕
        ColorType.Brownac8965 = "[ac8965]";
        ColorType.Reddb4051 = "[db4051]"; //红
        ColorType.Redd92200 = "[d92200]"; //红
        ColorType.Redff0000 = "[ff0000]"; //红
        ColorType.Brownd8d49c = "[d8d49c]"; //棕
        ColorType.color843b11 = "[843b11]"; //棕
        ColorType.colorb96d49 = "[b96d49]"; //棕
        ColorType.colorcd2000 = "[cd2000]"; //棕
        ColorType.colorfef3d7 = "[fef3d7]"; //棕
        ColorType.color9a683f = "[9a683f]"; //棕
        ColorType.Brown7a2f21 = "[7a2f21]"; //棕
        ColorType.Brown40120a = "[40120a]"; //棕
        ColorType.Brown491207 = "[491207]"; //棕
        ColorType.Brown541616 = "[541616]"; //棕
        ColorType.Brown5a2610 = "[5a2610]"; //棕
        ColorType.Browndf9a68 = "[df9a68]";
        ColorType.Browndb39264 = "[b39264]";
        ColorType.Brownd662c0d = "[662c0d]";
        ColorType.colorefe4c4 = "[efe4c4]";
        ColorType.color802626 = "[802626]";
        ColorType.color9f7b4d = "[9f7b4d]";
        ColorType.color4b0808 = "[4b0808]";
        ColorType.color5f5c59 = "[5f5c59]";
        ColorType.color903713 = "[903713]";
        ColorType.colorfdf6da = "[fdf6da]";
        ColorType.color73301c = "[73301c]";
        ColorType.colorffeeb5 = "[ffeeb5]";
        ColorType.Green98ec2c = "   "; //绿
        ColorType.Green56da35 = "[56da35]"; //绿
        ColorType.Green20a200 = "[20a200]"; //绿
        ColorType.Greenadff00 = "[adff00]"; //绿
        ColorType.Green2ca937 = "[2ca937]"; //绿
        ColorType.Green464b11 = "[464b11]"; //绿
        ColorType.Green54db36 = "[54db36]"; //绿
        ColorType.Yellowf7d253 = "[f7d253]"; //黄
        ColorType.Yellowffecc6 = "[ffecc6]"; //黄
        ColorType.Yellowffd500 = "[ffd500]"; //黄
        ColorType.Yellowffe9b4 = "[ffe9b4]"; //黄
        ColorType.Yellowedce7e = "[edce7e]"; //黄
        ColorType.color4c1c07 = "[4c1c07]";
        ColorType.Whiteffffff = "[ffffff]"; //白
        ColorType.Whitefffce6 = "[fffce6]"; //白
        ColorType.Whitefff7db = "[fff7db]"; //白
        ColorType.White9A683F = "[9A683F]"; //白
        ColorType.Black000000 = "[000000]"; //黑
        ColorType.Whitefff4d6 = "[fff4d6]"; //白
        ColorType.Whiteffeed0 = "[ffeed0]"; //白
        ColorType.Whiteffeec9 = "[ffeec9]"; //白
        ColorType.Whiteffe9b4 = "[ffe9b4]"; //白
        ColorType.Whitefff0b4 = "[fff0b4]"; //白
        ColorType.Coffeeff9200 = "[ff9200]"; //橙黄
        ColorType.Coffeefee87b = "[fee87b]"; //橙黄
        ColorType.color2daa35 = "[2daa35]"; //绿
        ColorType.color4392ff = "[4392ff]"; //蓝
        ColorType.colorb759ff = "[b759ff]"; //紫
        ColorType.colorff7200 = "[ff7200]"; //桔
        ColorType.colorce0a00 = "[ce0a00]"; //红
        ColorType.coloraa874a = "[aa874a]"; //红
        ColorType.colorffecc6 = "[ffecc6]"; //红
        ColorType.colorfde87e = "[fde87e]"; //红
        ColorType.colord6e7ff = "[d6e7ff]"; //红"#"
        ColorType.colord27262e = "[27262e]";
        ColorType.colorffe9b4 = "[ffe9b4]";
        ColorType.color9c9b9b = "[9c9b9b]";
        ColorType.colorfff2d3 = "[fff2d3]";
        ColorType.color451800 = "[451800]";
        return ColorType;
    }());
    tl3d.ColorType = ColorType;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Dictionary = /** @class */ (function () {
        function Dictionary(init) {
            this._keys = new Array;
            this._values = new Array;
            for (var x = 0; init && x < init.length; x++) {
                this[init[x].key] = init[x].value;
                this._keys.push(init[x].key);
                this._values.push(init[x].value);
            }
        }
        Dictionary.prototype.add = function (key, value) {
            this[key] = value;
            this._keys.push(key);
            this._values.push(value);
        };
        Dictionary.prototype.has = function (key) {
            if (this[key]) {
                return true;
            }
            else {
                return false;
            }
        };
        Dictionary.prototype.remove = function (key) {
            var index = this._keys.indexOf(key, 0);
            this._keys.splice(index, 1);
            this._values.splice(index, 1);
            delete this[key];
        };
        Dictionary.prototype.keys = function () {
            return this._keys;
        };
        Dictionary.prototype.values = function () {
            return this._values;
        };
        Dictionary.prototype.containsKey = function (key) {
            if (typeof this[key] === "undefined") {
                return false;
            }
            return true;
        };
        Dictionary.prototype.toLookup = function () {
            return this;
        };
        return Dictionary;
    }());
    tl3d.Dictionary = Dictionary;
    var WeakSet = /** @class */ (function () {
        function WeakSet() {
            this._item = new Array;
        }
        WeakSet.prototype.add = function ($data) {
            this._item.push($data);
        };
        WeakSet.prototype.has = function ($data) {
            for (var i = 0; i < this._item.length; i++) {
                if (this._item[i] == $data) {
                    return true;
                }
            }
            return false;
        };
        return WeakSet;
    }());
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var GC = /** @class */ (function () {
        function GC() {
        }
        GC.prototype.destory = function () {
        };
        return GC;
    }());
    tl3d.GC = GC;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ResCount = /** @class */ (function (_super) {
        __extends(ResCount, _super);
        function ResCount() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._useNum = 0;
            _this.idleTime = 0;
            return _this;
        }
        Object.defineProperty(ResCount.prototype, "useNum", {
            get: function () {
                return this._useNum;
            },
            set: function (n) {
                this._useNum = n;
                // console.log("*设置引用计数：",this._useNum);
                if (this._useNum == 0) {
                    this.idleTime = 0;
                }
            },
            enumerable: true,
            configurable: true
        });
        ResCount.prototype.clearUseNum = function () {
            this._useNum--;
            // console.log("-减少引用计数：",this._useNum);
            if (this._useNum <= 0) {
                this.idleTime = ResCount.GCTime;
                // console.log("清空引用计数等待释放：",this.idleTime);
            }
        };
        //gc四次之后才被释放
        ResCount.GCTime = 4;
        return ResCount;
    }(tl3d.GC));
    tl3d.ResCount = ResCount;
})(tl3d || (tl3d = {}));
/// <reference path="ResCount.ts" />

(function (tl3d) {
    var ObjData = /** @class */ (function (_super) {
        __extends(ObjData, _super);
        function ObjData() {
            var _this = _super.call(this) || this;
            _this.vertices = new Array;
            _this.uvs = new Array;
            _this.indexs = new Array;
            _this.lightuvs = new Array;
            _this.normals = new Array;
            _this.tangents = new Array;
            _this.bitangents = new Array;
            _this.treNum = 0;
            /**顶点 uv lightuv normal 合成一个 va */
            _this.compressBuffer = false;
            _this.hasdispose = false;
            return _this;
        }
        ObjData.prototype.destory = function () {
            this.vertices.length = 0;
            this.vertices = null;
            this.uvs.length = 0;
            this.uvs = null;
            this.indexs.length = 0;
            this.indexs = null;
            this.lightuvs.length = 0;
            this.lightuvs = null;
            this.normals.length = 0;
            this.normals = null;
            this.tangents.length = 0;
            this.tangents = null;
            this.bitangents.length = 0;
            this.bitangents = null;
            if (this.vertexBuffer) {
                tl3d.Scene_data.context3D.deleteBuffer(this.vertexBuffer);
                this.vertexBuffer = null;
            }
            if (this.uvBuffer) {
                tl3d.Scene_data.context3D.deleteBuffer(this.uvBuffer);
                this.uvBuffer = null;
            }
            if (this.indexBuffer) {
                tl3d.Scene_data.context3D.deleteBuffer(this.indexBuffer);
                this.indexBuffer = null;
            }
            if (this.lightUvBuffer) {
                tl3d.Scene_data.context3D.deleteBuffer(this.lightUvBuffer);
                this.lightUvBuffer = null;
            }
            if (this.normalsBuffer) {
                tl3d.Scene_data.context3D.deleteBuffer(this.normalsBuffer);
                this.normalsBuffer = null;
            }
            if (this.tangentBuffer) {
                tl3d.Scene_data.context3D.deleteBuffer(this.tangentBuffer);
                this.tangentBuffer = null;
            }
            if (this.bitangentBuffer) {
                tl3d.Scene_data.context3D.deleteBuffer(this.bitangentBuffer);
                this.bitangentBuffer = null;
            }
            this.hasdispose = true;
        };
        return ObjData;
    }(tl3d.ResCount));
    tl3d.ObjData = ObjData;
})(tl3d || (tl3d = {}));
/// <reference path="../base/ObjData.ts" />

(function (tl3d) {
    var MeshData = /** @class */ (function (_super) {
        __extends(MeshData, _super);
        function MeshData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.boneIDAry = new Array;
            _this.boneWeightAry = new Array;
            _this.boneNewIDAry = new Array;
            _this.particleAry = new Array;
            return _this;
        }
        MeshData.prototype.getBindPosMatrix = function () {
            var ary = new Array;
            var invertAry = new Array;
            for (var i = 0; i < this.bindPosAry.length; i++) {
                var objbone = this.bindPosAry[i];
                var OldQ = new tl3d.Quaternion(objbone[0], objbone[1], objbone[2]);
                OldQ.setMd5W();
                var newM = OldQ.toMatrix3D();
                newM.appendTranslation(objbone[3], objbone[4], objbone[5]);
                invertAry.push(newM.clone());
                newM.invert();
                ary.push(newM);
            }
            this.bindPosMatrixAry = ary;
            this.bindPosInvertMatrixAry = invertAry;
        };
        MeshData.prototype.destory = function () {
            _super.prototype.destory.call(this);
            if (this.materialParam) {
                this.materialParam.destory();
                this.materialParam = null;
                this.materialParamData = null;
            }
            this.boneIDAry.length = 0;
            this.boneWeightAry.length = 0;
            this.boneNewIDAry.length = 0;
            this.boneIDAry = null;
            this.boneWeightAry = null;
            this.boneNewIDAry = null;
            if (this.boneWeightBuffer) {
                tl3d.Scene_data.context3D.deleteBuffer(this.boneWeightBuffer);
                this.boneWeightBuffer = null;
            }
            if (this.boneIdBuffer) {
                tl3d.Scene_data.context3D.deleteBuffer(this.boneIdBuffer);
                this.boneIdBuffer = null;
            }
            if (this.material) {
                this.material.clearUseNum();
            }
            this.particleAry.length = 0;
            this.particleAry = null;
            //for (){
            //}
        };
        return MeshData;
    }(tl3d.ObjData));
    tl3d.MeshData = MeshData;
    var BindParticle = /** @class */ (function () {
        //public particle: CombineParticle;
        function BindParticle($url, $socketName) {
            this.url = $url;
            this.socketName = $socketName;
        }
        return BindParticle;
    }());
    tl3d.BindParticle = BindParticle;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ResGC = /** @class */ (function () {
        function ResGC() {
            var _this = this;
            this._dic = new Object();
            var randTime = tl3d.Util.getRandomNumAssgin(1, 30000, 35000)[0];
            Laya.timer.loop(randTime, this, function () { _this.gc(); });
        }
        ResGC.prototype.gc = function () {
            // console.log("gc清理");
            var keys = [];
            for (var key in this._dic) {
                keys.push(key);
                var rc = this._dic[key];
                if (rc.useNum <= 0) {
                    rc.idleTime++;
                    if (rc.idleTime >= tl3d.ResCount.GCTime) {
                        // console.log("清理 -" + key);
                        rc.destory();
                        delete this._dic[key];
                    }
                }
            }
            // console.log("keys:",keys);
        };
        return ResGC;
    }());
    tl3d.ResGC = ResGC;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Context3D = /** @class */ (function () {
        function Context3D() {
            this.setTextureNum = 0;
            this.setProgramNum = 0;
        }
        Context3D.prototype.init = function ($caves) {
            //this.renderContext = $caves.getContext("experimental-webgl");
            var gl = $caves.getContext('webgl', { stencil: true, alpha: true, depth: true, antialias: true })
                || $caves.getContext('experimental-webgl', { stencil: true, alpha: true, depth: true, antialias: true });
            this.renderContext = gl;
            this._contextSetTest = new ContextSetTest();
        };
        Context3D.prototype.resetSize = function ($width, $height) {
            this.renderContext.viewport(0, 0, $width, $height);
        };
        Context3D.prototype.uploadBuff3D = function ($jsData) {
            var arrayBuffer = this.renderContext.getParameter(this.renderContext.ARRAY_BUFFER_BINDING);
            var $buffData = this.renderContext.createBuffer();
            this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, $buffData);
            this.renderContext.bufferData(this.renderContext.ARRAY_BUFFER, new Float32Array($jsData), this.renderContext.STATIC_DRAW);
            if (arrayBuffer) {
                this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, arrayBuffer);
            }
            this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, this.nullBuff); //将绑带对象制空。防止安桌污染
            return $buffData;
        };
        Context3D.prototype.uploadBuff3DArrayBuffer = function ($jsData) {
            var arrayBuffer = this.renderContext.getParameter(this.renderContext.ARRAY_BUFFER_BINDING);
            var $buffData = this.renderContext.createBuffer();
            this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, $buffData);
            this.renderContext.bufferData(this.renderContext.ARRAY_BUFFER, $jsData, this.renderContext.STATIC_DRAW);
            if (arrayBuffer) {
                this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, arrayBuffer);
            }
            this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, this.nullBuff); //将绑带对象制空。防止安桌污染
            return $buffData;
        };
        Context3D.prototype.uploadBuff3DByBuffer = function ($buffData, $jsData) {
            var arrayBuffer = this.renderContext.getParameter(this.renderContext.ARRAY_BUFFER_BINDING);
            this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, $buffData);
            this.renderContext.bufferData(this.renderContext.ARRAY_BUFFER, new Float32Array($jsData), this.renderContext.STATIC_DRAW);
            if (arrayBuffer) {
                this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, arrayBuffer);
            }
        };
        Context3D.prototype.uploadIndexBuff3D = function ($iStrData) {
            var elementArrayBuffer = this.renderContext.getParameter(this.renderContext.ELEMENT_ARRAY_BUFFER_BINDING);
            var $iBuffer = this.renderContext.createBuffer();
            this.renderContext.bindBuffer(this.renderContext.ELEMENT_ARRAY_BUFFER, $iBuffer);
            //todo packageapp
            while ($iStrData.length % 4 != 0) {
                $iStrData.push(0);
            }
            this.renderContext.bufferData(this.renderContext.ELEMENT_ARRAY_BUFFER, new Uint16Array($iStrData), this.renderContext.STATIC_DRAW);
            if (elementArrayBuffer) {
                this.renderContext.bindBuffer(this.renderContext.ELEMENT_ARRAY_BUFFER, elementArrayBuffer);
            }
            this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, this.nullBuff); //将绑带对象制空。防止安桌污染
            return $iBuffer;
        };
        Context3D.prototype.uploadIndexBuff3DByBuffer = function ($iBuffer, $iStrData) {
            var elementArrayBuffer = this.renderContext.getParameter(this.renderContext.ELEMENT_ARRAY_BUFFER_BINDING);
            this.renderContext.bindBuffer(this.renderContext.ELEMENT_ARRAY_BUFFER, $iBuffer);
            this.renderContext.bufferData(this.renderContext.ELEMENT_ARRAY_BUFFER, new Uint16Array($iStrData), this.renderContext.STATIC_DRAW);
            if (elementArrayBuffer) {
                this.renderContext.bindBuffer(this.renderContext.ELEMENT_ARRAY_BUFFER, elementArrayBuffer);
            }
        };
        //public num_setProgram:number = 0;
        Context3D.prototype.clearContext = function () {
            this.renderContext.depthMask(true);
            this.renderContext.clear(this.renderContext.COLOR_BUFFER_BIT | this.renderContext.DEPTH_BUFFER_BIT | this.renderContext.STENCIL_BUFFER_BIT);
        };
        Context3D.prototype.update = function () {
            this._contextSetTest.clear();
            this.renderContext.bindFramebuffer(this.renderContext.FRAMEBUFFER, null);
            this.renderContext.clearColor(63 / 255, 63 / 255, 63 / 255, 1.0);
            this.renderContext.clearDepth(1.0);
            this.renderContext.clearStencil(0.0);
            this.renderContext.enable(this.renderContext.DEPTH_TEST);
            this.renderContext.depthMask(true);
            this.renderContext.enable(this.renderContext.BLEND);
            this.renderContext.frontFace(this.renderContext.CW);
            this.renderContext.clear(this.renderContext.COLOR_BUFFER_BIT | this.renderContext.DEPTH_BUFFER_BIT | this.renderContext.STENCIL_BUFFER_BIT);
            //this.renderContext.blendFunc(this.renderContext.SRC_ALPHA, this.renderContext.ONE_MINUS_SRC_ALPHA);
            this.setBlendParticleFactors(0);
            this.renderContext.disable(this.renderContext.CULL_FACE);
            ////console.log("program设置次数：" + this.setProgramNum + "纹理设置次数：" + this.setTextureNum);
            this.setTextureNum = 0;
            this.setProgramNum = 0;
        };
        Context3D.prototype.updateFBO = function (fbo) {
            this.renderContext.bindFramebuffer(this.renderContext.FRAMEBUFFER, fbo.frameBuffer);
            this.renderContext.clearColor(63 / 255, 63 / 255, 63 / 255, 1.0);
            this.renderContext.clearDepth(1.0);
            this.renderContext.clearStencil(0.0);
            this.renderContext.enable(this.renderContext.DEPTH_TEST);
            this.renderContext.depthMask(true);
            this.renderContext.enable(this.renderContext.BLEND);
            this.renderContext.frontFace(this.renderContext.CW);
            this.renderContext.clear(this.renderContext.COLOR_BUFFER_BIT | this.renderContext.DEPTH_BUFFER_BIT | this.renderContext.STENCIL_BUFFER_BIT);
            //this.renderContext.blendFunc(this.renderContext.SRC_ALPHA, this.renderContext.ONE_MINUS_SRC_ALPHA);
            this.setBlendParticleFactors(0);
            this.renderContext.disable(this.renderContext.CULL_FACE);
        };
        Context3D.prototype.setDepthTest = function (tf) {
            if (tf) {
                this.renderContext.enable(this.renderContext.DEPTH_TEST);
            }
            else {
                this.renderContext.disable(this.renderContext.DEPTH_TEST);
            }
        };
        Context3D.prototype.setWriteDepth = function (tf) {
            if (this._contextSetTest.testZbuffer(tf)) {
                return;
            }
            this.renderContext.depthMask(tf);
        };
        Context3D.prototype.setBlendParticleFactors = function (type) {
            if (this._contextSetTest.testBlend(type)) {
                return;
            }
            switch (type) {
                case 0:
                    this.renderContext.blendFunc(this.renderContext.ONE, this.renderContext.ONE_MINUS_SRC_ALPHA);
                    break;
                case 1:
                    this.renderContext.blendFunc(this.renderContext.ONE, this.renderContext.ONE);
                    break;
                case 2:
                    this.renderContext.blendFunc(this.renderContext.DST_COLOR, this.renderContext.ZERO);
                    break;
                case 3:
                    this.renderContext.blendFunc(this.renderContext.ONE, this.renderContext.ONE_MINUS_SRC_COLOR);
                    break;
                case 4:
                    this.renderContext.blendFunc(this.renderContext.SRC_ALPHA, this.renderContext.ONE);
                    break;
                case -1:
                    this.renderContext.blendFunc(this.renderContext.SRC_ALPHA, this.renderContext.ONE_MINUS_SRC_ALPHA);
                    break;
            }
        };
        Context3D.prototype.setProgram = function ($program) {
            if (this._contextSetTest.testProgram($program)) {
                return;
            }
            this.renderContext.useProgram($program);
            this.setProgramNum++;
        };
        Context3D.prototype.getLocation = function ($program, $name) {
            return this.renderContext.getUniformLocation($program, $name);
        };
        //public locationDic: any = new Object();
        /** ***************************setvc */
        Context3D.prototype.setVcMatrix3fv = function ($program, $name, $m) {
            this.renderContext.uniformMatrix3fv($program.getWebGLUniformLocation($name), false, $m);
        };
        Context3D.prototype.setVcMatrix4fv = function ($program, $name, $m) {
            this.renderContext.uniformMatrix4fv($program.getWebGLUniformLocation($name), false, $m);
        };
        Context3D.prototype.setVpMatrix = function ($program, $m) {
            if (this._contextSetTest.testVp()) {
                return;
            }
            this.renderContext.uniformMatrix4fv($program.getWebGLUniformLocation("vpMatrix3D"), false, $m);
        };
        Context3D.prototype.setVc4fv = function ($program, $name, $m) {
            this.renderContext.uniform4fv($program.getWebGLUniformLocation($name), $m);
        };
        Context3D.prototype.setVc1fv = function ($program, $name, $m) {
            this.renderContext.uniform1fv($program.getWebGLUniformLocation($name), $m);
        };
        Context3D.prototype.setVc3fv = function ($program, $name, $m) {
            this.renderContext.uniform3fv($program.getWebGLUniformLocation($name), $m);
        };
        Context3D.prototype.setVc2fv = function ($program, $name, $m) {
            this.renderContext.uniform2fv($program.getWebGLUniformLocation($name), $m);
        };
        Context3D.prototype.setVcFloat = function ($program, $name, $m) {
            this.renderContext.uniform1fv($program.getWebGLUniformLocation($name), $m);
        };
        /** ******************************************* end setvc */
        Context3D.prototype.setuniform3f = function ($program, $name, a, b, c) {
            this.renderContext.uniform3f($program.getWebGLUniformLocation($name), a, b, c);
        };
        Context3D.prototype.setVcMatrix4fvLocation = function ($location, $m) {
            this.renderContext.uniformMatrix4fv($location, false, $m);
        };
        Context3D.prototype.setVc2f = function ($program, $name, a, b) {
            this.renderContext.uniform2f($program.getWebGLUniformLocation($name), a, b);
        };
        Context3D.prototype.setVcMatrix2fvLocation = function ($location, $m) {
            this.renderContext.uniformMatrix2fv($location, false, $m);
        };
        //  static maxLen:number=0
        Context3D.prototype.setVc4fvLocation = function ($location, $m) {
            //if (Context3D.maxLen < $m.length) {
            //    //console.log("在此处有变化renderContext",$m.length);
            //    Context3D.maxLen = $m.length;
            //}
            this.renderContext.uniform4fv($location, $m);
        };
        Context3D.prototype.setVa = function (dataId, dataWidth, dataBuffer) {
            this._contextSetTest.testVa(dataBuffer);
            this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, dataBuffer);
            this.renderContext.enableVertexAttribArray(dataId);
            this.renderContext.vertexAttribPointer(dataId, dataWidth, this.renderContext.FLOAT, false, 0, 0);
        };
        Context3D.prototype.pushVa = function (dataBuffer) {
            if (!this._contextSetTest.testVa(dataBuffer)) {
                this.renderContext.bindBuffer(this.renderContext.ARRAY_BUFFER, dataBuffer);
                return false;
            }
            else {
                return true;
            }
        };
        Context3D.prototype.setVaOffset = function (dataId, dataWidth, stride, offset) {
            if (!this._contextSetTest.enableVaAry[dataId]) {
                this.renderContext.enableVertexAttribArray(dataId);
                this._contextSetTest.enableVaAry[dataId] = true;
            }
            this.renderContext.vertexAttribPointer(dataId, dataWidth, this.renderContext.FLOAT, false, stride, offset);
        };
        Context3D.prototype.clearVa = function (dataId) {
            //this._contextSetTest.testVa(null);
            this._contextSetTest.enableVaAry[dataId] = false;
            this.renderContext.disableVertexAttribArray(dataId);
        };
        Context3D.prototype.drawCall = function ($iBuffer, $numTri) {
            this.renderContext.bindBuffer(this.renderContext.ELEMENT_ARRAY_BUFFER, $iBuffer);
            this.renderContext.drawElements(this.renderContext.TRIANGLES, $numTri, this.renderContext.UNSIGNED_SHORT, 0);
            // var errorID = this.renderContext.getError();
            // if (errorID != 0) {
            //     //console.log(errorID);
            // }
        };
        Context3D.prototype.drawLine = function ($iBuffer, $numTri) {
            this.renderContext.bindBuffer(this.renderContext.ELEMENT_ARRAY_BUFFER, $iBuffer);
            this.renderContext.drawElements(this.renderContext.LINES, $numTri, this.renderContext.UNSIGNED_SHORT, 0);
        };
        Context3D.prototype.setRenderTexture = function ($program, $name, $textureObject, $level, test) {
            if (test === void 0) { test = true; }
            if (test && this._contextSetTest.testTexture($name, $textureObject)) {
                return;
            }
            if ($level == 0) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE0);
            }
            else if ($level == 1) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE1);
            }
            else if ($level == 2) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE2);
            }
            else if ($level == 3) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE3);
            }
            else if ($level == 4) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE4);
            }
            else if ($level == 5) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE5);
            }
            else if ($level == 6) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE6);
            }
            this.renderContext.bindTexture(this.renderContext.TEXTURE_2D, $textureObject);
            this.renderContext.uniform1i($program.getWebGLUniformLocation($name), $level);
            this.setTextureNum++;
        };
        Context3D.prototype.setRenderTextureCube = function ($program, $name, $textureObject, $level) {
            if ($level == 0) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE0);
            }
            else if ($level == 1) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE1);
            }
            else if ($level == 2) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE2);
            }
            else if ($level == 3) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE3);
            }
            else if ($level == 4) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE4);
            }
            else if ($level == 5) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE5);
            }
            else if ($level == 6) {
                this.renderContext.activeTexture(this.renderContext.TEXTURE6);
            }
            this.renderContext.bindTexture(this.renderContext.TEXTURE_CUBE_MAP, $textureObject);
            this.renderContext.uniform1i(this.renderContext.getUniformLocation($program, $name), $level);
        };
        Context3D.prototype.updateTexture = function ($texture, $offsetx, $offsety, $img) {
            this.renderContext.bindTexture(this.renderContext.TEXTURE_2D, $texture);
            this.renderContext.texSubImage2D(this.renderContext.TEXTURE_2D, 0, $offsetx, $offsety, this.renderContext.RGBA, this.renderContext.UNSIGNED_BYTE, $img);
        };
        Context3D.prototype.getTexture = function ($img, $wrap, $filter, $mipmap) {
            // $mipmap=0
            if ($wrap === void 0) { $wrap = 0; }
            if ($filter === void 0) { $filter = 0; }
            if ($mipmap === void 0) { $mipmap = 0; }
            var $textureRect = new tl3d.Rectangle(0, 0, Math.pow(2, Math.ceil(Math.log($img.width) / Math.log(2))), Math.pow(2, Math.ceil(Math.log($img.height) / Math.log(2))));
            if ($textureRect.width != $img.width || $textureRect.height != $img.height) {
                //console.log("图片尺寸不为2幂")
                //alert("图片尺寸不为2幂")
                var $ctx = tl3d.UIManager.getInstance().getContext2D($textureRect.width, $textureRect.height, false);
                $ctx.drawImage($img, 0, 0, $img.width, $img.height, 0, 0, $textureRect.width, $textureRect.height);
                return this.getTexture($ctx.canvas, 0, 0);
            }
            //         let elementArrayBuffer  = this.renderContext.getParameter(this.renderContext.ELEMENT_ARRAY_BUFFER_BINDING);
            var text2DbIN = this.renderContext.getParameter(this.renderContext.TEXTURE_BINDING_2D);
            var textureObject = this.renderContext.createTexture();
            this.renderContext.bindTexture(this.renderContext.TEXTURE_2D, textureObject);
            this.renderContext.texImage2D(this.renderContext.TEXTURE_2D, 0, this.renderContext.RGBA, this.renderContext.RGBA, this.renderContext.UNSIGNED_BYTE, $img);
            var filterNum;
            if ($filter == 0) {
                filterNum = this.renderContext.LINEAR;
            }
            else {
                filterNum = this.renderContext.NEAREST;
            }
            var mipNum;
            if ($filter == 0) {
                if ($mipmap == 0) {
                    mipNum = this.renderContext.LINEAR;
                }
                else if ($mipmap == 1) {
                    mipNum = this.renderContext.LINEAR_MIPMAP_LINEAR;
                }
                else if ($mipmap == 2) {
                    mipNum = this.renderContext.LINEAR_MIPMAP_NEAREST;
                }
            }
            else {
                if ($mipmap == 0) {
                    mipNum = this.renderContext.NEAREST;
                }
                else if ($mipmap == 1) {
                    mipNum = this.renderContext.NEAREST_MIPMAP_LINEAR;
                }
                else if ($mipmap == 2) {
                    mipNum = this.renderContext.NEAREST_MIPMAP_NEAREST;
                }
            }
            this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_MAG_FILTER, filterNum);
            this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_MIN_FILTER, mipNum);
            if ($wrap == 0) {
                this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_WRAP_S, this.renderContext.REPEAT);
                this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_WRAP_T, this.renderContext.REPEAT);
            }
            else {
                this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_WRAP_S, this.renderContext.CLAMP_TO_EDGE);
                this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_WRAP_T, this.renderContext.CLAMP_TO_EDGE);
            }
            if ($mipmap != 0) {
                this.renderContext.generateMipmap(this.renderContext.TEXTURE_2D);
            }
            // this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, 1);
            if (text2DbIN) {
                this.renderContext.bindTexture(this.renderContext.TEXTURE_2D, text2DbIN);
            }
            return textureObject;
        };
        Context3D.prototype.creatTexture = function ($width, $height, $wrap) {
            if ($wrap === void 0) { $wrap = 0; }
            var text2DbIN = this.renderContext.getParameter(this.renderContext.TEXTURE_BINDING_2D);
            var $texture = this.renderContext.createTexture();
            this.renderContext.bindTexture(this.renderContext.TEXTURE_2D, $texture);
            this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_MAG_FILTER, this.renderContext.LINEAR);
            this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_MIN_FILTER, this.renderContext.LINEAR);
            if ($wrap == 0) {
                this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_WRAP_S, this.renderContext.REPEAT);
                this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_WRAP_T, this.renderContext.REPEAT);
            }
            else {
                this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_WRAP_S, this.renderContext.CLAMP_TO_EDGE);
                this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_WRAP_T, this.renderContext.CLAMP_TO_EDGE);
            }
            this.renderContext.texImage2D(this.renderContext.TEXTURE_2D, 0, this.renderContext.RGB, $width, $height, 0, this.renderContext.RGB, this.renderContext.UNSIGNED_BYTE, null);
            if (text2DbIN) {
                this.renderContext.bindTexture(this.renderContext.TEXTURE_2D, text2DbIN);
            }
            return $texture;
        };
        Context3D.prototype.createFramebuffer = function () {
            var fboBuffer = this.renderContext.createFramebuffer();
            this.renderContext.bindFramebuffer(this.renderContext.FRAMEBUFFER, fboBuffer);
            return fboBuffer;
        };
        Context3D.prototype.deleteBuffer = function (buffer) {
            if (!buffer) {
                //console.log("aaa12");
            }
            //var ooo:any = buffer;
            //ooo.destory = true;
            this.renderContext.deleteBuffer(buffer);
            //if (this.renderContext.getError() != 0) {
            //console.log("aaa12");
            //}
        };
        Context3D.prototype.deleteTexture = function (texture) {
            //return;
            //var ooo:any = texture;
            //ooo.destory = true;
            this.renderContext.deleteTexture(texture);
        };
        Context3D.prototype.deleteShader = function (shader) {
            //return;
            this.renderContext.deleteShader(shader.vShader);
            this.renderContext.deleteShader(shader.fShader);
            this.renderContext.deleteProgram(shader.program);
        };
        Context3D.prototype.cullFaceBack = function (tf) {
            if (this._contextSetTest.testCull(tf)) {
                return;
            }
            if (tf) {
                this.renderContext.enable(this.renderContext.CULL_FACE);
                this.renderContext.cullFace(this.renderContext.FRONT);
            }
            else {
                this.renderContext.disable(this.renderContext.CULL_FACE);
            }
        };
        Context3D.prototype.getFBO = function () {
            var fw = FBO.fw;
            var fh = FBO.fh;
            var frameBuffer = this.renderContext.createFramebuffer();
            this.renderContext.bindFramebuffer(this.renderContext.FRAMEBUFFER, frameBuffer);
            var depthRenderBuffer = this.renderContext.createRenderbuffer();
            this.renderContext.bindRenderbuffer(this.renderContext.RENDERBUFFER, depthRenderBuffer);
            this.renderContext.renderbufferStorage(this.renderContext.RENDERBUFFER, this.renderContext.DEPTH_COMPONENT16, fw, fh);
            this.renderContext.framebufferRenderbuffer(this.renderContext.FRAMEBUFFER, this.renderContext.DEPTH_ATTACHMENT, this.renderContext.RENDERBUFFER, depthRenderBuffer);
            var text2DbIN = this.renderContext.getParameter(this.renderContext.TEXTURE_BINDING_2D);
            var fTexture = this.renderContext.createTexture();
            this.renderContext.bindTexture(this.renderContext.TEXTURE_2D, fTexture);
            this.renderContext.texImage2D(this.renderContext.TEXTURE_2D, 0, this.renderContext.RGBA, fw, fh, 0, this.renderContext.RGBA, this.renderContext.UNSIGNED_BYTE, null);
            this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_MAG_FILTER, this.renderContext.LINEAR);
            this.renderContext.texParameteri(this.renderContext.TEXTURE_2D, this.renderContext.TEXTURE_MIN_FILTER, this.renderContext.LINEAR);
            this.renderContext.framebufferTexture2D(this.renderContext.FRAMEBUFFER, this.renderContext.COLOR_ATTACHMENT0, this.renderContext.TEXTURE_2D, fTexture, 0);
            this.renderContext.bindTexture(this.renderContext.TEXTURE_2D, null);
            this.renderContext.bindRenderbuffer(this.renderContext.RENDERBUFFER, null);
            this.renderContext.bindFramebuffer(this.renderContext.FRAMEBUFFER, null);
            var fbo = new FBO();
            fbo.frameBuffer = frameBuffer;
            fbo.depthBuffer = depthRenderBuffer;
            fbo.texture = fTexture;
            if (text2DbIN) {
                this.renderContext.bindTexture(this.renderContext.TEXTURE_2D, text2DbIN);
            }
            return fbo;
        };
        Context3D.prototype.clearTest = function () {
            this._contextSetTest.clear();
        };
        return Context3D;
    }());
    tl3d.Context3D = Context3D;
    var FBO = /** @class */ (function () {
        function FBO() {
        }
        FBO.fw = 512;
        FBO.fh = 512;
        return FBO;
    }());
    tl3d.FBO = FBO;
    var ContextSetTest = /** @class */ (function () {
        function ContextSetTest() {
            this.enableVaAry = new Array;
            this.vaAry = new Array;
            this._blendType = -1000;
            this._cullType = false;
            this._zbufferType = true;
            this._vpMatrix = false;
        }
        ContextSetTest.prototype.testTexture = function ($name, $textureObject) {
            if (this._textureDic[$name] == $textureObject) {
                return true;
            }
            else {
                this._textureDic[$name] = $textureObject;
                return false;
            }
        };
        ContextSetTest.prototype.testProgram = function ($program) {
            if (this._program == $program) {
                return true;
            }
            else {
                this._program = $program;
                this._textureDic = new Object();
                this._vpMatrix = false;
                return false;
            }
        };
        ContextSetTest.prototype.testVa = function (dataBuffer) {
            if (this._vabuffer == dataBuffer) {
                return true;
            }
            else {
                this._vabuffer = dataBuffer;
                return false;
            }
        };
        ContextSetTest.prototype.clear = function () {
            this._blendType = -1000;
            this._cullType = false;
            this._vpMatrix = false;
            this._program = null;
            this._vabuffer = null;
        };
        ContextSetTest.prototype.testBlend = function ($type) {
            if (this._blendType == $type) {
                return true;
            }
            else {
                this._blendType = $type;
                return false;
            }
        };
        ContextSetTest.prototype.testCull = function ($type) {
            if (this._cullType == $type) {
                return true;
            }
            else {
                this._cullType = $type;
                return false;
            }
        };
        ContextSetTest.prototype.testZbuffer = function ($type) {
            if (this._zbufferType == $type) {
                return true;
            }
            else {
                this._zbufferType = $type;
                return false;
            }
        };
        ContextSetTest.prototype.testVp = function () {
            if (this._vpMatrix) {
                return true;
            }
            else {
                this._vpMatrix = true;
                return false;
            }
        };
        return ContextSetTest;
    }());
    tl3d.ContextSetTest = ContextSetTest;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Scene_data = /** @class */ (function () {
        function Scene_data() {
        }
        Object.defineProperty(Scene_data, "viewMatrx3D", {
            get: function () {
                return Scene_data._viewMatrx3D;
            },
            set: function (value) {
                Scene_data._viewMatrx3D = value;
            },
            enumerable: true,
            configurable: true
        });
        Scene_data.sceneViewHW = 500;
        Scene_data.fileRoot = "";
        Scene_data.fileSub = "";
        Scene_data.soundPath = "skill/sound/";
        Scene_data.verticalScene = false;
        Scene_data.effectsLev = 2; //2高配1中配0低配
        Scene_data.camFar = 1000; //镜头最远距离
        Scene_data.frameTime = 1000 / 60;
        Scene_data.MAX_NUMBER = 10000000;
        Scene_data.scaleLight = [2.0];
        Scene_data.useByte = true;
        Scene_data.fogColor = [0, 0, 0];
        Scene_data.fogData = [825, 0.003];
        Scene_data.gameAngle = 0;
        Scene_data.sceneNumId = 0;
        Scene_data.supportBlob = false;
        return Scene_data;
    }());
    tl3d.Scene_data = Scene_data;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Shader3D = /** @class */ (function (_super) {
        __extends(Shader3D, _super);
        function Shader3D() {
            var _this = _super.call(this) || this;
            _this.fragment = _this.getFragmentShaderString();
            return _this;
        }
        Shader3D.prototype.encode = function () {
            this.vertex = this.getVertexShaderString();
            var $context = tl3d.Scene_data.context3D.renderContext;
            try {
                this.program = $context.createProgram();
            }
            catch (e) {
                console.error("engin init error");
            }
            this.vShader = $context.createShader($context.VERTEX_SHADER);
            this.fShader = $context.createShader($context.FRAGMENT_SHADER);
            $context.shaderSource(this.vShader, this.vertex);
            $context.shaderSource(this.fShader, this.fragment);
            $context.compileShader(this.vShader);
            $context.compileShader(this.fShader);
            $context.attachShader(this.program, this.vShader);
            $context.attachShader(this.program, this.fShader);
            this.binLocation($context);
            $context.linkProgram(this.program);
            //Scene_data.context3D.addProgram(this.program);
            this.localDic = new Object();
            //todo packageapp
            // var info: string = $context.getProgramInfoLog(this.program);
            // var vInfo: string = $context.getShaderInfoLog(this.vShader);
            // var fInfo: string = $context.getShaderInfoLog(this.fShader);
            // if (info != "") {
            //     if (vInfo == "" && fInfo == "") {
            //         return true;
            //     }
            //     //console.log("shader error: " + info + "," + vInfo + "," + fInfo);
            //     return false;
            // } else {
            //     return true;
            // }
            return true;
        };
        Shader3D.prototype.getWebGLUniformLocation = function ($name) {
            var local = this.localDic[$name];
            if (local) {
                return local;
            }
            else {
                this.localDic[$name] = tl3d.Scene_data.context3D.getLocation(this.program, $name);
                return this.localDic[$name];
            }
        };
        Shader3D.prototype.binLocation = function ($context) {
        };
        Shader3D.prototype.getVertexShaderString = function () {
            return "";
        };
        Shader3D.prototype.getFragmentShaderString = function () {
            return "";
        };
        Shader3D.prototype.destory = function () {
            this.vertex = null;
            this.fragment = null;
            this.name = null;
            this.localDic = null;
            tl3d.Scene_data.context3D.deleteShader(this);
        };
        return Shader3D;
    }(tl3d.ResCount));
    tl3d.Shader3D = Shader3D;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3D = /** @class */ (function (_super) {
        __extends(Display3D, _super);
        function Display3D() {
            var _this = _super.call(this) || this;
            _this.sceneVisible = true;
            _this._hasDestory = false;
            _this._onStage = false;
            return _this;
        }
        Display3D.prototype.update = function () {
        };
        Object.defineProperty(Display3D.prototype, "onStage", {
            get: function () {
                return this._onStage;
            },
            enumerable: true,
            configurable: true
        });
        Display3D.prototype.addStage = function () {
            this._onStage = true;
        };
        Display3D.prototype.removeStage = function () {
            this._onStage = false;
        };
        Display3D.prototype.resize = function () {
        };
        Display3D.prototype.destory = function () {
            if (this.objData) {
                this.objData.useNum--;
            }
        };
        return Display3D;
    }(tl3d.Object3D));
    tl3d.Display3D = Display3D;
})(tl3d || (tl3d = {}));
/// <reference path="../program/Shader3D.ts" />
/// <reference path="Display3D.ts" />

(function (tl3d) {
    var BaseDiplay3dShader = /** @class */ (function (_super) {
        __extends(BaseDiplay3dShader, _super);
        function BaseDiplay3dShader() {
            return _super.call(this) || this;
        }
        BaseDiplay3dShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "u2Texture");
        };
        BaseDiplay3dShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Position;" +
                "attribute vec2 u2Texture;" +
                "uniform mat4 viewMatrix3D;" +
                "uniform mat4 camMatrix3D;" +
                "uniform mat4 posMatrix3D;" +
                "varying vec2 v_texCoord;" +
                "void main(void)" +
                "{" +
                "   v_texCoord = vec2(u2Texture.x, u2Texture.y);" +
                "   vec4 vt0= vec4(v3Position, 1.0);" +
                "   vt0 = posMatrix3D * vt0;" +
                "   vt0 = camMatrix3D * vt0;" +
                "   vt0 = viewMatrix3D * vt0;" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        BaseDiplay3dShader.prototype.getFragmentShaderString = function () {
            var $str = "precision mediump float;\n" +
                "uniform sampler2D s_texture;\n" +
                "varying vec2 v_texCoord;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                "gl_FragColor =infoUv;\n" +
                "}";
            return $str;
        };
        BaseDiplay3dShader.BaseDiplay3dShader = "BaseDiplay3dShader";
        return BaseDiplay3dShader;
    }(tl3d.Shader3D));
    tl3d.BaseDiplay3dShader = BaseDiplay3dShader;
    var BaseDiplay3dSprite = /** @class */ (function (_super) {
        __extends(BaseDiplay3dSprite, _super);
        function BaseDiplay3dSprite() {
            var _this = _super.call(this) || this;
            _this.initData();
            _this.updateMatrix;
            return _this;
        }
        BaseDiplay3dSprite.prototype.initData = function () {
            tl3d.ProgrmaManager.getInstance().registe(BaseDiplay3dShader.BaseDiplay3dShader, new BaseDiplay3dShader);
            this.shader = tl3d.ProgrmaManager.getInstance().getProgram(BaseDiplay3dShader.BaseDiplay3dShader);
            this.program = this.shader.program;
            this.objData = new tl3d.ObjData;
            this.objData.vertices = new Array();
            this.objData.vertices.push(0, 0, 0);
            this.objData.vertices.push(100, 0, 0);
            this.objData.vertices.push(100, 0, 100);
            this.objData.uvs = new Array();
            this.objData.uvs.push(0, 0);
            this.objData.uvs.push(1, 0);
            this.objData.uvs.push(0, 1);
            this.objData.indexs = new Array();
            this.objData.indexs.push(0, 1, 2);
            this.loadTexture();
            this.upToGpu();
        };
        BaseDiplay3dSprite.prototype.loadTexture = function () {
            var $ctx = tl3d.UIManager.getInstance().getContext2D(128, 128, false);
            $ctx.fillStyle = "rgb(255,255,255)";
            $ctx.fillRect(0, 0, 128, 128);
            this._uvTextureRes = tl3d.TextureManager.getInstance().getCanvasTexture($ctx);
        };
        BaseDiplay3dSprite.prototype.upToGpu = function () {
            if (this.objData.indexs.length) {
                this.objData.treNum = this.objData.indexs.length;
                this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
                this.objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.uvs);
                this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            }
        };
        BaseDiplay3dSprite.prototype.update = function () {
            if (this.objData && this.objData.indexBuffer && this._uvTextureRes) {
                tl3d.Scene_data.context3D.setProgram(this.program);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "viewMatrix3D", tl3d.Scene_data.viewMatrx3D.m);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "camMatrix3D", tl3d.Scene_data.cam3D.cameraMatrix.m);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "posMatrix3D", this.posMatrix.m);
                tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
                tl3d.Scene_data.context3D.setVa(1, 2, this.objData.uvBuffer);
                tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this._uvTextureRes.texture, 0);
                tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
            }
        };
        return BaseDiplay3dSprite;
    }(tl3d.Display3D));
    tl3d.BaseDiplay3dSprite = BaseDiplay3dSprite;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display2DSprite = /** @class */ (function (_super) {
        __extends(Display2DSprite, _super);
        function Display2DSprite() {
            var _this = _super.call(this) || this;
            _this.batchPos = new Array;
            _this.objData = new tl3d.ObjData();
            _this.watchCaramMatrix = new tl3d.Matrix3D;
            _this.shader = tl3d.ProgrmaManager.getInstance().getProgram(tl3d.Sprite2DShader.SPRITE2D_SHADER);
            _this.program = _this.shader.program;
            return _this;
        }
        Display2DSprite.prototype.setInfo = function ($configurl, $imgurl, $fun) {
            if (!this._imgAtlas) {
                this._imgAtlas = new tl3d.UIAtlas;
            }
            this._imgAtlas.setInfo($configurl, $imgurl, $fun);
        };
        Display2DSprite.prototype.getSprite = function ($name) {
            var obj = new Sprite();
            obj.uvData = this._imgAtlas.getRec($name);
            return obj;
        };
        Display2DSprite.prototype.addSprite = function () {
            var spriteAry = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                spriteAry[_i] = arguments[_i];
            }
            for (var i = 0; i < spriteAry.length; i++) {
                this.batchPos.push(spriteAry[i]);
            }
            this.applyData();
        };
        Display2DSprite.prototype.applyData = function () {
            this.objData.vertices.length = 0;
            this.objData.uvs.length = 0;
            this.objData.indexs.length = 0;
            for (var i = 0; i < this.batchPos.length; i++) {
                var uv = this.batchPos[i].uvData;
                var whscale = uv.pixelHeight / uv.pixelWitdh;
                this.objData.vertices.push(-0.5 * uv.width, 1 * whscale * uv.width, 0, 0.5 * uv.width, 1 * whscale * uv.width, 0, 0.5 * uv.width, 0, 0, -0.5 * uv.width, 0, 0);
                this.objData.uvs.push(uv.x, uv.y, i, uv.x + uv.width, uv.y, i, uv.x + uv.width, uv.y + uv.height, i, uv.x, uv.y + uv.height, i);
                this.objData.indexs.push(i * 4, 1 + i * 4, 2 + i * 4, i * 4, 2 + i * 4, 3 + i * 4);
            }
            this.objData.treNum = this.objData.indexs.length;
            if (this.objData.vertexBuffer) {
                tl3d.Scene_data.context3D.uploadBuff3DByBuffer(this.objData.vertexBuffer, this.objData.vertices);
                tl3d.Scene_data.context3D.uploadBuff3DByBuffer(this.objData.uvBuffer, this.objData.uvs);
                tl3d.Scene_data.context3D.uploadIndexBuff3DByBuffer(this.objData.indexBuffer, this.objData.indexs);
            }
            else {
                this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
                this.objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.uvs);
                this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            }
        };
        Display2DSprite.prototype.update = function () {
            if (this.batchPos.length == 0) {
                return;
            }
            this.watchCaramMatrix.identity();
            this.watchCaramMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationY, tl3d.Vector3D.Y_AXIS);
            this.watchCaramMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationX, tl3d.Vector3D.X_AXIS);
            tl3d.Scene_data.context3D.setProgram(this.program);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "viewMatrix3D", tl3d.Scene_data.viewMatrx3D.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "camMatrix3D", tl3d.Scene_data.cam3D.cameraMatrix.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "watchCamMatrix3D", this.watchCaramMatrix.m);
            for (var i = 0; i < this.batchPos.length; i++) {
                tl3d.Scene_data.context3D.setVc4fv(this.shader, "posdata[" + i + "]", this.batchPos[i].posData);
            }
            tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this._imgAtlas.texture, 0);
            tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
            tl3d.Scene_data.context3D.setVa(1, 3, this.objData.uvBuffer);
            tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
        };
        return Display2DSprite;
    }(tl3d.Display3D));
    tl3d.Display2DSprite = Display2DSprite;
    var Sprite = /** @class */ (function (_super) {
        __extends(Sprite, _super);
        function Sprite() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.posData = [0, 0, 0, 100];
            return _this;
        }
        Sprite.prototype.setPos = function (xpos, ypos, zpos) {
            this.x = xpos;
            this.y = ypos;
            this.z = zpos;
        };
        Object.defineProperty(Sprite.prototype, "scale", {
            get: function () {
                return this._scaleX;
            },
            set: function (value) {
                this._scaleX = value;
                this.posData[3] = 100 * value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sprite.prototype, "x", {
            set: function (value) {
                this._x = value;
                this.posData[0] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sprite.prototype, "y", {
            set: function (value) {
                this._y = value;
                this.posData[1] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sprite.prototype, "z", {
            set: function (value) {
                this._z = value;
                this.posData[2] = value;
            },
            enumerable: true,
            configurable: true
        });
        return Sprite;
    }(tl3d.Object3D));
})(tl3d || (tl3d = {}));
/// <reference path="Display3D.ts" />

(function (tl3d) {
    var Display2dMovie = /** @class */ (function (_super) {
        __extends(Display2dMovie, _super);
        function Display2dMovie() {
            var _this = _super.call(this) || this;
            _this.batchPos = new Array;
            _this._time = 0;
            _this._allFrame = 12;
            _this._uvData = [0, 0];
            _this._uWidth = 0;
            _this._vWidth = 0;
            _this._state = 0;
            _this.frameRate = 3;
            _this.objData = new tl3d.ObjData();
            _this.watchCaramMatrix = new tl3d.Matrix3D;
            _this.shader = tl3d.ProgrmaManager.getInstance().getProgram(tl3d.Movie2DShader.MOVIE2D_SHADER);
            _this.program = _this.shader.program;
            return _this;
        }
        Display2dMovie.prototype.update = function () {
            this.watchCaramMatrix.identity();
            this.watchCaramMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationY, tl3d.Vector3D.Y_AXIS);
            this.watchCaramMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationX, tl3d.Vector3D.X_AXIS);
            tl3d.Scene_data.context3D.setProgram(this.program);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "viewMatrix3D", tl3d.Scene_data.viewMatrx3D.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "camMatrix3D", tl3d.Scene_data.cam3D.cameraMatrix.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "watchCamMatrix3D", this.watchCaramMatrix.m);
            for (var i = 0; i < this.batchPos.length; i++) {
                tl3d.Scene_data.context3D.setVc4fv(this.shader, "posdata[" + i + "]", this.batchPos[i].posData);
            }
            tl3d.Scene_data.context3D.setVc2fv(this.shader, "outuv", this._uvData);
            tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this.movieTexture, 0);
            tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
            tl3d.Scene_data.context3D.setVa(1, 3, this.objData.uvBuffer);
            tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
        };
        Display2dMovie.prototype.updateFrame = function (t) {
            this._time += t;
            var _curentFrame = tl3d.Util.float2int(this._time / (tl3d.Scene_data.frameTime * 2) / this.frameRate);
            if (_curentFrame >= this._allFrame) {
                if (this._state == 0) {
                    this._time = 0;
                    _curentFrame = 0;
                }
                else if (this._state == 1) {
                    _curentFrame = this._allFrame - 1;
                }
                else if (this._state == 2) {
                    this.play("stand");
                    _curentFrame = 0;
                    this._state = 0;
                }
                else if (this._state == 3) {
                }
            }
            this._uvData[0] = _curentFrame * this._uWidth;
        };
        Display2dMovie.prototype.play = function (action, state) {
            if (state === void 0) { state = 0; }
            this._state = state;
            this._time = 0;
            if (action == "walk") {
                this._uvData[1] = this._vWidth;
            }
            else if (action.indexOf("attack") != -1) {
                this._uvData[1] = this._vWidth * 2;
            }
            else {
                this._uvData[1] = 0;
            }
        };
        Display2dMovie.prototype.addSun = function ($obj) {
            this.batchPos.push($obj);
        };
        Display2dMovie.prototype.setUrl = function ($url) {
            //TextureManager.getInstance().getTexture(Scene_data.fileRoot + $url, ($text:WebGLTexture) => {this.movieTexture = $text });
        };
        Display2dMovie.prototype.initData = function (num, scale, uscale, vscale, allFrame, random) {
            if (random === void 0) { random = false; }
            this.objData.vertices.length = 0;
            this.objData.uvs.length = 0;
            this.objData.indexs.length = 0;
            this._uWidth = uscale;
            this._vWidth = vscale;
            this._allFrame = allFrame;
            for (var i = 0; i < num; i++) {
                this.objData.vertices.push(-0.5 * scale, 1, 0, 0.5 * scale, 1, 0, 0.5 * scale, 0, 0, -0.5 * scale, 0, 0);
                var upox = 0;
                if (random) {
                    upox = tl3d.Util.float2int(allFrame * Math.random()) * uscale;
                }
                this.objData.uvs.push(0 + upox, 0, i, uscale + upox, 0, i, uscale + upox, 1 * vscale, i, 0 + upox, 1 * vscale, i);
                this.objData.indexs.push(i * 4, 1 + i * 4, 2 + i * 4, i * 4, 2 + i * 4, 3 + i * 4);
            }
            this.objData.treNum = this.objData.indexs.length;
            if (this.objData.vertexBuffer) {
                tl3d.Scene_data.context3D.uploadBuff3DByBuffer(this.objData.vertexBuffer, this.objData.vertices);
                tl3d.Scene_data.context3D.uploadBuff3DByBuffer(this.objData.uvBuffer, this.objData.uvs);
                tl3d.Scene_data.context3D.uploadIndexBuff3DByBuffer(this.objData.indexBuffer, this.objData.indexs);
            }
            else {
                this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
                this.objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.uvs);
                this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            }
        };
        Display2dMovie.prototype.addStage = function () {
            _super.prototype.addStage.call(this);
            if (this.batchPos.length) {
                for (var i = 0; i < this.batchPos.length; i++) {
                    this.batchPos[i].add();
                }
            }
        };
        Display2dMovie.prototype.removeStage = function () {
            _super.prototype.removeStage.call(this);
            if (this.batchPos.length) {
                for (var i = 0; i < this.batchPos.length; i++) {
                    this.batchPos[i].remove();
                }
            }
        };
        return Display2dMovie;
    }(tl3d.Display3D));
    tl3d.Display2dMovie = Display2dMovie;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DSky = /** @class */ (function (_super) {
        __extends(Display3DSky, _super);
        function Display3DSky() {
            var _this = _super.call(this) || this;
            _this.shader = tl3d.ProgrmaManager.getInstance().getProgram(tl3d.SkyShader.Sky_Shader);
            _this.program = _this.shader.program;
            return _this;
        }
        Display3DSky.prototype.setObjUrl = function (value) {
            var _this = this;
            this.objurl = value;
            tl3d.ObjDataManager.getInstance().getObjData(tl3d.Scene_data.fileRoot + value, function ($objData) {
                _this.objData = $objData;
            });
        };
        Display3DSky.prototype.setCubeUrl = function (value) {
            var _this = this;
            tl3d.TextureManager.getInstance().loadCubeTexture(value, function ($ary) { _this.cubeTextList = $ary; });
        };
        Display3DSky.prototype.update = function () {
            tl3d.Scene_data.context3D.setProgram(this.program);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "viewMatrix3D", tl3d.Scene_data.viewMatrx3D.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "camMatrix3D", tl3d.Scene_data.cam3D.cameraMatrix.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "posMatrix3D", this.posMatrix.m);
            if (this.cubeTextList) {
                tl3d.Scene_data.context3D.setRenderTextureCube(this.program, "s_texture", this.cubeTextList[0], 0);
            }
            tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
            tl3d.Scene_data.context3D.setVa(1, 3, this.objData.normalsBuffer);
            tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
        };
        return Display3DSky;
    }(tl3d.Display3D));
    tl3d.Display3DSky = Display3DSky;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DSprite = /** @class */ (function (_super) {
        __extends(Display3DSprite, _super);
        function Display3DSprite() {
            var _this = _super.call(this) || this;
            _this.time = 0;
            _this.dynamic = false;
            _this._rotationMatrix = new tl3d.Matrix3D;
            return _this;
            //this.lightMapTexture = TextureManager.getInstance().defaultLightMap;
        }
        Object.defineProperty(Display3DSprite.prototype, "aabbVect", {
            get: function () {
                if (!this._aabbVect) {
                    var $aabb = this.aabb;
                    var ax = $aabb.x;
                    var ay = $aabb.y;
                    var az = $aabb.z;
                    var bx = $aabb.width;
                    var by = $aabb.height;
                    var bz = $aabb.depth;
                    this._aabbVect = new Array;
                    this._aabbVect.push(new tl3d.Vector3D(ax, ay, az));
                    this._aabbVect.push(new tl3d.Vector3D(ax + bx, ay, az));
                    this._aabbVect.push(new tl3d.Vector3D(ax, ay + by, az));
                    this._aabbVect.push(new tl3d.Vector3D(ax, ay, az + bz));
                    this._aabbVect.push(new tl3d.Vector3D(ax + bx, ay + by, az));
                    this._aabbVect.push(new tl3d.Vector3D(ax + bx, ay, az + bz));
                    this._aabbVect.push(new tl3d.Vector3D(ax, ay + by, az + bz));
                    this._aabbVect.push(new tl3d.Vector3D(ax + bx, ay + by, az + bz));
                }
                return this._aabbVect;
            },
            enumerable: true,
            configurable: true
        });
        Display3DSprite.prototype.setObjUrl = function (value) {
            var _this = this;
            this.objurl = value;
            tl3d.ObjDataManager.getInstance().getObjData(tl3d.Scene_data.fileRoot + value, function ($obj) {
                _this.objData = $obj;
                if (_this.material) {
                    if (!_this.objData.tangentBuffer) {
                        tl3d.ObjDataManager.getInstance().creatTBNBuffer(_this.objData);
                    }
                }
            });
        };
        Display3DSprite.prototype.setPicUrl = function ($str) {
            var _this = this;
            this.picUrl = $str;
            tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + $str, function ($texture) {
                _this.baseTexture = $texture;
            });
        };
        Display3DSprite.prototype.setLightMapUrl = function (value) {
            var _this = this;
            if (!value || value == "") {
                return;
            }
            var url = tl3d.Scene_data.fileRoot + value;
            tl3d.TextureManager.getInstance().getTexture(url, function ($texture) {
                //this.lightMapTexture = $texture;
                _this.lightMapTextureRes = $texture;
            });
        };
        Object.defineProperty(Display3DSprite.prototype, "lightMapTexture", {
            get: function () {
                if (!this.lightMapTextureRes) {
                    //alert("无光照贴图") 
                    //console.log("无光照贴图------------------------------------");
                    return null;
                }
                return this.lightMapTextureRes.texture;
            },
            enumerable: true,
            configurable: true
        });
        Display3DSprite.prototype.setMaterialUrl = function (value, $paramData) {
            var _this = this;
            if ($paramData === void 0) { $paramData = null; }
            value = value.replace("_byte.txt", ".txt");
            value = value.replace(".txt", "_byte.txt");
            this.materialUrl = tl3d.Scene_data.fileRoot + value;
            //var materialshader: MaterialShader = new MaterialShader;
            tl3d.MaterialManager.getInstance().getMaterialByte(this.materialUrl, function ($material) {
                _this.material = $material;
                if (_this.material.useNormal) {
                    if (_this.objData && !_this.objData.tangentBuffer) {
                        tl3d.ObjDataManager.getInstance().creatTBNBuffer(_this.objData);
                    }
                }
                if (_this.material.usePbr || _this.material.directLight) {
                    _this._rotationData = new Float32Array(9);
                    _this.updateRotationMatrix();
                }
                if ($paramData) {
                    _this.materialParam = new tl3d.MaterialBaseParam();
                    _this.materialParam.setData(_this.material, $paramData);
                }
            }, null, true, tl3d.MaterialShader.MATERIAL_SHADER, tl3d.MaterialShader);
        };
        Object.defineProperty(Display3DSprite.prototype, "lightProbe", {
            get: function () {
                return this._lightProbe;
            },
            set: function (value) {
                this._lightProbe = value;
                if (this._lightProbe) {
                    if (!this.resultSHVec) {
                        this.resultSHVec = new Array;
                        var ary = [0.4444730390920146, -0.3834955622240026, -0.33124467509627725, 0.09365654209093091,
                            -0.05673310882817577, 0.2120523322966496, 0.02945768486978205, -0.04965996229802928, -0.1136529129285836];
                        for (var i = 0; i < 9; i++) {
                            this.resultSHVec.push(new tl3d.Vector3D(ary[i], ary[i], ary[i]));
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Display3DSprite.prototype.update = function () {
            if (this.dynamic) {
                if (!this.sceneVisible) {
                    return;
                }
            }
            this.updateMaterial();
            // return;
            // Scene_data.context3D.setProgram(this.program);
            // Scene_data.context3D.setVcMatrix4fv(this.program, "viewMatrix3D", Scene_data.viewMatrx3D.m);
            // Scene_data.context3D.setVcMatrix4fv(this.program, "camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            // Scene_data.context3D.setVcMatrix4fv(this.program, "posMatrix3D", this.posMatrix.m);
            // var mk = [0, 0, 0, 0];
            // Scene_data.context3D.setVc4fv(this.program, "testconst", mk);
            // var mk2 = [1.5, 0, 0, 0];
            // Scene_data.context3D.setVc4fv(this.program, "testconst2", mk2);
            // //if (this.baseTexture) {
            // //    Scene_data.context3D.setRenderTexture(this.program, "s_texture", this.baseTexture,0);
            // //}
            // Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
            // Scene_data.context3D.setVa(1, 2, this.objData.uvBuffer);
            // Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
        };
        Display3DSprite.prototype.updateMaterial = function () {
            if (!this.material || !this.objData) {
                return;
            }
            tl3d.Scene_data.context3D.setBlendParticleFactors(this.material.blendMode);
            tl3d.Scene_data.context3D.cullFaceBack(this.material.backCull);
            this.updateBind();
            ////console.log(this.material.url);
            tl3d.Scene_data.context3D.setProgram(this.material.program);
            tl3d.Scene_data.context3D.setWriteDepth(this.material.writeZbuffer);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.material.shader, "posMatrix3D", this.posMatrix.m);
            this.setCam();
            //this.setBaseMaterialVc(this.material);
            this.setMaterialVc(this.material, this.materialParam);
            this.setMaterialTexture(this.material, this.materialParam);
            this.setDirectLight(this.material);
            this.setMaterialVa();
            tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
        };
        Display3DSprite.prototype.setMaterialVa = function () {
            if (this.objData.compressBuffer) {
                this.setMaterialVaCompress();
            }
            else {
                this.setMaterialVaIndependent();
            }
        };
        Display3DSprite.prototype.setMaterialVaIndependent = function () {
            tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
            tl3d.Scene_data.context3D.setVa(1, 2, this.objData.uvBuffer);
            if (!(this.material.directLight || this.material.noLight)) {
                tl3d.Scene_data.context3D.setVa(2, 2, this.objData.lightUvBuffer);
            }
            if (this.material.usePbr || this.material.directLight) {
                tl3d.Scene_data.context3D.setVa(3, 3, this.objData.normalsBuffer);
                tl3d.Scene_data.context3D.setVcMatrix3fv(this.material.shader, "rotationMatrix3D", this._rotationData);
            }
            if (this.material.useNormal) {
                tl3d.Scene_data.context3D.setVa(4, 3, this.objData.tangentBuffer);
                tl3d.Scene_data.context3D.setVa(5, 3, this.objData.bitangentBuffer);
            }
        };
        Display3DSprite.prototype.setMaterialVaCompress = function () {
            var tf = tl3d.Scene_data.context3D.pushVa(this.objData.vertexBuffer);
            if (tf) {
                return;
            }
            tl3d.Scene_data.context3D.setVaOffset(0, 3, this.objData.stride, 0);
            tl3d.Scene_data.context3D.setVaOffset(1, 2, this.objData.stride, this.objData.uvsOffsets);
            if (!(this.material.directLight || this.material.noLight)) {
                tl3d.Scene_data.context3D.setVaOffset(2, 2, this.objData.stride, this.objData.lightuvsOffsets);
            }
            if (this.material.usePbr || this.material.directLight) {
                tl3d.Scene_data.context3D.setVaOffset(3, 3, this.objData.stride, this.objData.normalsOffsets);
                tl3d.Scene_data.context3D.setVcMatrix3fv(this.material.shader, "rotationMatrix3D", this._rotationData);
            }
            if (this.material.useNormal) {
                tl3d.Scene_data.context3D.setVaOffset(4, 3, this.objData.stride, this.objData.tangentsOffsets);
                tl3d.Scene_data.context3D.setVaOffset(5, 3, this.objData.stride, this.objData.bitangentsOffsets);
            }
        };
        Display3DSprite.prototype.setDirectLight = function ($material) {
            if ($material.directLight) {
                tl3d.Scene_data.context3D.setVc3fv($material.shader, "ambientColor", tl3d.Scene_data.light.ambientColor);
                tl3d.Scene_data.context3D.setVc3fv($material.shader, "sunDirect", tl3d.Scene_data.light.sunDirect);
                tl3d.Scene_data.context3D.setVc3fv($material.shader, "sunColor", tl3d.Scene_data.light.sunColor);
            }
        };
        Display3DSprite.prototype.setCam = function () {
            // var mvc:Float32Array = new Float32Array(16 * 3);
            // mvc.set(this.posMatrix.m,0);
            // mvc.set(Scene_data.viewMatrx3D.m,16);
            // mvc.set(Scene_data.cam3D.cameraMatrix.m,32);
            //Scene_data.context3D.setVcMatrix4fv(this.material.shader, "viewMatrix3D", Scene_data.viewMatrx3D.m);
            //Scene_data.context3D.setVcMatrix4fv(this.material.shader, "camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            //var m:Matrix3D = new Matrix3D;
            //m.prepend(Scene_data.viewMatrx3D);
            // m.prepend(Scene_data.cam3D.cameraMatrix);
            //Scene_data.context3D.setVcMatrix4fv(this.material.shader, "vpMatrix3D", Scene_data.vpMatrix.m);
            tl3d.Scene_data.context3D.setVpMatrix(this.material.shader, tl3d.Scene_data.vpMatrix.m);
        };
        Display3DSprite.prototype.setBind = function ($bindTarget, $bindSocket) {
            this.bindTarget = $bindTarget;
            this.bindSocket = $bindSocket;
            this.bindMatrix = new tl3d.Matrix3D();
        };
        Display3DSprite.prototype.setGroup = function ($pos, $rotaion, $scale) {
            this._isInGroup = true;
            this._groupPos = $pos;
            this._groupRotation = $rotaion;
            this._groupScale = $scale;
            this.groupMatrix = new tl3d.Matrix3D();
            this.groupRotationMatrix = new tl3d.Matrix3D();
            this.groupMatrix.isIdentity = false;
            this.groupMatrix.identity();
            this.groupMatrix.appendScale($scale.x, $scale.y, $scale.z);
            this.groupMatrix.appendRotation($rotaion.x, tl3d.Vector3D.X_AXIS);
            this.groupMatrix.appendRotation($rotaion.y, tl3d.Vector3D.Y_AXIS);
            this.groupMatrix.appendRotation($rotaion.z, tl3d.Vector3D.Z_AXIS);
            this.groupMatrix.appendTranslation($pos.x, $pos.y, $pos.z);
            this.groupRotationMatrix.isIdentity = false;
            this.groupRotationMatrix.identity();
            this.groupRotationMatrix.prependRotation($rotaion.z, tl3d.Vector3D.Z_AXIS);
            this.groupRotationMatrix.prependRotation($rotaion.y, tl3d.Vector3D.Y_AXIS);
            this.groupRotationMatrix.prependRotation($rotaion.x, tl3d.Vector3D.X_AXIS);
        };
        Display3DSprite.prototype.updateBind = function () {
            if (this.bindTarget) {
                this.posMatrix.identity();
                this.posMatrix.appendScale(this._scaleX, this._scaleY, this._scaleZ);
                if (this._isInGroup) {
                    this.posMatrix.append(this.groupMatrix);
                    //posMatrix.prependTranslation(groupPos.x, groupPos.y, groupPos.z);
                    //posMatrix.prependRotation(groupRotation.z, Vector3D.Z_AXIS);
                    //posMatrix.prependRotation(groupRotation.y, Vector3D.Y_AXIS);
                    //posMatrix.prependRotation(groupRotation.x, Vector3D.X_AXIS);
                    //posMatrix.prependScale(groupScale.x, groupScale.y, groupScale.z);
                }
                this.bindTarget.getSocket(this.bindSocket, this.bindMatrix);
                this.posMatrix.append(this.bindMatrix);
                this.bindMatrix.copyTo(this._rotationMatrix);
                this._rotationMatrix.identityPostion();
                if (this._isInGroup) {
                    this._rotationMatrix.prepend(this.groupRotationMatrix);
                    //_rotationMatrix.prependRotation(groupRotation.z, Vector3D.Z_AXIS);
                    //_rotationMatrix.prependRotation(groupRotation.y, Vector3D.Y_AXIS);
                    //_rotationMatrix.prependRotation(groupRotation.x, Vector3D.X_AXIS);
                }
                this.sceneVisible = this.bindTarget.visible;
            }
        };
        Display3DSprite.prototype.setBaseMaterialVc = function ($material) {
            var t = 0;
            if ($material.hasTime) {
                t = (tl3d.TimeUtil.getTimer(this._scene ? this._scene.startTime : tl3d.TimeUtil.START_TIME) - this.time) % 100000 * 0.001;
            }
            if ($material.hasTime || $material.usePbr || $material.useKill) {
                tl3d.Scene_data.context3D.setVc4fv($material.shader, "fc0", [1, 0, $material.killNum, t]); //sceneEvnScale,null,killNum,time;
            }
            if ($material.scaleLightMap) {
                tl3d.Scene_data.context3D.setVcFloat($material.shader, "scalelight", tl3d.Scene_data.scaleLight);
            }
            if ($material.usePbr || $material.fogMode == 1) {
                this.setCamPos($material);
            }
            if ($material.fogMode != 0) {
                tl3d.Scene_data.context3D.setVc2fv($material.shader, "fogdata", tl3d.Scene_data.fogData);
                tl3d.Scene_data.context3D.setVc3fv($material.shader, "fogcolor", tl3d.Scene_data.fogColor);
            }
        };
        Display3DSprite.prototype.setCamPos = function ($material) {
            // var p: Vector3D = new Vector3D(Scene_data.cam3D.x, Scene_data.cam3D.y, Scene_data.cam3D.z, 1.0);
            // p.scaleBy(1/100)
            // Scene_data.context3D.setVc4fv($material.shader, "fc2", [p.x,p.y,p.z,p.w]);
            $material.updateCam(tl3d.Scene_data.cam3D.x / 100, tl3d.Scene_data.cam3D.y / 100, tl3d.Scene_data.cam3D.z / 100);
        };
        Display3DSprite.prototype.setMaterialVc = function ($material, $mp) {
            if ($mp === void 0) { $mp = null; }
            if ($material.fcNum <= 0) {
                return;
            }
            var t = 0;
            if ($material.hasTime) {
                t = (tl3d.TimeUtil.getTimer(this._scene ? this._scene.startTime : tl3d.TimeUtil.START_TIME) - this.time) % 100000 * 0.001;
            }
            $material.update(t);
            this.setCamPos($material);
            if ($mp) {
                $mp.update();
            }
            tl3d.Scene_data.context3D.setVc4fv($material.shader, "fc", $material.fcData);
            ////console.log($material.fcData);
            // var constVec:Array<ConstItem> = $material.constList;
            // for(var i:number=0;i<constVec.length;i++){
            //     Scene_data.context3D.setVc4fv($material.shader, constVec[i].name, constVec[i].vecNum);
            // }
        };
        Display3DSprite.prototype.setMaterialTexture = function ($material, $mp) {
            if ($mp === void 0) { $mp = null; }
            var texVec = $material.texList;
            for (var i = 0; i < texVec.length; i++) {
                if (texVec[i].type == tl3d.TexItem.LIGHTMAP) {
                    //_context.setTextureAt(texVec[i].id, lightMapTexture);
                    tl3d.Scene_data.context3D.setRenderTexture($material.shader, texVec[i].name, this.lightMapTexture, texVec[i].id);
                }
                else if (texVec[i].type == tl3d.TexItem.LTUMAP && tl3d.Scene_data.pubLut) {
                    tl3d.Scene_data.context3D.setRenderTexture($material.shader, texVec[i].name, tl3d.Scene_data.pubLut, texVec[i].id);
                    //_context.setTextureAt(texVec[i].id, Scene_data.prbLutTexture.texture);
                }
                else if (texVec[i].type == tl3d.TexItem.CUBEMAP) {
                    if ($material.useDynamicIBL) { // && _reflectionTextureVo) {
                        //_context.setTextureAt(texVec[i].id, _reflectionTextureVo.texture);
                    }
                    else {
                        var index = Math.floor($material.roughness * 5);
                        if (tl3d.Scene_data.skyCubeMap) {
                            var cubeTexture = tl3d.Scene_data.skyCubeMap[index];
                            tl3d.Scene_data.context3D.setRenderTextureCube($material.program, texVec[i].name, cubeTexture, texVec[i].id);
                        }
                    }
                }
                //else if (texVec[i].type == TexItem.HEIGHTMAP) {
                //    //_context.setTextureAt(texVec[i].id, _cubeTexture);
                //    setHeightTexture(texVec[i].id);
                //} else if (texVec[i].type == TexItem.REFRACTIONMAP) {
                //    if (_reflectionTextureVo) {
                //        _context.setTextureAt(texVec[i].id, _reflectionTextureVo.ZeTexture);
                //    }
                //}
                else {
                    //_context.setTextureAt(texVec[i].id, texVec[i].texture);
                    if (texVec[i].texture) {
                        tl3d.Scene_data.context3D.setRenderTexture($material.shader, texVec[i].name, texVec[i].texture, texVec[i].id);
                    }
                }
            }
            if ($mp) {
                for (i = 0; i < $mp.dynamicTexList.length; i++) {
                    //_context.setTextureAt($mParam.dynamicTexList[i].target.id, $mParam.dynamicTexList[i].texture);
                    if ($mp.dynamicTexList[i].target) {
                        tl3d.Scene_data.context3D.setRenderTexture($material.shader, $mp.dynamicTexList[i].target.name, $mp.dynamicTexList[i].texture, $mp.dynamicTexList[i].target.id);
                    }
                }
            }
        };
        Display3DSprite.prototype.checkMaterialTexture = function ($material) {
            var texVec = $material.texList;
            for (var i = 0; i < texVec.length; i++) {
                if (texVec[i].type == tl3d.TexItem.LIGHTMAP) {
                    if (!this.lightMapTexture) {
                        return false;
                    }
                }
                else if (texVec[i].type == tl3d.TexItem.LTUMAP) {
                    if (!tl3d.Scene_data.pubLut) {
                        return false;
                    }
                }
                else if (texVec[i].type == tl3d.TexItem.CUBEMAP) {
                    if ($material.useDynamicIBL) { // && _reflectionTextureVo) {
                        //_context.setTextureAt(texVec[i].id, _reflectionTextureVo.texture);
                    }
                    else {
                        if (!tl3d.Scene_data.skyCubeMap) {
                            return false;
                        }
                    }
                }
                else {
                    if (!texVec[i].texture) {
                        return false;
                    }
                }
            }
            return true;
        };
        Display3DSprite.prototype.updateRotationMatrix = function () {
            try {
                this._rotationMatrix.identity();
                this._rotationMatrix.appendRotation(this._rotationX, tl3d.Vector3D.X_AXIS);
                this._rotationMatrix.appendRotation(this._rotationY, tl3d.Vector3D.Y_AXIS);
                this._rotationMatrix.appendRotation(this._rotationZ, tl3d.Vector3D.Z_AXIS);
                if (this._rotationData) {
                    this._rotationMatrix.getRotaion(this._rotationData);
                }
            }
            catch (err) {
                //console.log("在此处理错误1");
            }
        };
        Display3DSprite.prototype.setPos = function ($v3d) {
            this.x = $v3d.x;
            this.y = $v3d.y + 10;
            this.z = $v3d.z;
        };
        Display3DSprite.prototype.destory = function () {
            _super.prototype.destory.call(this);
            this.name = null;
            this.objurl = null;
            this.picUrl = null;
            this.materialUrl = null;
            if (this.material) {
                this.material.useNum--;
            }
            if (this.materialParam) {
                this.materialParam.destory();
                this.materialParam = null;
            }
            if (this.lightMapTextureRes) {
                this.lightMapTextureRes.clearUseNum();
            }
            this._rotationMatrix = null;
            this._rotationData = null;
            this.bindMatrix = null;
            this.bindTarget = null;
            this.bindSocket = null;
            this._groupPos = null;
            this._groupRotation = null;
            this._groupScale = null;
            this.groupMatrix = null;
            this.groupRotationMatrix = null;
        };
        return Display3DSprite;
    }(tl3d.Display3D));
    tl3d.Display3DSprite = Display3DSprite;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DUISprite = /** @class */ (function (_super) {
        __extends(Display3DUISprite, _super);
        function Display3DUISprite() {
            var _this = _super.call(this) || this;
            _this.uiMatrix = new tl3d.Matrix3D;
            _this.uiMatrix.prependTranslation(0, 0, 600);
            _this.uiMatrix.prependRotation(-15, tl3d.Vector3D.X_AXIS);
            _this.uiMatrix.prependRotation(0, tl3d.Vector3D.Y_AXIS);
            _this.uiViewMatrix = new tl3d.Matrix3D;
            return _this;
        }
        Display3DUISprite.prototype.loadRes = function ($name) {
            var _this = this;
            if (!this.modelRes) {
                this.modelRes = new tl3d.ModelRes();
            }
            this.modelRes.load(tl3d.Scene_data.fileRoot + tl3d.UnitFunction.getModelUrl($name), function () { _this.loadResComFinish(); });
        };
        Display3DUISprite.prototype.loadResComFinish = function () {
            this.setObjUrl(this.modelRes.objUrl);
            this.setMaterialUrl(this.modelRes.materialUrl);
        };
        Display3DUISprite.prototype.loadGroup = function ($name) {
            var _this = this;
            var groupRes = new tl3d.GroupRes;
            groupRes.load(tl3d.Scene_data.fileRoot + "model/" + $name + ".txt", function () { _this.loadPartRes(groupRes); });
        };
        Display3DUISprite.prototype.loadPartRes = function (groupRes) {
            for (var i = 0; i < groupRes.dataAry.length; i++) {
                var item = groupRes.dataAry[i];
                if (item.types == tl3d.BaseRes.SCENE_PARTICLE_TYPE) {
                }
                else if (item.types == tl3d.BaseRes.PREFAB_TYPE) {
                    this.setObjUrl(item.objUrl);
                    this.setMaterialUrl(item.materialUrl, item.materialInfoArr);
                }
            }
        };
        Display3DUISprite.prototype.resize = function () {
            this.uiViewMatrix.identity();
            this.uiViewMatrix.perspectiveFieldOfViewLH(1, 1, 500, 5000);
            this.uiViewMatrix.appendScale(1000 / tl3d.Scene_data.stageWidth, 1000 / tl3d.Scene_data.stageHeight, 1);
        };
        Display3DUISprite.prototype.setCam = function () {
            //Scene_data.context3D.setVcMatrix4fv(this.material.shader, "posMatrix3D", this.posMatrix.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.material.shader, "viewMatrix3D", this.uiViewMatrix.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.material.shader, "camMatrix3D", this.uiMatrix.m);
        };
        Display3DUISprite.prototype.update = function () {
            tl3d.Scene_data.context3D.setWriteDepth(true);
            tl3d.Scene_data.context3D.setDepthTest(true);
            _super.prototype.update.call(this);
            tl3d.Scene_data.context3D.setWriteDepth(false);
            tl3d.Scene_data.context3D.setDepthTest(false);
            ////console.log(this.posMatrix.m)
        };
        return Display3DUISprite;
    }(tl3d.Display3DSprite));
    tl3d.Display3DUISprite = Display3DUISprite;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3dMovie = /** @class */ (function (_super) {
        __extends(Display3dMovie, _super);
        function Display3dMovie() {
            var _this = _super.call(this) || this;
            _this._completeState = 0;
            _this._optCbTime = 1; //回调触发次数
            _this._optCbCurTime = 0; //回调当前次数
            _this._defaultAction = "stand";
            _this._curentFrame = 0;
            _this._actionTime = 0;
            _this.isBreak = true; //动作是否可以被打断
            _this._fileScale = 1;
            _this._hasDestory = false;
            /**正在播放的技能*/
            _this._isSinging = false;
            _this.meshVisible = true;
            _this._nextScale = 1;
            _this.locationDic = new Object;
            _this._animDic = new Object;
            _this._partDic = new Object;
            _this._partUrl = new Object;
            _this._preLoadActionDic = new Object;
            _this._waitLoadActionDic = new Object;
            _this.showCapsule = false;
            _this._enablePhysics = false;
            return _this;
        }
        Object.defineProperty(Display3dMovie.prototype, "isSinging", {
            get: function () {
                return this._isSinging;
            },
            set: function (value) {
                this._isSinging = value;
                //console.log(" this._isSinging",this._isSinging)
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Display3dMovie.prototype, "curentAction", {
            get: function () {
                return this._curentAction;
            },
            set: function (value) {
                this._curentAction = value;
            },
            enumerable: true,
            configurable: true
        });
        Display3dMovie.prototype.fixAstartData = function (pos) { };
        Display3dMovie.prototype.setRoleUrl = function (value, $cb) {
            var _this = this;
            if (value === this._curMeshUrl)
                return;
            // console.log("---加载 ----",value);
            this._curMeshUrl = value;
            this._curMeshLoadCom = false;
            this.clearMesh();
            // let time: number = Date.now();
            tl3d.MeshDataManager.getInstance().getMeshData(value, function ($skinMesh) {
                // logyhj("加载耗时：", (Date.now() - time));
                if (_this._hasDestory) {
                    $skinMesh.useNum--;
                    return;
                }
                // console.log("---value , this._curMeshUrl ----",value,this._curMeshUrl);
                if (value !== _this._curMeshUrl) {
                    $skinMesh.useNum--;
                    // console.log("-----------------mesh 已经被替换-------------");
                    return;
                }
                if (_this._curMeshLoadCom) {
                    $skinMesh.useNum--;
                    // console.log("%s 被重复加载",value);
                    return;
                }
                _this._curMeshLoadCom = true;
                _this._skinMesh = $skinMesh;
                _this.fileScale = $skinMesh.fileScale;
                if (_this.onStage) {
                    _this.addSkinMeshParticle();
                }
                _this._animDic = $skinMesh.animDic;
                _this.onMeshLoaded();
                if ($cb) {
                    $cb();
                }
                // logyhj("加载耗时1：", (Date.now() - time));
            });
        };
        Display3dMovie.prototype.onMeshLoaded = function () {
            this.dispatchEvent(new tl3d.BaseEvent(tl3d.BaseEvent.COMPLETE));
        };
        Display3dMovie.prototype.clearMesh = function () {
            this.removeSkinMeshParticle();
            if (this._skinMesh) {
                this._skinMesh.useNum--;
            }
            this._skinMesh = null;
            this._animDic = new Object;
        };
        Display3dMovie.prototype.addSkinMeshParticle = function () {
            if (!this._skinMesh) {
                return;
            }
            var dicAry = new Array;
            this._partDic["mesh"] = dicAry;
            var meshAry = this._skinMesh.meshAry;
            if (!meshAry) {
                return;
            }
            for (var i = 0; i < meshAry.length; i++) {
                var particleAry = meshAry[i].particleAry;
                for (var j = 0; j < particleAry.length; j++) {
                    var bindPartcle = particleAry[j];
                    var particle;
                    particle = tl3d.ParticleManager.getInstance().getParticleByte(tl3d.Scene_data.fileRoot + bindPartcle.url);
                    if (!particle.sourceData) {
                        console.log("particle.sourceData error", particle, bindPartcle);
                    }
                    particle.dynamic = true;
                    particle.bindSocket = bindPartcle.socketName;
                    dicAry.push(particle);
                    particle.bindTarget = this;
                    this._scene.addParticle(particle);
                }
            }
        };
        Display3dMovie.prototype.removeSkinMeshParticle = function () {
            if (!this._partDic)
                this._partDic = new Object;
            var dicAry = this._partDic["mesh"];
            if (!dicAry) {
                return;
            }
            for (var i = 0; i < dicAry.length; i++) {
                this._scene.removeParticle(dicAry[i]);
                dicAry[i].destory();
            }
            this._partDic["mesh"] = null;
        };
        Display3dMovie.prototype.roleResCom = function ($roleRes, $batchNum) {
            //this._roleRes = $roleRes;
            //this._roleRes.useNum++;
            //this._meshUrl = this._roleRes.roleUrl;
            //MeshDataManager.getInstance().getMeshData(this._meshUrl, ($skinMesh: SkinMesh) => {
            //    this._skinMesh = $skinMesh;
            //    if ($batchNum != 1) {
            //        this._skinMesh.type = 1;
            //    }
            //    for (var key in this._animDic) {
            //        this.processAnimByMesh(this._animDic[key]);
            //    }
            //    $skinMesh.loadMaterial(($m: Material) => { this.loadMaterialCom($m) });
            //    $skinMesh.loadParticle(this);
            //    this.fileScale = $skinMesh.fileScale;
            //}, $batchNum);
            //var actionAry: Array<string> = this._roleRes.actionAry;
            //for (var i: number = 0; i<actionAry.length;i++){
            //    this.addAction(actionAry[i], this._roleRes.roleUrl + actionAry[i]);
            //}
        };
        Display3dMovie.prototype.setMeshUrl = function (value, $batchNum) {
            var _this = this;
            if ($batchNum === void 0) { $batchNum = 1; }
            this._meshUrl = tl3d.Scene_data.fileRoot + value;
            tl3d.MeshDataManager.getInstance().getMeshData(this._meshUrl, function ($skinMesh) {
                _this._skinMesh = $skinMesh;
                if ($batchNum != 1) {
                    _this._skinMesh.type = 1;
                }
                for (var key in _this._animDic) {
                    _this.processAnimByMesh(_this._animDic[key]);
                }
                $skinMesh.loadMaterial(function ($m) { _this.loadMaterialCom($m); });
                //$skinMesh.loadParticle(this);
                _this.fileScale = $skinMesh.fileScale;
            }, $batchNum);
        };
        Object.defineProperty(Display3dMovie.prototype, "scale", {
            get: function () {
                return this._nextScale;
            },
            set: function (value) {
                this._nextScale = value;
                this._scaleX = value * this._fileScale;
                this._scaleY = value * this._fileScale;
                this._scaleZ = value * this._fileScale;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Display3dMovie.prototype, "fileScale", {
            set: function (value) {
                this._fileScale = value;
                this._scaleX = this._nextScale * value;
                this._scaleY = this._nextScale * value;
                this._scaleZ = this._nextScale * value;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Display3dMovie.prototype, "shadow", {
            set: function (value) {
                if (value) {
                    if (!this._shadow) {
                        this._shadow = tl3d.ShadowManager.getInstance().addShadow();
                    }
                }
                else {
                    if (this._shadow) {
                        tl3d.ShadowManager.getInstance().removeShadow(this._shadow);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Display3dMovie.prototype.setShadowSize = function (value) {
            if (this._shadow) {
                this._shadow.size = value;
            }
        };
        Display3dMovie.prototype.addStage = function () {
            _super.prototype.addStage.call(this);
            this.addSkinMeshParticle();
            if (this._shadow) {
                this._shadow.visible = true;
            }
        };
        Display3dMovie.prototype.removeStage = function () {
            _super.prototype.removeStage.call(this);
            this._curMeshUrl = null;
            if (this._shadow) {
                tl3d.ShadowManager.getInstance().removeShadow(this._shadow);
            }
            for (var key in this._partDic) {
                var ary = this._partDic[key];
                for (var i = 0; i < ary.length; i++) {
                    if (ary[i] instanceof tl3d.CombineParticle) {
                        this._scene.removeParticle(ary[i]);
                    }
                    else if (ary[i] instanceof tl3d.Display3DSprite) {
                        this._scene.removeSpriteDisplay(ary[i]);
                    }
                }
            }
        };
        Display3dMovie.prototype.loadMaterialCom = function ($material) {
            if ($material.lightProbe) {
                this.lightProbe = true;
            }
        };
        Display3dMovie.prototype.setCollision = function ($radius, $height) {
        };
        Display3dMovie.prototype.applyVisible = function () {
        };
        Display3dMovie.prototype.removePart = function ($key) {
            var ary = this._partDic[$key];
            if (!ary) {
                return;
            }
            for (var i = 0; i < ary.length; i++) {
                if (ary[i] instanceof tl3d.CombineParticle) {
                    this._scene.removeParticle(ary[i]);
                    ary[i].destory();
                }
                else if (ary[i] instanceof tl3d.Display3DSprite) {
                    this._scene.removeSpriteDisplay(ary[i]);
                    ary[i].destory();
                }
            }
            this._partDic[$key] = null;
            this._partUrl[$key] = null;
            delete this._partDic[$key];
            delete this._partUrl[$key];
        };
        /**
            部位，路径，类型 1为粒子 0为其他
        */
        Display3dMovie.prototype.addPart = function ($key, $bindSocket, $url) {
            var _this = this;
            if (this._partUrl[$key] == $url) { //如果相同则返回
                return;
            }
            else if (this._partUrl[$key]) { //如果不同则先移除
                this.removePart($key);
            }
            if (!this._partDic[$key]) {
                this._partDic[$key] = new Array;
            }
            this._partUrl[$key] = $url;
            var ary = this._partDic[$key];
            this._scene.groupDataMgr.getGroupData(tl3d.Scene_data.fileRoot + $url, function (groupRes) {
                _this.loadPartRes($bindSocket, groupRes, ary);
            });
            //var groupRes: GroupRes = new GroupRes;
            //groupRes.load(Scene_data.fileRoot +  $url, () => { this.loadPartRes($bindSocket,groupRes,ary) });
        };
        Display3dMovie.prototype.loadPartRes = function ($bindSocket, groupRes, ary) {
            if (this._hasDestory) {
                return;
            }
            for (var i = 0; i < groupRes.dataAry.length; i++) {
                var item = groupRes.dataAry[i];
                var posV3d;
                var rotationV3d;
                var scaleV3d;
                if (item.isGroup) {
                    posV3d = new tl3d.Vector3D(item.x, item.y, item.z);
                    rotationV3d = new tl3d.Vector3D(item.rotationX, item.rotationY, item.rotationZ);
                    scaleV3d = new tl3d.Vector3D(item.scaleX, item.scaleY, item.scaleZ);
                }
                if (item.types == tl3d.BaseRes.SCENE_PARTICLE_TYPE) {
                    var particle = tl3d.ParticleManager.getInstance().getParticleByte(tl3d.Scene_data.fileRoot + item.particleUrl);
                    ary.push(particle);
                    particle.bindTarget = this;
                    particle.bindSocket = $bindSocket;
                    particle.dynamic = true;
                    this._scene.addParticle(particle);
                    if (item.isGroup) {
                        particle.setGroup(posV3d, rotationV3d, scaleV3d);
                    }
                }
                else if (item.types == tl3d.BaseRes.PREFAB_TYPE) {
                    var display = new tl3d.Display3DSprite();
                    display.setObjUrl(item.objUrl);
                    display.setMaterialUrl(item.materialUrl, item.materialInfoArr);
                    display.dynamic = true;
                    ary.push(display);
                    display.setBind(this, $bindSocket);
                    this._scene.addSpriteDisplay(display);
                    if (item.isGroup) {
                        display.setGroup(posV3d, rotationV3d, scaleV3d);
                    }
                }
            }
            this.applyVisible();
        };
        // public reset(): void
        // {
        //     for (var key in this._partDic) {
        //         var ary: Array<any> = this._partDic[key];
        //         for (var i: number = 0; i < ary.length; i++) {
        //             if (ary[i] instanceof CombineParticle) {
        //                 ParticleManager.getInstance().addParticle(<CombineParticle>ary[i])
        //             } else if (ary[i] instanceof Display3DSprite) {
        //                 SceneManager.getInstance().addDisplay(<Display3DSprite>ary[i])
        //             }
        //         }
        //     }
        // }
        // private loadPartInfoCom($byte: ArrayBuffer, $bindSocket: string, ary: Array<any> ): void {
        //     var byte: ByteArray = new ByteArray($byte);
        //     var length: number = byte.readInt();
        //     for (var i: number = 0; i < length; i++){
        //         var types: number = byte.readInt();
        //         var url: string = byte.readUTF();
        //         var url2: string;
        //         if (types == 1) {
        //             url2 = byte.readUTF();
        //         } 
        //         var isGroup: boolean = byte.readBoolean();
        //         var posV3d: Vector3D;
        //         var rotationV3d: Vector3D;
        //         var scaleV3d: Vector3D;
        //         if (isGroup) {
        //             posV3d = byte.readVector3D()
        //             rotationV3d = byte.readVector3D()
        //             scaleV3d = byte.readVector3D()
        //         }
        //         if (types == 0) {
        //         } else if (types == 1){
        //             var display: Display3DSprite = new Display3DSprite();
        //             display.setObjUrl(url);
        //             display.setMaterialUrl(url2);
        //             ary.push(display);
        //             display.setBind(this, $bindSocket);
        //             SceneManager.getInstance().addDisplay(display);
        //             if (isGroup){
        //                 display.setGroup(posV3d, rotationV3d, scaleV3d);
        //             }
        //         }
        //     }
        // }
        Display3dMovie.prototype.getSocket = function (socketName, resultMatrix) {
            try {
                resultMatrix.identity();
                if (!this._skinMesh) {
                    //resultMatrix.appendTranslation(this._x,this._y,this._z);
                    resultMatrix.append(this.posMatrix);
                    return;
                }
                else if (!this._skinMesh.boneSocketDic[socketName]) {
                    if (socketName = "none") {
                        resultMatrix.appendTranslation(this._x, this._y, this._z);
                    }
                    else {
                        resultMatrix.append(this.posMatrix);
                    }
                    return;
                }
                var boneSocketData = this._skinMesh.boneSocketDic[socketName];
                //if (!boneSocketData) {
                //    resultMatrix.append(this.posMatrix);
                //    return;
                //}
                var testmatix;
                var index = boneSocketData.index;
                testmatix = this.getFrameMatrix(index);
                resultMatrix.appendScale(1 / this._scaleX, 1 / this._scaleY, 1 / this._scaleZ);
                resultMatrix.appendRotation(boneSocketData.rotationX, tl3d.Vector3D.X_AXIS);
                resultMatrix.appendRotation(boneSocketData.rotationY, tl3d.Vector3D.Y_AXIS);
                resultMatrix.appendRotation(boneSocketData.rotationZ, tl3d.Vector3D.Z_AXIS);
                resultMatrix.appendTranslation(boneSocketData.x, boneSocketData.y, boneSocketData.z);
                if (testmatix) {
                    resultMatrix.append(this._skinMesh.meshAry[this._skinMesh.meshAry.length - 1].bindPosInvertMatrixAry[index]);
                    resultMatrix.append(testmatix);
                }
                resultMatrix.append(this.posMatrix);
            }
            catch (error) {
                console.error("出错啦", error);
            }
        };
        Display3dMovie.prototype.getSunType = function () {
            return 0;
        };
        Display3dMovie.prototype.getFrameMatrix = function (index) {
            if (this._animDic[this.curentAction]) {
                var animData = this._animDic[this.curentAction];
                if (this._curentFrame >= animData.matrixAry.length) {
                    return animData.matrixAry[0][index];
                }
                return animData.matrixAry[this._curentFrame][index];
            }
            else if (this._animDic[this._defaultAction]) {
                var animData = this._animDic[this._defaultAction];
                return animData.matrixAry[this._curentFrame][index];
            }
            return null;
        };
        Display3dMovie.prototype.addAction = function (name, url, needPerLoad) {
            if (needPerLoad === void 0) { needPerLoad = false; }
            this._preLoadActionDic[name] = url;
            if (name == this._defaultAction || name == this.curentAction) {
                this.setAnimUrl(name, url);
            }
            else if (needPerLoad) {
                this.setAnimUrl(name, url);
            }
        };
        Display3dMovie.prototype.setAnimUrl = function (name, url) {
            var _this = this;
            this._waitLoadActionDic[name] = true;
            tl3d.AnimManager.getInstance().getAnimData(url, function ($animData) {
                _this._animDic[name] = $animData;
                _this.processAnimByMesh($animData);
                _this._waitLoadActionDic[name] = false;
            });
        };
        Display3dMovie.prototype.randomPlayAction = function () {
            var keys = Object.keys(this._animDic);
            var idx = tl3d.Util.random(keys.length);
            var action = keys[idx];
            this.play(action, 2);
        };
        Display3dMovie.prototype.play = function ($action, $completeState, needFollow, comboBackAction, cb) {
            if ($completeState === void 0) { $completeState = 0; }
            if (needFollow === void 0) { needFollow = true; }
            //FpsMc.tipStr = "1" + $action + "," + this._curentAction;
            if (!this.isBreak)
                return;
            if (this.curentAction == $action) {
                return;
            }
            this._completecb = cb;
            this._optCbCurTime = 0;
            //FpsMc.tipStr = "2";
            this.curentAction = $action;
            this._comboBackAction = comboBackAction || this._defaultAction;
            this._completeState = $completeState;
            this._actionTime = 0;
            this.updateFrame(0);
            //FpsMc.tipStr = "3";
            if (this._animDic.hasOwnProperty($action)) {
                //FpsMc.tipStr = "4";
                return true;
            }
            else {
                //FpsMc.tipStr = "5";
                if (!this._waitLoadActionDic[$action] && this._preLoadActionDic[$action]) {
                    //FpsMc.tipStr = "6";
                    this.setAnimUrl($action, this._preLoadActionDic[$action]);
                }
                return false;
            }
        };
        Display3dMovie.prototype.processAnimByMesh = function ($animData) {
            if (!this._skinMesh) {
                return;
            }
            if ($animData.hasProcess) {
                return;
            }
            for (var i = 0; i < $animData.matrixAry.length; i++) {
                var frameAry = $animData.matrixAry[i];
                for (var j = 0; j < frameAry.length; j++) {
                    frameAry[j].prepend(this._skinMesh.meshAry[0].bindPosMatrixAry[j]);
                }
            }
            $animData.hasProcess = true;
        };
        Display3dMovie.prototype.update = function () {
            if (!this._skinMesh) {
                return;
            }
            if (this.lightProbe) {
                this.resultSHVec = tl3d.LightProbeManager.getInstance().getData(new tl3d.Vector3D(this.x, this.y + 10, this.z));
            }
            // if(this.name == "老鹰"){
            //  //console.log(this.name);  
            // }
            this.updateBind();
            if (this.meshVisible) {
                for (var i = 0; this._skinMesh && this._skinMesh.meshAry && i < this._skinMesh.meshAry.length; i++) {
                    this.updateMaterialMesh(this._skinMesh.meshAry[i]);
                }
            }
            if (this.showCapsule) {
                this.updateShowCapsule();
            }
        };
        Display3dMovie.prototype.updateFrame = function (t) {
            this._actionTime += t;
            var actionKey;
            if (this.curentAction && this._animDic[this.curentAction]) {
                actionKey = this.curentAction;
            }
            else if (this._animDic[this._defaultAction]) {
                actionKey = this._defaultAction;
            }
            else {
                return;
            }
            var animData = this._animDic[actionKey];
            this._curentFrame = tl3d.Util.float2int(this._actionTime / (tl3d.Scene_data.frameTime * 2));
            if (this._curentFrame >= animData.matrixAry.length) {
                //动作播放结束
                if (this._completecb && this._optCbCurTime < this._optCbTime) {
                    this._optCbCurTime++;
                    this._completecb();
                }
                if (this._completeState == 0) {
                    this._actionTime = 0;
                    this._curentFrame = 0;
                }
                else if (this._completeState == 1) {
                    this._curentFrame = animData.matrixAry.length - 1;
                }
                else if (this._completeState == 2) {
                    this._curentFrame = 0;
                    this._completeState = 0;
                    this.changeAction(this._defaultAction);
                }
                else if (this._completeState == 3) {
                    //播放指定动作1次,然后回到待机动作
                    this._curentFrame = 0;
                    this._completeState = 0;
                    this.changeAction(this._comboBackAction);
                    this._completeState = 2;
                }
            }
        };
        Display3dMovie.prototype.changeAction = function ($action) {
            this.curentAction = $action;
        };
        Display3dMovie.prototype.destory = function () {
            _super.prototype.destory.call(this);
            if (this._skinMesh) {
                this._skinMesh.useNum--;
            }
            for (var key in this._partDic) {
                var ary = this._partDic[key];
                for (var i = 0; ary && i < ary.length; i++) {
                    if (ary[i] instanceof tl3d.CombineParticle) {
                        ary[i].destory();
                    }
                    else if (ary[i] instanceof tl3d.Display3DSprite) {
                        ary[i].destory();
                    }
                }
            }
            this._partDic = null;
            this._hasDestory = true;
        };
        Display3dMovie.prototype.updateShowCapsule = function () {
            if (this.capsuleLineSprite) {
                this.capsuleLineSprite.x = this.x;
                this.capsuleLineSprite.y = this.y + this._capsule.radius;
                this.capsuleLineSprite.z = this.z;
                this.capsuleLineSprite.update();
            }
            else {
                this.capsuleLineSprite = new tl3d.LineDisplaySprite();
                this.capsuleLineSprite.clear();
                this.capsuleLineSprite.baseColor = new tl3d.Vector3D(1, 0, 0, 1);
                this.drawCylinder(this._capsule.radius, this._capsule.height);
                this.drawBall(this._capsule.radius);
                this.capsuleLineSprite.upToGpu();
            }
        };
        Display3dMovie.prototype.drawBall = function ($r) {
            var radiusNum100 = $r;
            var num = 12;
            var p;
            var m;
            var lastPos;
            var i;
            var j;
            var bm;
            var bp;
            for (j = 0; j <= num; j++) {
                lastPos = null;
                for (i = num / 2; i < num; i++) {
                    p = new tl3d.Vector3D(radiusNum100, 0, 0);
                    m = new tl3d.Matrix3D;
                    m.appendRotation((360 / num) * i, tl3d.Vector3D.Z_AXIS);
                    p = m.transformVector(p);
                    bm = new tl3d.Matrix3D;
                    bm.appendRotation((360 / num) * j, tl3d.Vector3D.Y_AXIS);
                    p = bm.transformVector(p);
                    if (lastPos) {
                        this.capsuleLineSprite.makeLineMode(lastPos, p);
                    }
                    lastPos = p.clone();
                }
            }
            for (j = 1; j <= 4; j++) {
                bm = new tl3d.Matrix3D;
                bm.appendRotation(j * -20, tl3d.Vector3D.Z_AXIS);
                bp = bm.transformVector(new tl3d.Vector3D(radiusNum100, 0, 0));
                lastPos = null;
                for (i = 0; i < num; i++) {
                    p = bp.clone();
                    m = new tl3d.Matrix3D;
                    m.appendRotation((360 / num) * i, tl3d.Vector3D.Y_AXIS);
                    p = m.transformVector(p);
                    if (lastPos) {
                        this.capsuleLineSprite.makeLineMode(lastPos, p);
                    }
                    if (i == num - 1) {
                        this.capsuleLineSprite.makeLineMode(bp, p);
                    }
                    lastPos = p.clone();
                }
            }
        };
        Display3dMovie.prototype.drawCylinder = function ($w, $h) {
            var w = $w;
            var h = $h;
            var jindu = 12;
            var lastA;
            var lastB;
            var i;
            for (i = 0; i < jindu; i++) {
                var a = new tl3d.Vector3D(w, 0, 0);
                var b = new tl3d.Vector3D(w, +h, 0);
                var m = new tl3d.Matrix3D;
                m.appendRotation(i * (360 / jindu), tl3d.Vector3D.Y_AXIS);
                var A = m.transformVector(a);
                var B = m.transformVector(b);
                this.capsuleLineSprite.makeLineMode(A, B);
                //this.capsuleLineSprite.makeLineMode(A, new Vector3D(0, 0, 0))
                this.capsuleLineSprite.makeLineMode(B, new tl3d.Vector3D(0, +h, 0));
                if (i == (jindu - 1)) {
                    this.capsuleLineSprite.makeLineMode(A, a);
                    this.capsuleLineSprite.makeLineMode(B, b);
                }
                if (lastA || lastB) {
                    this.capsuleLineSprite.makeLineMode(A, lastA);
                    this.capsuleLineSprite.makeLineMode(B, lastB);
                }
                lastA = A.clone();
                lastB = B.clone();
            }
        };
        Display3dMovie.prototype.setVcMatrix = function ($mesh) {
            //Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "viewMatrix3D", Scene_data.viewMatrx3D.m);
            //Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            tl3d.Scene_data.context3D.setVpMatrix($mesh.material.shader, tl3d.Scene_data.vpMatrix.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "posMatrix3D", this.posMatrix.m);
            //Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "rotationMatrix3D", this._rotationMatrix.m);
        };
        Display3dMovie.prototype.setVa = function ($mesh) {
            if ($mesh.compressBuffer) {
                this.setVaCompress($mesh);
            }
            else {
                this.setVaIndependent($mesh);
            }
        };
        Display3dMovie.prototype.setVaIndependent = function ($mesh) {
            tl3d.Scene_data.context3D.setVa(0, 3, $mesh.vertexBuffer);
            tl3d.Scene_data.context3D.setVa(1, 2, $mesh.uvBuffer);
            tl3d.Scene_data.context3D.setVa(2, 4, $mesh.boneIdBuffer);
            tl3d.Scene_data.context3D.setVa(3, 4, $mesh.boneWeightBuffer);
            if ($mesh.material.usePbr) {
                tl3d.Scene_data.context3D.setVa(4, 4, $mesh.normalsBuffer);
                tl3d.Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "rotationMatrix3D", this._rotationMatrix.m);
                if ($mesh.material.useNormal) {
                    tl3d.Scene_data.context3D.setVa(5, 4, $mesh.tangentBuffer);
                    tl3d.Scene_data.context3D.setVa(6, 4, $mesh.bitangentBuffer);
                }
            }
            else {
                if ($mesh.material.lightProbe || $mesh.material.directLight) {
                    tl3d.Scene_data.context3D.setVa(4, 4, $mesh.normalsBuffer);
                    tl3d.Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "rotationMatrix3D", this._rotationMatrix.m);
                }
            }
        };
        Display3dMovie.prototype.setVaCompress = function ($mesh) {
            var tf = tl3d.Scene_data.context3D.pushVa($mesh.vertexBuffer);
            if (tf) {
                ////console.log('cccccc')
                return;
            }
            tl3d.Scene_data.context3D.setVaOffset(0, 3, $mesh.stride, 0);
            tl3d.Scene_data.context3D.setVaOffset(1, 2, $mesh.stride, $mesh.uvsOffsets);
            tl3d.Scene_data.context3D.setVaOffset(2, 4, $mesh.stride, $mesh.boneIDOffsets);
            tl3d.Scene_data.context3D.setVaOffset(3, 4, $mesh.stride, $mesh.boneWeightOffsets);
            if ($mesh.material.usePbr) {
                tl3d.Scene_data.context3D.setVaOffset(4, 3, $mesh.stride, $mesh.normalsOffsets);
                tl3d.Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "rotationMatrix3D", this._rotationMatrix.m);
                if ($mesh.material.useNormal) {
                    tl3d.Scene_data.context3D.setVaOffset(5, 3, $mesh.stride, $mesh.tangentsOffsets);
                    tl3d.Scene_data.context3D.setVaOffset(6, 3, $mesh.stride, $mesh.bitangentsOffsets);
                }
            }
            else {
                if ($mesh.material.lightProbe || $mesh.material.directLight) {
                    tl3d.Scene_data.context3D.setVaOffset(4, 3, $mesh.stride, $mesh.normalsOffsets);
                    tl3d.Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "rotationMatrix3D", this._rotationMatrix.m);
                }
            }
        };
        Display3dMovie.prototype.clearVa = function () {
            tl3d.Scene_data.context3D.clearVa(2);
            tl3d.Scene_data.context3D.clearVa(3);
            tl3d.Scene_data.context3D.clearVa(4);
            tl3d.Scene_data.context3D.clearVa(5);
            tl3d.Scene_data.context3D.clearVa(6);
        };
        Display3dMovie.prototype.updateMaterialMesh = function ($mesh) {
            if (!$mesh.material) {
                return;
            }
            tl3d.Scene_data.context3D.setProgram($mesh.material.program);
            // Scene_data.context3D.cullFaceBack($mesh.material.backCull);
            tl3d.Scene_data.context3D.cullFaceBack(false);
            tl3d.Scene_data.context3D.setBlendParticleFactors($mesh.material.blendMode);
            // Scene_data.context3D.setBlendParticleFactors(-1);
            this.setVcMatrix($mesh);
            //this.setBaseMaterialVc($mesh.material);
            this.setMaterialVc($mesh.material, $mesh.materialParam);
            ////console.log($mesh.material.fcData);
            this.setMaterialTexture($mesh.material, $mesh.materialParam);
            this.setVa($mesh);
            //this.setLightProbeVc($mesh.material);
            this.setDirectLight($mesh.material);
            this.setMeshVc($mesh);
            tl3d.Scene_data.context3D.drawCall($mesh.indexBuffer, $mesh.treNum);
        };
        Display3dMovie.prototype.setLightProbeVc = function ($material) {
            if ($material.lightProbe) {
                for (var i = 0; i < this.resultSHVec.length; i++) {
                    tl3d.Scene_data.context3D.setVc3fv($material.shader, "sh[" + i + "]", [this.resultSHVec[i].x, this.resultSHVec[i].y, this.resultSHVec[i].z]);
                }
            }
        };
        Display3dMovie.prototype.setMeshVc = function ($mesh) {
            var animData;
            if (this._animDic[this.curentAction]) {
                animData = this._animDic[this.curentAction];
            }
            else if (this._animDic[this._defaultAction]) {
                animData = this._animDic[this._defaultAction];
            }
            else {
                return;
            }
            var $dualQuatFrame = animData.getBoneQPAryByMesh($mesh)[$mesh.uid][this._curentFrame];
            if (!$dualQuatFrame) {
                return;
            }
            tl3d.Scene_data.context3D.setVc4fv($mesh.material.shader, "boneQ", $dualQuatFrame.quat); //旋转
            tl3d.Scene_data.context3D.setVc3fv($mesh.material.shader, "boneD", $dualQuatFrame.pos); //所有的位移
        };
        Display3dMovie.prototype.setPos = function ($v3d) {
            ////console.log($v3d);
            _super.prototype.setPos.call(this, $v3d);
            if (this._shadow) {
                this._shadow.x = $v3d.x;
                this._shadow.y = $v3d.y + 8;
                this._shadow.z = $v3d.z;
            }
        };
        Object.defineProperty(Display3dMovie.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
                this.updateMatrix();
                if (this._shadow) {
                    this._shadow.x = value;
                }
                this.changePos();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Display3dMovie.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
                this.updateMatrix();
                if (this._shadow) {
                    this._shadow.y = value;
                }
                this.changePos();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Display3dMovie.prototype, "z", {
            get: function () {
                return this._z;
            },
            set: function (value) {
                this._z = value;
                this.updateMatrix();
                if (this._shadow) {
                    this._shadow.z = value;
                }
                this.changePos();
            },
            enumerable: true,
            configurable: true
        });
        Display3dMovie.prototype.changePos = function () {
        };
        return Display3dMovie;
    }(tl3d.Display3DSprite));
    tl3d.Display3dMovie = Display3dMovie;
})(tl3d || (tl3d = {}));
/// <reference path="Display3dMovie.ts" />

(function (tl3d) {
    var Display3dBatchMovie = /** @class */ (function (_super) {
        __extends(Display3dBatchMovie, _super);
        function Display3dBatchMovie() {
            var _this = _super.call(this) || this;
            _this.batchNum = 0;
            _this.batchPos = new Array;
            return _this;
        }
        Object.defineProperty(Display3dBatchMovie.prototype, "fileScale", {
            set: function (value) {
                this._fileScale = value;
                for (var i = 0; i < this.batchPos.length; i++) {
                    this.batchPos[i].fileScale = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Display3dBatchMovie.prototype.addSun = function ($obj) {
            this.batchPos.push($obj);
            $obj.fileScale = this._fileScale;
        };
        Display3dBatchMovie.prototype.setVcMatrix = function ($mesh) {
            tl3d.Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "viewMatrix3D", tl3d.Scene_data.viewMatrx3D.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "camMatrix3D", tl3d.Scene_data.cam3D.cameraMatrix.m);
            tl3d.Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "rotationMatrix3D", this._rotationMatrix.m);
            for (var i = 0; i < this.batchPos.length; i++) {
                tl3d.Scene_data.context3D.setVcMatrix4fv($mesh.material.shader, "posMatrixAry[" + i + "]", this.batchPos[i].posMatrix.m);
            }
        };
        Display3dBatchMovie.prototype.setLightProbeVc = function ($material) {
        };
        Display3dBatchMovie.prototype.setVa = function ($mesh) {
            tl3d.Scene_data.context3D.setVa(0, 3, $mesh.vertexBuffer);
            tl3d.Scene_data.context3D.setVa(1, 3, $mesh.uvBuffer);
            tl3d.Scene_data.context3D.setVa(2, 4, $mesh.boneIdBuffer);
            tl3d.Scene_data.context3D.setVa(3, 4, $mesh.boneWeightBuffer);
            if ($mesh.material.usePbr) {
                tl3d.Scene_data.context3D.setVa(4, 4, $mesh.normalsBuffer);
                if ($mesh.material.useNormal) {
                    tl3d.Scene_data.context3D.setVa(5, 4, $mesh.tangentBuffer);
                    tl3d.Scene_data.context3D.setVa(6, 4, $mesh.bitangentBuffer);
                }
            }
            else {
                if ($mesh.material.lightProbe || $mesh.material.directLight) {
                    tl3d.Scene_data.context3D.setVa(4, 4, $mesh.normalsBuffer);
                }
            }
        };
        Display3dBatchMovie.prototype.addStage = function () {
            _super.prototype.addStage.call(this);
            if (this.batchPos.length) {
                for (var i = 0; i < this.batchPos.length; i++) {
                    this.batchPos[i].add();
                }
            }
        };
        Display3dBatchMovie.prototype.removeStage = function () {
            _super.prototype.removeStage.call(this);
            if (this.batchPos.length) {
                for (var i = 0; i < this.batchPos.length; i++) {
                    this.batchPos[i].remove();
                }
            }
        };
        return Display3dBatchMovie;
    }(tl3d.Display3dMovie));
    tl3d.Display3dBatchMovie = Display3dBatchMovie;
    var Movie3D = /** @class */ (function (_super) {
        __extends(Movie3D, _super);
        function Movie3D() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.posData = [0, 0, 0, 10];
            _this.hasReach = false;
            _this._fileScale = 1;
            return _this;
        }
        Object.defineProperty(Movie3D.prototype, "shadow", {
            set: function (value) {
                if (value) {
                    if (!this._shadow) {
                        this._shadow = tl3d.ShadowManager.getInstance().addShadow();
                        this._shadow.x = this._x;
                        this._shadow.y = this._y;
                        this._shadow.z = this._z;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Movie3D.prototype, "fileScale", {
            set: function (value) {
                this._fileScale = value;
                this._scaleX *= value;
                this._scaleY *= value;
                this._scaleZ *= value;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Movie3D.prototype, "scale", {
            set: function (value) {
                this._scaleX = value * this._fileScale;
                this._scaleY = value * this._fileScale;
                this._scaleZ = value * this._fileScale;
                this.posData[3] = 20 * value;
                this.updateMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Movie3D.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
                this.posData[0] = value;
                this.updateMatrix();
                if (this._shadow) {
                    if (this.retinueShadowFix) {
                        this._shadow.x = value + this.retinueShadowFix.x;
                    }
                    else {
                        this._shadow.x = value;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Movie3D.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
                this.posData[1] = value;
                this.updateMatrix();
                if (this._shadow) {
                    if (this.retinueShadowFix) {
                        this._shadow.y = value + this.retinueShadowFix.y + 2;
                    }
                    else {
                        this._shadow.y = value + 2;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Movie3D.prototype, "z", {
            get: function () {
                return this._z;
            },
            set: function (value) {
                this._z = value;
                this.posData[2] = value;
                this.updateMatrix();
                if (this._shadow) {
                    if (this.retinueShadowFix) {
                        this._shadow.z = value + this.retinueShadowFix.z;
                    }
                    else {
                        this._shadow.z = value;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Movie3D.prototype.add = function () {
            if (this._shadow) {
                this._shadow.visible = true;
            }
        };
        Movie3D.prototype.remove = function () {
            if (this._shadow) {
                this._shadow.visible = false;
            }
        };
        return Movie3D;
    }(tl3d.Object3D));
    tl3d.Movie3D = Movie3D;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3dBg = /** @class */ (function (_super) {
        __extends(Display3dBg, _super);
        function Display3dBg() {
            var _this = _super.call(this) || this;
            _this._scaleData = [1, 1];
            _this.shader = tl3d.ProgrmaManager.getInstance().getProgram(tl3d.UIImageShader.UI_IMG_SHADER);
            _this.program = _this.shader;
            _this.initData();
            return _this;
        }
        Display3dBg.prototype.initData = function () {
            this.objData = new tl3d.ObjData();
            this.objData.vertices.push(-1, 1, 0.99, 1, 1, 0.99, 1, -1, 0.99, -1, -1, 0.99);
            this.objData.uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
            this.objData.indexs.push(0, 1, 2, 0, 2, 3);
            this.objData.treNum = 6;
            this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
            this.objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.uvs);
            this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
        };
        Display3dBg.prototype.resize = function () {
            this.appleyPos();
        };
        Display3dBg.prototype.setImgInfo = function ($url, $width, $height) {
            this.setImgUrl($url);
            this._width = $width;
            this._height = $height;
        };
        Display3dBg.prototype.setImgUrl = function ($url) {
            //TextureManager.getInstance().getTexture(Scene_data.fileRoot + $url, ($texture: WebGLTexture) => {
            //    this.texture = $texture;
            //});
        };
        Display3dBg.prototype.appleyPos = function () {
            var widthScale = this._width / tl3d.Scene_data.stageWidth;
            var heightScale = this._height / tl3d.Scene_data.stageHeight;
            if (widthScale < heightScale) {
                this._scaleData[0] = 1;
                this._scaleData[1] = (this._height / tl3d.Scene_data.stageHeight) / widthScale;
            }
            else {
                this._scaleData[0] = (this._width / tl3d.Scene_data.stageWidth) / heightScale;
                this._scaleData[1] = 1;
            }
        };
        Display3dBg.prototype.update = function () {
            this.appleyPos();
            tl3d.Scene_data.context3D.setBlendParticleFactors(0);
            tl3d.Scene_data.context3D.setProgram(this.program);
            tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
            tl3d.Scene_data.context3D.setVa(1, 2, this.objData.uvBuffer);
            tl3d.Scene_data.context3D.setVc2fv(this.shader, "scale", this._scaleData);
            tl3d.Scene_data.context3D.setVcFloat(this.shader, "alpha", [1.0]);
            tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this.texture, 0);
            tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
        };
        return Display3dBg;
    }(tl3d.Display3D));
    tl3d.Display3dBg = Display3dBg;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3dShadow = /** @class */ (function (_super) {
        __extends(Display3dShadow, _super);
        function Display3dShadow() {
            var _this = _super.call(this) || this;
            _this.needUpdate = false;
            _this.locationFloat32 = new Float32Array(0);
            _this.shadowList = new Array;
            _this.objData = new tl3d.ObjData;
            _this.shader = tl3d.ProgrmaManager.getInstance().getProgram(tl3d.Display3DShadowShader.Display3DShadowShader);
            _this.program = _this.shader.program;
            _this.posProLocation = tl3d.Scene_data.context3D.getLocation(_this.program, "pos");
            return _this;
        }
        Display3dShadow.prototype.addShadow = function ($shdow) {
            this.shadowList.push($shdow);
            $shdow.display = this;
            this.applyObjData();
        };
        Display3dShadow.prototype.removeShadow = function ($shdow) {
            var index = this.shadowList.indexOf($shdow);
            if (index != -1) {
                this.shadowList.splice(index, 1);
                this.applyObjData();
            }
            if (this.shadowList.length == 0) {
            }
        };
        Display3dShadow.prototype.stateChage = function () {
            for (var i = 0; i < this.shadowList.length; i++) {
                if (this.shadowList[i].visible) {
                    break;
                }
            }
            if (i == this.shadowList.length) {
                this.needUpdate = false;
            }
            else {
                this.needUpdate = true;
            }
        };
        Display3dShadow.prototype.hasIdle = function () {
            return this.shadowList.length < 30;
        };
        Display3dShadow.prototype.applyObjData = function () {
            this.objData.vertices.length = 0;
            this.objData.uvs.length = 0;
            this.objData.indexs.length = 0;
            var wh = 5;
            for (var i = 0; i < this.shadowList.length; i++) {
                this.objData.vertices.push(-wh, 0, wh, wh, 0, wh, wh, 0, -wh, -wh, 0, -wh);
                this.objData.uvs.push(0, 0, i, 0, 1, i, 1, 1, i, 1, 0, i);
                this.objData.indexs.push(i * 4, 1 + i * 4, 2 + i * 4, i * 4, 2 + i * 4, 3 + i * 4);
            }
            this.objData.treNum = this.shadowList.length * 6;
            if (this.objData.vertexBuffer) {
                tl3d.Scene_data.context3D.uploadBuff3DByBuffer(this.objData.vertexBuffer, this.objData.vertices);
                tl3d.Scene_data.context3D.uploadBuff3DByBuffer(this.objData.uvBuffer, this.objData.uvs);
                tl3d.Scene_data.context3D.uploadIndexBuff3DByBuffer(this.objData.indexBuffer, this.objData.indexs);
            }
            else {
                this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
                this.objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.uvs);
                this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            }
        };
        Display3dShadow.prototype.update = function () {
            this.needUpdate = true;
            if (!this.needUpdate || this.shadowList.length == 0) {
                return;
            }
            if (this.objData.treNum) {
                tl3d.Scene_data.context3D.setBlendParticleFactors(0);
                tl3d.Scene_data.context3D.setProgram(this.program);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "viewMatrix3D", tl3d.Scene_data.viewMatrx3D.m);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "camMatrix3D", tl3d.Scene_data.cam3D.cameraMatrix.m);
                if (this.locationFloat32.length != this.shadowList.length * 4) {
                    this.locationFloat32 = new Float32Array(this.shadowList.length * 4);
                }
                for (var i = 0; i < this.shadowList.length; i++) {
                    //Scene_data.context3D.setVc4fv(this.program, "pos[" + i + "]", this.shadowList[i].data);
                    if (!this.shadowList[i].visible) {
                        //Scene_data.context3D.setVc4fvLocation(this.locationAry[i], [0, 10000, 0, 0]);
                        this.locationFloat32[i * 4 + 0] = 0;
                        this.locationFloat32[i * 4 + 1] = 10000;
                        this.locationFloat32[i * 4 + 2] = 0;
                        this.locationFloat32[i * 4 + 3] = 0;
                    }
                    else {
                        this.locationFloat32[i * 4 + 0] = this.shadowList[i].data[0];
                        this.locationFloat32[i * 4 + 1] = this.shadowList[i].data[1];
                        this.locationFloat32[i * 4 + 2] = this.shadowList[i].data[2];
                        this.locationFloat32[i * 4 + 3] = this.shadowList[i].data[3];
                    }
                }
                tl3d.Scene_data.context3D.setVc4fvLocation(this.posProLocation, this.locationFloat32);
                tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
                tl3d.Scene_data.context3D.setVa(1, 3, this.objData.uvBuffer);
                tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", Display3dShadow.texture, 0);
                tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
            }
        };
        return Display3dShadow;
    }(tl3d.Display3D));
    tl3d.Display3dShadow = Display3dShadow;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var GroundDataMesh = /** @class */ (function () {
        function GroundDataMesh() {
        }
        //处理成可以使用的2幂材质数据源
        GroundDataMesh.prototype.mekeUseTexture = function ($img) {
            var $textureRect = new tl3d.Rectangle(0, 0, Math.pow(2, Math.ceil(Math.log($img.width) / Math.log(2))), Math.pow(2, Math.ceil(Math.log($img.height) / Math.log(2))));
            if ($textureRect.width != $img.width || $textureRect.height != $img.height) {
                var $temp = new tl3d.BitMapData($textureRect.width, $textureRect.height);
                for (var i = 0; i < $temp.width; i++) {
                    for (var j = 0; j < $temp.height; j++) {
                        var $v = $img.getRgb(i / $temp.width * $img.width, j / $temp.height * $img.height);
                        $temp.setRgb(i, j, $v);
                    }
                }
                //    //console.log("地形信息图调整:注需要编辑器地面设置为2幂")
                return $temp;
            }
            else {
                return $img;
            }
        };
        GroundDataMesh.prototype.calibration = function () {
            this.idBitmap = this.mekeUseTexture(this.idBitmap);
            this.infoBitmap = this.mekeUseTexture(this.infoBitmap);
        };
        GroundDataMesh.meshAllgroundData = function ($byte) {
            var cellNumX = $byte.readInt();
            var cellNumZ = $byte.readInt();
            var $groudItem = new Array();
            for (var i = 0; i < cellNumX; i++) {
                for (var j = 0; j < cellNumZ; j++) {
                    var tx = $byte.readInt();
                    var ty = $byte.readInt();
                    var $tw = $byte.readInt();
                    var $th = $byte.readInt();
                    var $groundDataMesh = new GroundDataMesh();
                    $groundDataMesh.idBitmap = new tl3d.BitMapData($tw, $th);
                    $groundDataMesh.infoBitmap = new tl3d.BitMapData($tw, $th);
                    $groundDataMesh.tx = tx;
                    $groundDataMesh.ty = ty;
                    $groudItem.push($groundDataMesh);
                    for (var k = 0; k < $tw; k++) {
                        for (var h = 0; h < $th; h++) {
                            var $vid;
                            var $indexKey = $byte.readByte();
                            switch ($indexKey) {
                                case 0:
                                    $vid = new tl3d.Vector3D(0, 1, 2);
                                    break;
                                case 1:
                                    $vid = new tl3d.Vector3D(0, 1, 3);
                                    break;
                                case 2:
                                    $vid = new tl3d.Vector3D(0, 2, 3);
                                    break;
                                case 3:
                                    $vid = new tl3d.Vector3D(1, 2, 3);
                                    break;
                                default:
                                    throw new Error("信息索引没有编入");
                                //break;
                            }
                            $groundDataMesh.idBitmap.setRgb(k, h, new tl3d.Vector3D($vid.x / 255, $vid.y / 255, $vid.z / 255, 1));
                            var $vinfo = new tl3d.Vector3D();
                            $vinfo.x = $byte.readByte() + 128;
                            $vinfo.y = $byte.readByte() + 128;
                            $vinfo.z = 255 - $vinfo.x - $vinfo.y;
                            $groundDataMesh.infoBitmap.setRgb(k, h, new tl3d.Vector3D($vinfo.x / 255, $vinfo.y / 255, $vinfo.z / 255, 1));
                        }
                    }
                    $groundDataMesh.calibration();
                }
            }
            var $sixUrl = $byte.readUTF();
            for (var $tempidx = 0; $tempidx < $groudItem.length; $tempidx++) {
                $groudItem[$tempidx].sixurl = $sixUrl;
            }
            return $groudItem;
        };
        return GroundDataMesh;
    }());
    tl3d.GroundDataMesh = GroundDataMesh;
    var TerrainDisplay3DSprite = /** @class */ (function (_super) {
        __extends(TerrainDisplay3DSprite, _super);
        function TerrainDisplay3DSprite() {
            var _this = _super.call(this) || this;
            tl3d.ProgrmaManager.getInstance().registe(tl3d.TerrainDisplay3DShader.TerrainDisplay3DShader, new tl3d.TerrainDisplay3DShader());
            _this.groundShader = tl3d.ProgrmaManager.getInstance().getProgram(tl3d.TerrainDisplay3DShader.TerrainDisplay3DShader);
            return _this;
        }
        TerrainDisplay3DSprite.prototype.update = function () {
            if (this.groundShader && this.baseSixteenRes && this.idMapPicDataTexture) {
                this.upDataToDraw();
            }
            else {
                _super.prototype.update.call(this);
            }
        };
        TerrainDisplay3DSprite.prototype.upDataToDraw = function () {
            if (this.groundShader && this.baseSixteenRes) {
                tl3d.Scene_data.context3D.cullFaceBack(false);
                tl3d.Scene_data.context3D.setProgram(this.groundShader.program);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.groundShader, "viewMatrix3D", tl3d.Scene_data.viewMatrx3D.m);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.groundShader, "camMatrix3D", tl3d.Scene_data.cam3D.cameraMatrix.m);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.groundShader, "posMatrix3D", this.posMatrix.m);
                tl3d.Scene_data.context3D.setVc4fv(this.groundShader, "colorData", [1, 0, 1, 1]);
                var tf = tl3d.Scene_data.context3D.pushVa(this.objData.vertexBuffer);
                if (!tf) {
                    tl3d.Scene_data.context3D.setVaOffset(0, 3, this.objData.stride, 0);
                    tl3d.Scene_data.context3D.setVaOffset(1, 2, this.objData.stride, this.objData.uvsOffsets);
                }
                tl3d.Scene_data.context3D.setRenderTexture(this.groundShader, "idmaptexture", this.idMapPicDataTexture, 0);
                tl3d.Scene_data.context3D.setRenderTexture(this.groundShader, "infotexture", this.infoMapPicDataTexture, 1);
                tl3d.Scene_data.context3D.setRenderTexture(this.groundShader, "sixtexture", this.baseSixteenRes.texture, 2);
                tl3d.Scene_data.context3D.setRenderTexture(this.groundShader, "lightexture", this.lightMapTexture, 3);
                tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
            }
        };
        TerrainDisplay3DSprite.prototype.setGrounDataMesh = function ($groundDataMesh) {
            var _this = this;
            this.idMapPicDataTexture = tl3d.Scene_data.context3D.getTexture($groundDataMesh.idBitmap.imgData, 0, 1);
            this.infoMapPicDataTexture = tl3d.Scene_data.context3D.getTexture($groundDataMesh.infoBitmap.imgData, 0, 1);
            var $textureUrl = $groundDataMesh.sixurl;
            tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + $textureUrl, function ($texture) {
                _this.baseSixteenRes = $texture;
            });
        };
        return TerrainDisplay3DSprite;
    }(tl3d.Display3DSprite));
    tl3d.TerrainDisplay3DSprite = TerrainDisplay3DSprite;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var BaseEvent = /** @class */ (function () {
        function BaseEvent($type) {
            this.type = $type;
        }
        BaseEvent.COMPLETE = "complete";
        return BaseEvent;
    }());
    tl3d.BaseEvent = BaseEvent;
})(tl3d || (tl3d = {}));
/**
*
*
* pramaType 0 表示无类型 1表示 float 2表示 vec2 3表示vec3
*/

(function (tl3d) {
    var ConstItem = /** @class */ (function () {
        function ConstItem() {
            this.value = new tl3d.Vector3D;
            this.offset = 0;
        }
        Object.defineProperty(ConstItem.prototype, "id", {
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
                this.name = "fc" + value;
                this.offset = value * 4;
            },
            enumerable: true,
            configurable: true
        });
        ConstItem.prototype.creat = function ($vc) {
            this.vecNum = $vc;
            this.vecNum[0 + this.offset] = this.value.x;
            this.vecNum[1 + this.offset] = this.value.y;
            this.vecNum[2 + this.offset] = this.value.z;
            this.vecNum[3 + this.offset] = this.value.w;
        };
        ConstItem.prototype.setData = function (obj) {
            this.id = obj.id;
            this.value = new tl3d.Vector3D(obj.value.x, obj.value.y, obj.value.z, obj.value.w);
            this.paramName0 = obj.paramName0;
            this.param0Type = obj.param0Type;
            this.param0Index = obj.param0Index;
            this.paramName1 = obj.paramName1;
            this.param1Type = obj.param1Type;
            this.param1Index = obj.param1Index;
            this.paramName2 = obj.paramName2;
            this.param2Type = obj.param2Type;
            this.param2Index = obj.param2Index;
            this.paramName3 = obj.paramName3;
            this.param3Type = obj.param3Type;
            this.param3Index = obj.param3Index;
        };
        ConstItem.prototype.setDynamicOffset = function ($dynamic) {
            if (this.paramName0 == $dynamic.paramName) {
                $dynamic.targetOffset = this.param0Index + this.offset;
            }
            else if (this.paramName1 == $dynamic.paramName) {
                $dynamic.targetOffset = this.param1Index + this.offset;
            }
            else if (this.paramName2 == $dynamic.paramName) {
                $dynamic.targetOffset = this.param2Index + this.offset;
            }
            else if (this.paramName3 == $dynamic.paramName) {
                $dynamic.targetOffset = this.param3Index + this.offset;
            }
        };
        ConstItem.prototype.setDynamicDirect = function ($ary, $offset) {
            this.vecNum.set($ary, $offset);
        };
        ConstItem.prototype.setDynamic = function ($dynamic) {
            try {
                this.vecNum.set($dynamic.currentValue, $dynamic.targetOffset);
            }
            catch (err) {
                //console.log("在此处理错误2");
            }
            /**
            if (this.paramName0 == $dynamic.paramName) {
                if (this.param0Type == 1) {
                    this.vecNum[this.param0Index + this.offset] = $dynamic.currentValue.x;
                } else if (this.param0Type == 2) {
                    this.vecNum[this.param0Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param0Index + 1 + this.offset] = $dynamic.currentValue.y;
                } else if (this.param0Type == 3) {
                    this.vecNum[this.param0Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param0Index + 1 + this.offset] = $dynamic.currentValue.y;
                    this.vecNum[this.param0Index + 2 + this.offset] = $dynamic.currentValue.z;
                } else if (this.param0Type == 4) {
                    this.vecNum[this.param0Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param0Index + 1 + this.offset] = $dynamic.currentValue.y;
                    this.vecNum[this.param0Index + 2 + this.offset] = $dynamic.currentValue.z;
                    this.vecNum[this.param0Index + 3 + this.offset] = $dynamic.currentValue.w;
                }
            } else if (this.paramName1 == $dynamic.paramName) {
                if (this.param1Type == 1) {
                    this.vecNum[this.param1Index + this.offset] = $dynamic.currentValue.x;
                } else if (this.param1Type == 2) {
                    this.vecNum[this.param1Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param1Index + 1 + this.offset] = $dynamic.currentValue.y;
                } else if (this.param1Type == 3) {
                    this.vecNum[this.param1Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param1Index + 1 + this.offset] = $dynamic.currentValue.y;
                    this.vecNum[this.param1Index + 2 + this.offset] = $dynamic.currentValue.z;
                } else if (this.param1Type == 4) {
                    this.vecNum[this.param1Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param1Index + 1 + this.offset] = $dynamic.currentValue.y;
                    this.vecNum[this.param1Index + 2 + this.offset] = $dynamic.currentValue.z;
                    this.vecNum[this.param1Index + 3 + this.offset] = $dynamic.currentValue.w;
                }
            } else if (this.paramName2 == $dynamic.paramName) {
                if (this.param2Type == 1) {
                    this.vecNum[this.param2Index + this.offset] = $dynamic.currentValue.x;
                } else if (this.param2Type == 2) {
                    this.vecNum[this.param2Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param2Index + 1 + this.offset] = $dynamic.currentValue.y;
                } else if (this.param2Type == 3) {
                    this.vecNum[this.param2Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param2Index + 1 + this.offset] = $dynamic.currentValue.y;
                    this.vecNum[this.param2Index + 2 + this.offset] = $dynamic.currentValue.z;
                } else if (this.param2Type == 4) {
                    this.vecNum[this.param2Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param2Index + 1 + this.offset] = $dynamic.currentValue.y;
                    this.vecNum[this.param2Index + 2 + this.offset] = $dynamic.currentValue.z;
                    this.vecNum[this.param2Index + 3 + this.offset] = $dynamic.currentValue.w;
                }
            } else if (this.paramName3 == $dynamic.paramName) {
                if (this.param3Type == 1) {
                    this.vecNum[this.param3Index + this.offset] = $dynamic.currentValue.x;
                } else if (this.param3Type == 2) {
                    this.vecNum[this.param3Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param3Index + 1 + this.offset] = $dynamic.currentValue.y;
                } else if (this.param3Type == 3) {
                    this.vecNum[this.param3Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param3Index + 1 + this.offset] = $dynamic.currentValue.y;
                    this.vecNum[this.param3Index + 2 + this.offset] = $dynamic.currentValue.z;
                } else if (this.param3Type == 4) {
                    this.vecNum[this.param3Index + this.offset] = $dynamic.currentValue.x;
                    this.vecNum[this.param3Index + 1 + this.offset] = $dynamic.currentValue.y;
                    this.vecNum[this.param3Index + 2 + this.offset] = $dynamic.currentValue.z;
                    this.vecNum[this.param3Index + 3 + this.offset] = $dynamic.currentValue.w;
                }
    
            }
             */
        };
        return ConstItem;
    }());
    tl3d.ConstItem = ConstItem;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var DynamicBaseConstItem = /** @class */ (function () {
        function DynamicBaseConstItem() {
        }
        DynamicBaseConstItem.prototype.update = function (t) {
            if (t === void 0) { t = 0; }
            if (this.target) {
                this.target.setDynamic(this);
            }
        };
        Object.defineProperty(DynamicBaseConstItem.prototype, "type", {
            get: function () {
                return this._type;
            },
            set: function (value) {
                this._type = value;
            },
            enumerable: true,
            configurable: true
        });
        DynamicBaseConstItem.prototype.setTargetInfo = function ($target, $paramName, $type) {
            this.target = $target;
            this.paramName = $paramName;
            this.type = $type;
            if (this.target) {
                this.target.setDynamicOffset(this);
            }
            this.currentValue = new Array($type);
        };
        DynamicBaseConstItem.prototype.setCurrentVal = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            for (var i = 0; i < args.length; i++) {
                this.currentValue[i] = args[i];
                // if (i == 0) {
                //     this.currentValue.x = args[i];
                // } else if (i == 1) {
                //     this.currentValue.y = args[i];
                // } else if (i == 2) {
                //     this.currentValue.z = args[i];
                // }
            }
        };
        return DynamicBaseConstItem;
    }());
    tl3d.DynamicBaseConstItem = DynamicBaseConstItem;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var DynamicBaseTexItem = /** @class */ (function () {
        function DynamicBaseTexItem() {
        }
        DynamicBaseTexItem.prototype.destory = function () {
            if (this.textureRes) {
                this.textureRes.useNum--;
            }
            this.target = null;
        };
        Object.defineProperty(DynamicBaseTexItem.prototype, "texture", {
            get: function () {
                if (this.textureRes) {
                    return this.textureRes.texture;
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        return DynamicBaseTexItem;
    }());
    tl3d.DynamicBaseTexItem = DynamicBaseTexItem;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var DynamicConstItem = /** @class */ (function (_super) {
        __extends(DynamicConstItem, _super);
        function DynamicConstItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DynamicConstItem.prototype.update = function (t) {
            if (t === void 0) { t = 0; }
            this.currentValue = this.curve.getValue(t);
            this.target.setDynamic(this);
            //this.target.setDynamicDirect(this.curve.getValue(t),this.targetOffset);
        };
        Object.defineProperty(DynamicConstItem.prototype, "type", {
            set: function (value) {
                this._type = value;
                this.curve = new tl3d.Curve;
                this.curve.type = value;
            },
            enumerable: true,
            configurable: true
        });
        return DynamicConstItem;
    }(tl3d.DynamicBaseConstItem));
    tl3d.DynamicConstItem = DynamicConstItem;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var DynamicTexItem = /** @class */ (function (_super) {
        __extends(DynamicTexItem, _super);
        function DynamicTexItem() {
            return _super.call(this) || this;
        }
        DynamicTexItem.prototype.destory = function () {
            _super.prototype.destory.call(this);
            if (this._textureDynamic) {
                tl3d.Scene_data.context3D.deleteTexture(this._textureDynamic);
            }
            //if (this.textureRes){
            //    this.textureRes.useNum--;
            //}
            this.target = null;
            //this.curve = null;
        };
        DynamicTexItem.prototype.initCurve = function ($type) {
            this.curve = new tl3d.Curve;
            this.curve.type = $type;
        };
        Object.defineProperty(DynamicTexItem.prototype, "texture", {
            get: function () {
                if (this._textureDynamic) {
                    return this._textureDynamic;
                }
                else {
                    if (this.textureRes) {
                        return this.textureRes.texture;
                    }
                    else {
                        return null;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        DynamicTexItem.prototype.creatTextureByCurve = function () {
            var i = 0;
            var endVecIndex = this.curve.valueVec.length - 1;
            var imgNumVec = new Array;
            for (var i = 0; i < this.life; i++) {
                if (i < this.curve.begintFrame) {
                    imgNumVec.push(this.curve.valueVec[0][0] * 0xff, this.curve.valueVec[0][1] * 0xff, this.curve.valueVec[0][2] * 0xff, this.curve.valueVec[0][3] * 0xff);
                }
                else if (i > this.curve.maxFrame) {
                    if (this.curve.maxFrame == 0 && this.curve.begintFrame < 0) {
                        imgNumVec.push(0xff, 0xff, 0xff, 0xff);
                    }
                    else {
                        imgNumVec.push(this.curve.valueVec[endVecIndex][0] * 0xff, this.curve.valueVec[endVecIndex][1] * 0xff, this.curve.valueVec[endVecIndex][2] * 0xff, this.curve.valueVec[endVecIndex][3] * 0xff);
                    }
                }
                else {
                    if (this.curve.begintFrame < 0) {
                        imgNumVec.push(0xff, 0xff, 0xff, 0xff);
                    }
                    else {
                        var index = i - this.curve.begintFrame;
                        imgNumVec.push(this.curve.valueVec[index][0] * 0xff, this.curve.valueVec[index][1] * 0xff, this.curve.valueVec[index][2] * 0xff, this.curve.valueVec[index][3] * 0xff);
                    }
                }
            }
            var $ctx = tl3d.UIManager.getInstance().getContext2D(64, 2, false);
            var baseindex;
            for (var i = 0; i < 64; i++) {
                baseindex = Math.floor(i / 64 * this.life) * 4;
                $ctx.fillStyle = "rgba(" + Math.floor(imgNumVec[baseindex + 0]) + "," + Math.floor(imgNumVec[baseindex + 1]) + "," + Math.floor(imgNumVec[baseindex + 2]) + "," + Math.floor(imgNumVec[baseindex + 3]) / 0xff + ")";
                $ctx.fillRect(i, 0, 1, 2);
            }
            this._textureDynamic = tl3d.TextureManager.getInstance().getCanvasTexture($ctx).texture;
        };
        Object.defineProperty(DynamicTexItem.prototype, "life", {
            //public argbToHex(r: Number, g: Number, b: Number, a: Number): uint {
            //    var expColor: uint = uint(a * 0xff) << 24 | uint(r * 0xff) << 16 | uint(g * 0xff) << 8 | uint(b * 0xff);
            //    return expColor;
            //}
            get: function () {
                return this._life;
            },
            set: function (value) {
                this._life = value;
            },
            enumerable: true,
            configurable: true
        });
        return DynamicTexItem;
    }(tl3d.DynamicBaseTexItem));
    tl3d.DynamicTexItem = DynamicTexItem;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Material = /** @class */ (function (_super) {
        __extends(Material, _super);
        function Material() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.texList = new Array;
            _this.constList = new Array;
            _this.killNum = 0;
            _this.writeZbuffer = true;
            _this.fogMode = 0;
            _this.fcNum = 0;
            return _this;
        }
        Material.prototype.update = function (t) {
            this.updateTime(t);
            //this.updateCam();
            this.updateScene();
        };
        Material.prototype.updateTime = function (t) {
            if (this.hasTime) {
                this.fcData[1] = t;
            }
        };
        Material.prototype.updateCam = function (x, y, z) {
            if (this.usePbr || this.fogMode == 1) {
                var idx = this.fcIDAry[0] * 4;
                this.fcData[0 + idx] = x;
                this.fcData[1 + idx] = y;
                this.fcData[2 + idx] = z;
            }
        };
        Material.prototype.updateScene = function () {
            if (this.sceneNumId == tl3d.Scene_data.sceneNumId) {
                return;
            }
            this.sceneNumId = tl3d.Scene_data.sceneNumId;
            if (this.fogMode != 0) {
                var idx = this.fcIDAry[1] * 4;
                // this.fcData[0 + idx] = Scene_data.fogColor[0];  因为现在是多场景示例，就不用重新设置了
                // this.fcData[1 + idx] = Scene_data.fogColor[1];
                // this.fcData[2 + idx] = Scene_data.fogColor[2];
            }
            if (this.scaleLightMap) {
                var idx = this.fcIDAry[2] * 4;
                this.fcData[0 + idx] = tl3d.Scene_data.scaleLight[0];
            }
        };
        Material.prototype.initFcData = function () {
            this.fcData = new Float32Array(this.fcNum * 4);
            if (this.fcNum <= 0) {
                return;
            }
            this.sceneNumId = tl3d.Scene_data.sceneNumId;
            if (this.hasTime || this.useKill || this.fogMode != 0) { //fc0
                if (this.useKill) {
                    this.fcData[0] = this.killNum;
                }
                if (this.fogMode != 0) {
                    this.fcData[2] = tl3d.Scene_data.fogData[0];
                    this.fcData[3] = tl3d.Scene_data.fogData[1];
                }
            }
            if (this.usePbr || this.fogMode == 1) {
                var idx = this.fcIDAry[0] * 4;
                this.fcData[0 + idx] = tl3d.Scene_data.cam3D.x / 100;
                this.fcData[1 + idx] = tl3d.Scene_data.cam3D.y / 100;
                this.fcData[2 + idx] = tl3d.Scene_data.cam3D.z / 100;
            }
            if (this.fogMode != 0) {
                var idx = this.fcIDAry[1] * 4;
                this.fcData[0 + idx] = tl3d.Scene_data.fogColor[0];
                this.fcData[1 + idx] = tl3d.Scene_data.fogColor[1];
                this.fcData[2 + idx] = tl3d.Scene_data.fogColor[2];
            }
            if (this.scaleLightMap) {
                var idx = this.fcIDAry[2] * 4;
                this.fcData[0 + idx] = tl3d.Scene_data.scaleLight[0];
            }
        };
        Material.prototype.setCompileData = function (_compileData) {
            if (!_compileData) {
                return;
            }
            this.shaderStr = _compileData.shaderStr;
            this.hasTime = _compileData.hasTime;
            this.timeSpeed = _compileData.timeSpeed;
            this.blendMode = _compileData.blendMode;
            this.backCull = _compileData.backCull;
            this.killNum = _compileData.killNum;
            this.hasVertexColor = _compileData.hasVertexColor;
            this.usePbr = _compileData.usePbr;
            this.useNormal = _compileData.useNormal;
            this.roughness = _compileData.roughness;
            this.writeZbuffer = _compileData.writeZbuffer;
            this.hasFresnel = _compileData.hasFresnel;
            this.useDynamicIBL = _compileData.useDynamicIBL;
            this.normalScale = _compileData.normalScale;
            this.lightProbe = _compileData.lightProbe;
            this.useKill = _compileData.useKill;
            this.directLight = _compileData.directLight;
            this.noLight = _compileData.noLight;
            this.scaleLightMap = _compileData.scaleLightMap;
            this.fogMode = _compileData.fogMode;
            this.hasParticleColor = false;
            this.initFcData();
            if (_compileData.texList) {
                var ary = _compileData.texList;
                this.texList = new Array;
                for (var i = 0; i < ary.length; i++) {
                    var texItem = new tl3d.TexItem;
                    texItem.id = ary[i].id;
                    texItem.url = ary[i].url;
                    texItem.isDynamic = ary[i].isDynamic;
                    texItem.paramName = ary[i].paramName;
                    texItem.isMain = ary[i].isMain;
                    texItem.isParticleColor = ary[i].isParticleColor;
                    texItem.type = ary[i].type;
                    texItem.wrap = ary[i].wrap;
                    texItem.filter = ary[i].filter;
                    texItem.mipmap = ary[i].mipmap;
                    this.texList.push(texItem);
                    if (texItem.isParticleColor) {
                        this.hasParticleColor = true;
                    }
                }
            }
            if (_compileData.constList) {
                ary = _compileData.constList;
                this.constList = new Array;
                for (i = 0; i < ary.length; i++) {
                    var constItem = new tl3d.ConstItem;
                    constItem.setData(ary[i]);
                    constItem.creat(this.fcData);
                    this.constList.push(constItem);
                }
            }
        };
        Material.prototype.setByteData = function (byte) {
            var fs = byte;
            var vesion = fs.readInt();
            this.shaderStr = fs.readUTF(); //fs.writeUTF(_compileData.shaderStr)
            this.hasTime = fs.readBoolean(); //fs.writeBoolean(_compileData.hasTime);
            this.timeSpeed = fs.readFloat(); //fs.writeFloat(_compileData.timeSpeed);
            this.blendMode = fs.readFloat(); //fs.writeFloat(_compileData.blendMode);
            this.backCull = fs.readBoolean(); //fs.writeBoolean(_compileData.backCull);
            this.killNum = fs.readFloat(); //fs.writeFloat(_compileData.killNum);
            this.hasVertexColor = fs.readBoolean(); //fs.writeBoolean(_compileData.hasVertexColor);
            this.usePbr = fs.readBoolean(); //fs.writeBoolean(_compileData.usePbr);
            this.useNormal = fs.readBoolean(); //fs.writeBoolean(_compileData.useNormal);
            this.roughness = fs.readFloat(); //fs.writeFloat(_compileData.roughness);
            this.writeZbuffer = fs.readBoolean(); //fs.writeBoolean(_compileData.writeZbuffer);
            this.hasFresnel = fs.readBoolean(); //fs.writeBoolean(_compileData.hasFresnel);
            this.useDynamicIBL = fs.readBoolean(); //fs.writeBoolean(_compileData.useDynamicIBL);
            this.normalScale = fs.readFloat(); //fs.writeFloat(_compileData.normalScale);
            this.lightProbe = fs.readBoolean(); //fs.writeBoolean(_compileData.lightProbe);
            this.useKill = fs.readBoolean(); //fs.writeBoolean(_compileData.useKill);
            this.directLight = fs.readBoolean(); //fs.writeBoolean(_compileData.directLight);
            this.noLight = fs.readBoolean(); //fs.writeBoolean(_compileData.noLight);
            this.scaleLightMap = fs.readBoolean(); //fs.writeBoolean(_compileData.scaleLightMap)
            if (vesion > 2) {
                this.fogMode = fs.readInt();
            }
            if (vesion >= 22) {
                this.fcNum = fs.readByte();
                var leg = fs.readByte();
                this.fcIDAry = new Array;
                for (var i = 0; i < leg; i++) {
                    this.fcIDAry.push(fs.readByte());
                }
            }
            else {
                // //console.log("ddddd");
            }
            this.hasParticleColor = false;
            this.initFcData();
            this.readTexList(fs);
            this.readConstLis(fs);
        };
        Material.prototype.readConstLis = function (fs) {
            var constLisLen = fs.readInt();
            this.constList = new Array;
            for (var i = 0; i < constLisLen; i++) {
                var constItem = new tl3d.ConstItem;
                constItem.id = fs.readFloat();
                constItem.value = new tl3d.Vector3D(fs.readFloat(), fs.readFloat(), fs.readFloat(), fs.readFloat());
                constItem.paramName0 = fs.readUTF();
                constItem.param0Type = fs.readFloat();
                constItem.param0Index = fs.readFloat();
                constItem.paramName1 = fs.readUTF();
                constItem.param1Type = fs.readFloat();
                constItem.param1Index = fs.readFloat();
                constItem.paramName2 = fs.readUTF();
                constItem.param2Type = fs.readFloat();
                constItem.param2Index = fs.readFloat();
                constItem.paramName3 = fs.readUTF();
                constItem.param3Type = fs.readFloat();
                constItem.param3Index = fs.readFloat();
                constItem.creat(this.fcData);
                this.constList.push(constItem);
            }
        };
        Material.prototype.readTexList = function (fs) {
            var texListLen = fs.readInt();
            this.texList = new Array;
            for (var i = 0; i < texListLen; i++) {
                var texItem = new tl3d.TexItem;
                texItem.id = fs.readFloat();
                texItem.url = fs.readUTF();
                texItem.isDynamic = fs.readBoolean();
                texItem.paramName = fs.readUTF();
                texItem.isMain = fs.readBoolean();
                texItem.isParticleColor = fs.readBoolean();
                texItem.type = fs.readFloat();
                texItem.wrap = fs.readFloat();
                texItem.filter = fs.readFloat();
                texItem.mipmap = fs.readFloat();
                if (texItem.isParticleColor) {
                    this.hasParticleColor = true;
                }
                this.texList.push(texItem);
            }
        };
        Material.prototype.destory = function () {
            for (var i = 0; i < this.texList.length; i++) {
                this.texList[i].destory();
            }
            this.texList = null;
            this.constList = null;
            if (this.shader) {
                this.shader.clearUseNum();
            }
        };
        return Material;
    }(tl3d.ResCount));
    tl3d.Material = Material;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MaterialBaseParam = /** @class */ (function (_super) {
        __extends(MaterialBaseParam, _super);
        function MaterialBaseParam() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MaterialBaseParam.prototype.destory = function () {
            for (var i = 0; i < this.dynamicTexList.length; i++) {
                this.dynamicTexList[i].destory();
            }
            this.dynamicTexList = null;
            this.dynamicConstList = null;
        };
        MaterialBaseParam.prototype.update = function () {
            if (this.material && this.dynamicConstList) {
                for (var i = 0; i < this.dynamicConstList.length; i++) {
                    this.dynamicConstList[i].update();
                }
            }
        };
        MaterialBaseParam.prototype.setData = function ($material, $ary) {
            this.material = $material;
            this.dynamicConstList = new Array;
            this.dynamicTexList = new Array;
            var constList = $material.constList;
            var texList = $material.texList;
            for (var i = 0; i < $ary.length; i++) {
                var obj = $ary[i];
                if (obj.type == 0) {
                    var texItem = new tl3d.DynamicBaseTexItem();
                    texItem.paramName = obj.name;
                    for (var j = 0; j < texList.length; j++) {
                        if (texItem.paramName == texList[j].paramName) {
                            texItem.target = texList[j];
                            break;
                        }
                    }
                    var mipmap = 0;
                    if (texItem.target) {
                        mipmap = texItem.target.mipmap;
                    }
                    mipmap = 0;
                    tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + obj.url, function ($textres) {
                        texItem.textureRes = $textres;
                    }, 0, null, 0, mipmap);
                    this.dynamicTexList.push(texItem);
                }
                else {
                    var targetName = obj.name;
                    var target = null;
                    for (var j = 0; j < constList.length; j++) {
                        if (targetName == constList[j].paramName0
                            || targetName == constList[j].paramName1
                            || targetName == constList[j].paramName2
                            || targetName == constList[j].paramName3) {
                            target = constList[j];
                            break;
                        }
                    }
                    var constItem = new tl3d.DynamicBaseConstItem();
                    constItem.setTargetInfo(target, targetName, obj.type);
                    if (obj.type == 1) {
                        constItem.setCurrentVal(obj.x);
                    }
                    else if (obj.type == 2) {
                        constItem.setCurrentVal(obj.x, obj.y);
                    }
                    else {
                        constItem.setCurrentVal(obj.x, obj.y, obj.z);
                    }
                    this.dynamicConstList.push(constItem);
                }
            }
        };
        return MaterialBaseParam;
    }(tl3d.GC));
    tl3d.MaterialBaseParam = MaterialBaseParam;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MaterialManager = /** @class */ (function (_super) {
        __extends(MaterialManager, _super);
        function MaterialManager() {
            var _this = 
            //this._dic = new Object();
            _super.call(this) || this;
            _this._loadDic = new Object();
            _this._resDic = new Object();
            _this._regDic = new Object();
            return _this;
        }
        MaterialManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new MaterialManager();
            }
            return this._instance;
        };
        /**
        public getMaterial($url: string, $fun: Function, $info: Object = null, $autoReg: boolean = false, $regName: string = null, $shader3D: Shader3D = null): void {
    
            if (this._dic[$url]) {
                if ($info) {
                    $fun(this._dic[$url], $info);
                } else {
                    $fun(this._dic[$url]);
                }
                return;
            }
    
            var materialLoad: MaterialLoad = new MaterialLoad($fun, $info, $url, $autoReg, $regName, $shader3D);
            if (this._loadDic[$url]) {
                var ary: Array<MaterialLoad> = this._loadDic[$url];
                ary.push(materialLoad);
                return;
            }
    
            this._loadDic[$url] = new Array;
            this._loadDic[$url].push(materialLoad);
    
            if (this._resDic[$url]) {
                this.loadMaterialCom(this._resDic[$url], materialLoad);
            } else {
                LoadManager.getInstance().load($url, LoadManager.XML_TYPE, ($data: string, _info: MaterialLoad) => { this.loadMaterialCom($data, _info) }, materialLoad);
            }
        }
         */
        MaterialManager.prototype.getMaterialByte = function ($url, $fun, $info, $autoReg, $regName, $shader3DCls) {
            var _this = this;
            if ($info === void 0) { $info = null; }
            if ($autoReg === void 0) { $autoReg = false; }
            if ($regName === void 0) { $regName = null; }
            if ($shader3DCls === void 0) { $shader3DCls = null; }
            if (this._dic[$url]) {
                if ($info) {
                    $fun(this._dic[$url], $info);
                }
                else {
                    $fun(this._dic[$url]);
                }
                this._dic[$url].useNum++;
                // if ($url.indexOf("m_ef_ver_byte.txt") != -1) {
                //     //console.log("aaaaaaaaaaaaaaaa", this._dic[$url].useNum)
                // }
                return;
            }
            var materialLoad = new MaterialLoad($fun, $info, $url, $autoReg, $regName, $shader3DCls);
            if (this._loadDic[$url]) {
                var ary = this._loadDic[$url];
                ary.push(materialLoad);
                return;
            }
            this._loadDic[$url] = new Array;
            this._loadDic[$url].push(materialLoad);
            if (this._resDic[$url]) {
                this.meshByteMaterialByt(this._resDic[$url], materialLoad);
                if (this._regDic[$url]) {
                    this._dic[$url].useNum += this._regDic[$url];
                    delete this._regDic[$url];
                }
                delete this._resDic[$url];
            }
            else {
                tl3d.LoadManager.getInstance().load($url, tl3d.LoadManager.BYTE_TYPE, function ($data, _info) { _this.loadMaterialByteCom($data, _info); }, materialLoad);
            }
        };
        MaterialManager.prototype.meshByteMaterialByt = function (byte, _info) {
            var material = new tl3d.Material();
            material.setByteData(byte);
            material.url = _info.url;
            this.loadMaterial(material);
            if (_info.autoReg) {
                material.shader = tl3d.ProgrmaManager.getInstance().getMaterialProgram(_info.regName, _info.shader3D, material, null, true);
                material.program = material.shader.program;
            }
            var ary = this._loadDic[_info.url];
            for (var i = 0; i < ary.length; i++) {
                if (ary[i].info) {
                    ary[i].fun(material, ary[i].info);
                }
                else {
                    ary[i].fun(material);
                }
                material.useNum++;
                // if (_info.url.indexOf("m_ef_ver_byte.txt") != -1) {
                //     //console.log("aaaaaaaaaaaaaaaa", material.useNum)
                // }
            }
            delete this._loadDic[_info.url];
            this._dic[_info.url] = material;
        };
        MaterialManager.prototype.loadMaterialByteCom = function ($data, _info) {
            var byte = new tl3d.TLByteArray($data);
            this.meshByteMaterialByt(byte, _info);
        };
        MaterialManager.prototype.addResByte = function ($url, $data) {
            if (!this._dic[$url] && !this._resDic[$url]) {
                this._resDic[$url] = $data;
            }
        };
        MaterialManager.prototype.registerUrl = function ($url) {
            $url = $url.replace("_byte.txt", ".txt");
            $url = $url.replace(".txt", "_byte.txt");
            if (this._dic[$url]) {
                this._dic[$url].useNum++;
            }
            else {
                if (this._regDic[$url]) {
                    this._regDic[$url]++;
                }
                else {
                    this._regDic[$url] == 1;
                }
            }
        };
        MaterialManager.prototype.releaseUrl = function ($url) {
            $url = $url.replace("_byte.txt", ".txt");
            $url = $url.replace(".txt", "_byte.txt");
            if (this._dic[$url]) {
                this._dic[$url].clearUseNum();
            }
        };
        /**
        public loadMaterialCom($data: string, _info: MaterialLoad): void {
            var obj = JSON.parse($data);
            
            var material: Material = new Material();
            material.setCompileData(obj);
            material.url = _info.url;
    
            this.loadMaterial(material);
    
            if (_info.autoReg){
                material.program = ProgrmaManager.getInstance().getMaterialProgram(_info.regName, _info.shader3D, material, null, true);
            }
    
            var ary: Array<TextureLoad> = this._loadDic[_info.url];
            for (var i: number = 0; i < ary.length; i++) {
                if (ary[i].info) {
                    ary[i].fun(material, ary[i].info);
                } else {
                    ary[i].fun(material);
                }
            }
            
            delete this._loadDic[_info.url];
    
            this._dic[_info.url] = material;
    
        }
        */
        MaterialManager.prototype.loadMaterial = function ($material) {
            var texVec = $material.texList;
            for (var i = 0; i < texVec.length; i++) {
                if (texVec[i].isParticleColor || texVec[i].isDynamic || texVec[i].type != 0) {
                    continue;
                }
                tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + texVec[i].url, function ($textureVo, $texItem) {
                    $texItem.textureRes = $textureVo;
                }, texVec[i].wrap, texVec[i], texVec[i].filter, texVec[i].mipmap);
            }
        };
        MaterialManager.prototype.loadDynamicTexUtil = function (material) {
            var dynamicTexList = material.dynamicTexList;
            for (var i = 0; i < dynamicTexList.length; i++) {
                if (dynamicTexList[i].isParticleColor) {
                    dynamicTexList[i].creatTextureByCurve();
                }
                else {
                    tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + dynamicTexList[i].url, function ($textureVo, $texItem) {
                        $texItem.textureRes = $textureVo;
                    }, 0, dynamicTexList[i], 0, 1);
                }
            }
        };
        return MaterialManager;
    }(tl3d.ResGC));
    tl3d.MaterialManager = MaterialManager;
    var MaterialLoad = /** @class */ (function () {
        function MaterialLoad($fun, $info, $url, $autoReg, $regName, $shader3D) {
            this.fun = $fun;
            this.info = $info;
            this.url = $url;
            this.autoReg = $autoReg;
            this.regName = $regName;
            this.shader3D = $shader3D;
        }
        return MaterialLoad;
    }());
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MaterialParam = /** @class */ (function (_super) {
        __extends(MaterialParam, _super);
        //public dynamicTexList:Array<DynamicTexItem>;
        //public dynamicConstList:Array<DynamicConstItem>;
        function MaterialParam() {
            return _super.call(this) || this;
        }
        MaterialParam.prototype.destory = function () {
            //this.material.useNum--;
            this.material.useNum--;
            this.shader.useNum--;
            // if(this.material.url.indexOf("m_ef_ver_byte.txt") != -1){
            //     //console.log("bbbbbbbbbbbbbbbbbbb",this.material.useNum)
            // }
            //for (var i: number = 0; i < this.dynamicTexList.length; i++){
            //    this.dynamicTexList[i].destory();
            //}
            //this.dynamicTexList = null;
            //this.dynamicConstList = null;
            _super.prototype.destory.call(this);
        };
        MaterialParam.prototype.setMaterial = function ($materialTree) {
            this.material = $materialTree;
            this.materialUrl = $materialTree.url;
            this.dynamicTexList = new Array;
            this.dynamicConstList = new Array;
            this.setTexList();
            this.setConstList();
        };
        MaterialParam.prototype.setLife = function ($life) {
            for (var i = 0; i < this.dynamicTexList.length; i++) {
                if (this.dynamicTexList[i].isParticleColor) {
                    this.dynamicTexList[i].life = $life;
                }
            }
        };
        MaterialParam.prototype.setTexList = function () {
            var texList = this.material.texList;
            for (var i = 0; i < texList.length; i++) {
                var dyTex;
                if (texList[i].isParticleColor) {
                    dyTex = new tl3d.DynamicTexItem;
                    dyTex.target = texList[i];
                    dyTex.paramName = texList[i].paramName;
                    dyTex.initCurve(4);
                    this.dynamicTexList.push(dyTex);
                    dyTex.isParticleColor = true;
                }
                else if (texList[i].isDynamic) {
                    dyTex = new tl3d.DynamicTexItem;
                    dyTex.target = texList[i];
                    dyTex.paramName = texList[i].paramName;
                    this.dynamicTexList.push(dyTex);
                }
            }
        };
        MaterialParam.prototype.setConstList = function () {
            var constList = this.material.constList;
            for (var i = 0; i < constList.length; i++) {
                var constItem = constList[i];
                var dyCon;
                if (constItem.param0Type != 0) {
                    dyCon = new tl3d.DynamicConstItem;
                    // dyCon.target = constItem;
                    // dyCon.paramName = constItem.paramName0;
                    // dyCon.type = constItem.param0Type;
                    dyCon.setTargetInfo(constItem, constItem.paramName0, constItem.param0Type);
                    this.dynamicConstList.push(dyCon);
                }
                if (constItem.param1Type != 0) {
                    dyCon = new tl3d.DynamicConstItem;
                    // dyCon.target = constItem;
                    // dyCon.paramName = constItem.paramName1;
                    // dyCon.type = constItem.param1Type;
                    dyCon.setTargetInfo(constItem, constItem.paramName1, constItem.param1Type);
                    this.dynamicConstList.push(dyCon);
                }
                if (constItem.param2Type != 0) {
                    dyCon = new tl3d.DynamicConstItem;
                    // dyCon.target = constItem;
                    // dyCon.paramName = constItem.paramName2;
                    // dyCon.type = constItem.param2Type;
                    dyCon.setTargetInfo(constItem, constItem.paramName2, constItem.param2Type);
                    this.dynamicConstList.push(dyCon);
                }
                if (constItem.param3Type != 0) {
                    dyCon = new tl3d.DynamicConstItem;
                    // dyCon.target = constItem;
                    // dyCon.paramName = constItem.paramName3;
                    // dyCon.type = constItem.param3Type;
                    dyCon.setTargetInfo(constItem, constItem.paramName3, constItem.param3Type);
                    this.dynamicConstList.push(dyCon);
                }
            }
        };
        MaterialParam.prototype.setTextObj = function (ary) {
            for (var i = 0; i < ary.length; i++) {
                var obj = ary[i];
                for (var j = 0; j < this.dynamicTexList.length; j++) {
                    if (this.dynamicTexList[j].paramName == obj.paramName) {
                        if (this.dynamicTexList[j].isParticleColor) {
                            this.dynamicTexList[j].curve.setData(obj.curve);
                        }
                        else {
                            this.dynamicTexList[j].url = obj.url;
                        }
                        break;
                    }
                }
            }
        };
        MaterialParam.prototype.setConstObj = function (ary) {
            for (var i = 0; i < ary.length; i++) {
                var obj = ary[i];
                for (var j = 0; j < this.dynamicConstList.length; j++) {
                    if (this.dynamicConstList[j].paramName == obj.paramName) {
                        this.dynamicConstList[j].curve.setData(obj.curve);
                        break;
                    }
                }
            }
        };
        return MaterialParam;
    }(tl3d.MaterialBaseParam));
    tl3d.MaterialParam = MaterialParam;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TexItem = /** @class */ (function () {
        function TexItem() {
        }
        TexItem.prototype.destory = function () {
            if (this.textureRes) {
                this.textureRes.clearUseNum();
            }
        };
        Object.defineProperty(TexItem.prototype, "id", {
            get: function () {
                return this._id;
            },
            set: function (value) {
                this._id = value;
                this.name = "fs" + value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TexItem.prototype, "texture", {
            get: function () {
                if (this.textureRes) {
                    return this.textureRes.texture;
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        TexItem.LIGHTMAP = 1;
        TexItem.LTUMAP = 2;
        TexItem.CUBEMAP = 3;
        TexItem.HEIGHTMAP = 4;
        TexItem.REFRACTIONMAP = 5;
        return TexItem;
    }());
    tl3d.TexItem = TexItem;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TextureCube = /** @class */ (function () {
        function TextureCube() {
        }
        return TextureCube;
    }());
    tl3d.TextureCube = TextureCube;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    //贴图管理器
    var TextureManager = /** @class */ (function (_super) {
        __extends(TextureManager, _super);
        function TextureManager() {
            var _this = _super.call(this) || this;
            _this._loadDic = new Object();
            _this._resDic = new Object();
            _this.initDefaultLightMapTexture();
            return _this;
        }
        TextureManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new TextureManager();
            }
            return this._instance;
        };
        TextureManager.prototype.hasTexture = function ($url) {
            if (this._dic[$url]) {
                return true;
            }
            return false;
        };
        /**
         * 获取贴图
         * @param 地址
         * @param fun 回调
         * @param wrapType
         * @param info
         * @param filteType
         * @param mipmapType
         */
        TextureManager.prototype.getTexture = function ($url, $fun, $wrapType, $info, $filteType, $mipmapType) {
            var _this = this;
            if ($wrapType === void 0) { $wrapType = 0; }
            if ($info === void 0) { $info = null; }
            if ($filteType === void 0) { $filteType = 0; }
            if ($mipmapType === void 0) { $mipmapType = 0; }
            var textres = this._dic[$url];
            if (textres) {
                if ($info) {
                    $fun(textres, $info);
                }
                else {
                    $fun(textres);
                }
                textres.useNum++;
                return;
            }
            var textureLoad = new TextureLoad($fun, $info, $url, $wrapType, $filteType, $mipmapType); //加载完的回调
            var loadList = this._loadDic[$url];
            if (loadList) {
                loadList.push(textureLoad);
                return;
            }
            loadList = new Array;
            loadList.push(textureLoad);
            this._loadDic[$url] = loadList;
            if (this._resDic[$url]) { //内存存在创建显存即可
                this.loadTextureCom(this._resDic[$url], textureLoad);
                delete this._resDic[$url];
            }
            else { //没有贴图对象就加载创建
                tl3d.LoadManager.getInstance().load($url, tl3d.LoadManager.IMG_TYPE, function ($img, _info) {
                    _this.loadTextureCom($img, _info);
                }, textureLoad);
            }
        };
        //贴图加载完毕
        TextureManager.prototype.loadTextureCom = function ($img, _info) {
            var texture = tl3d.Scene_data.context3D.getTexture($img, _info.wrap, _info.filter, _info.mipmap);
            var textres = new tl3d.TextureRes(_info.url);
            textres.texture = texture;
            textres.width = $img.width;
            textres.height = $img.height;
            var ary = this._loadDic[_info.url];
            for (var i = 0; i < ary.length; i++) {
                if (ary[i].info) {
                    ary[i].fun(textres, ary[i].info);
                }
                else {
                    ary[i].fun(textres);
                }
                textres.useNum++;
            }
            delete this._loadDic[_info.url]; //加载队列移除
            this._dic[_info.url] = textres;
        };
        //加载好的图片内存缓存一下
        TextureManager.prototype.addRes = function ($url, $img) {
            if (!this._dic[$url] && !this._resDic[$url]) {
                this._resDic[$url] = $img;
            }
        };
        //清理缓存
        TextureManager.prototype.removeRes = function ($url) {
            var img = this._resDic[$url];
            if (img) {
                delete this._resDic[$url];
            }
        };
        TextureManager.prototype.getCanvasTexture = function (ctx) {
            var tres = new tl3d.TextureRes("");
            var texture = tl3d.Scene_data.context3D.getTexture(ctx.canvas, 0, 0);
            tres.texture = texture;
            return tres;
        };
        TextureManager.prototype.updateTexture = function ($texture, $offsetx, $offsety, ctx) {
            tl3d.Scene_data.context3D.updateTexture($texture, $offsetx, $offsety, ctx.canvas);
        };
        TextureManager.prototype.loadCubeTexture = function ($url, $fun) {
            var cubeMapLoad = new CubemapLoad();
            cubeMapLoad.loadCube($url, function ($cubeList) { $fun($cubeList); });
        };
        //初始化默认光照贴图
        TextureManager.prototype.initDefaultLightMapTexture = function () {
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext("2d");
            canvas.width = 32;
            canvas.height = 32;
            ctx.fillStyle = "rgb(" + 255 / 5 + "," + 255 / 5 + "," + 255 / 5 + ")";
            ctx.fillRect(0, 0, 32, 32);
            this.defaultLightMap = tl3d.Scene_data.context3D.getTexture(canvas);
        };
        return TextureManager;
    }(tl3d.ResGC));
    tl3d.TextureManager = TextureManager;
    var TextureLoad = /** @class */ (function () {
        function TextureLoad($fun, $info, $url, $wrap, $filter, $mipmap) {
            this.fun = $fun;
            this.info = $info;
            this.url = $url;
            this.wrap = $wrap;
            this.filter = $filter;
            this.mipmap = $mipmap;
        }
        return TextureLoad;
    }());
    tl3d.TextureLoad = TextureLoad;
    var CubemapLoad = /** @class */ (function () {
        function CubemapLoad() {
            this.ary = new Array(6);
            this.flagNum = 0;
        }
        CubemapLoad.prototype.loadCube = function ($url, $fun) {
            var _this = this;
            this.fun = $fun;
            for (var i = 0; i < 6; i++) {
                var itemUrl = $url + "0" + (i + 1) + ".jpg";
                tl3d.LoadManager.getInstance().load(itemUrl, tl3d.LoadManager.IMG_TYPE, function ($img, $info) { _this.loadCom($img, $info); }, { "id": i });
            }
        };
        CubemapLoad.prototype.loadCom = function ($img, $info) {
            var wh = $img.width / 4;
            var canvas = document.createElement("canvas");
            var ctx = canvas.getContext("2d");
            canvas.width = wh;
            canvas.height = wh;
            var renderContext = tl3d.Scene_data.context3D.renderContext;
            var texture = renderContext.createTexture();
            renderContext.bindTexture(renderContext.TEXTURE_CUBE_MAP, texture);
            ctx.drawImage($img, wh * 2, wh, wh, wh, 0, 0, wh, wh); //right
            renderContext.texImage2D(renderContext.TEXTURE_CUBE_MAP_POSITIVE_X, 0, renderContext.RGBA, renderContext.RGBA, renderContext.UNSIGNED_BYTE, canvas);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MAG_FILTER, renderContext.LINEAR);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MIN_FILTER, renderContext.LINEAR);
            ctx.drawImage($img, 0, wh, wh, wh, 0, 0, wh, wh); //left
            renderContext.texImage2D(renderContext.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, renderContext.RGBA, renderContext.RGBA, renderContext.UNSIGNED_BYTE, canvas);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MAG_FILTER, renderContext.LINEAR);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MIN_FILTER, renderContext.LINEAR);
            ctx.drawImage($img, wh, 0, wh, wh, 0, 0, wh, wh); //top
            renderContext.texImage2D(renderContext.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, renderContext.RGBA, renderContext.RGBA, renderContext.UNSIGNED_BYTE, canvas);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MAG_FILTER, renderContext.LINEAR);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MIN_FILTER, renderContext.LINEAR);
            ctx.drawImage($img, wh, wh * 2, wh, wh, 0, 0, wh, wh); //bottom
            renderContext.texImage2D(renderContext.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, renderContext.RGBA, renderContext.RGBA, renderContext.UNSIGNED_BYTE, canvas);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MAG_FILTER, renderContext.LINEAR);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MIN_FILTER, renderContext.LINEAR);
            ctx.drawImage($img, wh, wh, wh, wh, 0, 0, wh, wh); //front
            renderContext.texImage2D(renderContext.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, renderContext.RGBA, renderContext.RGBA, renderContext.UNSIGNED_BYTE, canvas);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MAG_FILTER, renderContext.LINEAR);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MIN_FILTER, renderContext.LINEAR);
            ctx.drawImage($img, wh * 3, wh, wh, wh, 0, 0, wh, wh); //back
            renderContext.texImage2D(renderContext.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, renderContext.RGBA, renderContext.RGBA, renderContext.UNSIGNED_BYTE, canvas);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MAG_FILTER, renderContext.LINEAR);
            renderContext.texParameteri(renderContext.TEXTURE_CUBE_MAP, renderContext.TEXTURE_MIN_FILTER, renderContext.LINEAR);
            this.ary[$info.id] = texture;
            this.flagNum++;
            if (this.flagNum == 6) {
                this.fun(this.ary);
            }
        };
        return CubemapLoad;
    }());
    tl3d.CubemapLoad = CubemapLoad;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TextureRes = /** @class */ (function (_super) {
        __extends(TextureRes, _super);
        function TextureRes(url) {
            if (url === void 0) { url = ""; }
            var _this = _super.call(this) || this;
            _this.url = url;
            return _this;
        }
        TextureRes.prototype.destory = function () {
            tl3d.Scene_data.context3D.deleteTexture(this.texture);
            //console.log("销毁纹理",this.url);
        };
        return TextureRes;
    }(tl3d.ResCount));
    tl3d.TextureRes = TextureRes;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ObjectMath = /** @class */ (function () {
        function ObjectMath() {
            this.a = 0;
            this.b = 0;
            this.c = 0;
            this.d = 0;
        }
        return ObjectMath;
    }());
    tl3d.ObjectMath = ObjectMath;
    var Calculation = /** @class */ (function () {
        function Calculation() {
        }
        Calculation._PanelEquationFromThreePt = function (p1, p2, p3) {
            //得到平面方程 ax+by+cz+d=0(传入三个点,返回平面方程a,b,c,d);
            var a = ((p2.y - p1.y) * (p3.z - p1.z) - (p2.z - p1.z) * (p3.y - p1.y));
            var b = ((p2.z - p1.z) * (p3.x - p1.x) - (p2.x - p1.x) * (p3.z - p1.z));
            var c = ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));
            var d = (0 - (a * p1.x + b * p1.y + c * p1.z));
            var tempObjectMath = new ObjectMath;
            tempObjectMath.a = a;
            tempObjectMath.b = b;
            tempObjectMath.c = c;
            tempObjectMath.d = d;
            return tempObjectMath;
        };
        Calculation.calPlaneLineIntersectPoint = function (planeVector, planePoint, linePointA, linePointB) {
            var ret = new tl3d.Vector3D();
            var vp1 = planeVector.x;
            var vp2 = planeVector.y;
            var vp3 = planeVector.z;
            var n1 = planePoint.x;
            var n2 = planePoint.y;
            var n3 = planePoint.z;
            var v1 = linePointA.x - linePointB.x;
            var v2 = linePointA.y - linePointB.y;
            var v3 = linePointA.z - linePointB.z;
            var m1 = linePointB.x;
            var m2 = linePointB.y;
            var m3 = linePointB.z;
            var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
            //首先判断直线是否与平面平行
            if (vpt == 0) {
                return null;
            }
            else {
                var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                ret.x = m1 + v1 * t;
                ret.y = m2 + v2 * t;
                ret.z = m3 + v3 * t;
            }
            return ret;
        };
        return Calculation;
    }());
    tl3d.Calculation = Calculation;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Circle = /** @class */ (function () {
        function Circle($x, $y, $radius) {
            if ($x === void 0) { $x = 0; }
            if ($y === void 0) { $y = 0; }
            if ($radius === void 0) { $radius = 0; }
            this.setData($x, $y, $radius);
        }
        Circle.prototype.setData = function ($x, $y, $radius) {
            this.x = $x;
            this.y = $y;
            this.radius = $radius;
        };
        Circle.prototype.setPos = function ($x, $y) {
            this.x = $x;
            this.y = $y;
        };
        Object.defineProperty(Circle.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Circle.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
            },
            enumerable: true,
            configurable: true
        });
        Circle.prototype.setRadius = function ($radius) {
            this.radius = $radius;
        };
        Circle.prototype.testPoint = function ($point) {
            var xx = this.x - $point.x;
            var yy = this.y - $point.y;
            return Math.sqrt(xx * xx + yy * yy) < this.radius;
        };
        return Circle;
    }());
    tl3d.Circle = Circle;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Groundposition = /** @class */ (function () {
        function Groundposition() {
        }
        Groundposition.getGroundPos = function ($x, $y) {
            var $ty = -500;
            if (!this._plantObjectMath) {
                var A = new tl3d.Vector3D(0, $ty, 500);
                var B = new tl3d.Vector3D(-500, $ty, 0);
                var C = new tl3d.Vector3D(500, $ty, 0);
                this._plantObjectMath = tl3d.Calculation._PanelEquationFromThreePt(A, B, C);
                this._plantnormal = new tl3d.Vector3D(this._plantObjectMath.a, this._plantObjectMath.b, this._plantObjectMath.c);
                this._plantnormal.normalize();
                this._plane_a = new tl3d.Vector3D(A.x, A.y, A.z);
            }
            //计算直线与平面交点
            var line_a = tl3d.MathUtil.mathDisplay2Dto3DWorldPos(new tl3d.Vector2D($x, $y), 500);
            var line_b = new tl3d.Vector3D(tl3d.Scene_data.cam3D.x, tl3d.Scene_data.cam3D.y, tl3d.Scene_data.cam3D.z);
            var crossPoint = tl3d.Calculation.calPlaneLineIntersectPoint(this._plantnormal, this._plane_a, line_a, line_b);
            return crossPoint;
        };
        return Groundposition;
    }());
    tl3d.Groundposition = Groundposition;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MathClass = /** @class */ (function () {
        function MathClass() {
        }
        MathClass.getCamView = function (_Cam, _focus_3d) {
            //var $dis: number = 1000;
            _Cam.update();
            //计算出相机的位置
            var $m = new tl3d.Matrix3D;
            $m.appendRotation(-_focus_3d.rotationX, tl3d.Vector3D.X_AXIS);
            $m.appendRotation(-_focus_3d.rotationY, tl3d.Vector3D.Y_AXIS);
            $m.appendTranslation(_focus_3d.x, _focus_3d.y, _focus_3d.z);
            var $p = $m.transformVector(new tl3d.Vector3D(0, 0, -_Cam.distance));
            _Cam.x = $p.x;
            _Cam.y = $p.y;
            _Cam.z = $p.z;
            _Cam.rotationX = _focus_3d.rotationX;
            _Cam.rotationY = _focus_3d.rotationY;
            //重置相机矩阵
            _Cam.cameraMatrix.identity();
            _Cam.cameraMatrix.prependTranslation(0, 0, _Cam.distance);
            _Cam.cameraMatrix.prependRotation(_Cam.rotationX, tl3d.Vector3D.X_AXIS);
            _Cam.cameraMatrix.prependRotation(_Cam.rotationY, tl3d.Vector3D.Y_AXIS);
            _Cam.cameraMatrix.prependTranslation(-_focus_3d.x, -_focus_3d.y, -_focus_3d.z);
            this.camOffSetShock(_Cam);
            this.updateVp();
            return _Cam.cameraMatrix.m;
        };
        MathClass.camOffSetShock = function (_Cam) {
            if (this.SetShock) {
                _Cam.cameraMatrix.prependTranslation(_Cam.offset.x, _Cam.offset.y, _Cam.offset.z);
            }
        };
        MathClass.updateVp = function () {
            tl3d.Scene_data.vpMatrix.identity();
            tl3d.Scene_data.vpMatrix.prepend(tl3d.Scene_data.viewMatrx3D);
            tl3d.Scene_data.vpMatrix.prepend(tl3d.Scene_data.cam3D.cameraMatrix);
        };
        MathClass.MathCam = function (_Cam) {
            var camera3dMatrix = new tl3d.Matrix3D();
            camera3dMatrix.prependRotation(_Cam.rotationX, tl3d.Vector3D.X_AXIS);
            camera3dMatrix.prependRotation(_Cam.rotationY, tl3d.Vector3D.Y_AXIS);
            camera3dMatrix.prependTranslation(-_Cam.x, -_Cam.y, -_Cam.z);
            _Cam.cameraMatrix.identity();
            _Cam.cameraMatrix.append(camera3dMatrix);
        };
        MathClass.GetViewHitBoxData = function ($far) {
            var cameraMatrixInvert = tl3d.Scene_data.cam3D.cameraMatrix.clone();
            cameraMatrixInvert.invert();
            var sx = tl3d.Scene_data.viewMatrx3D.m[0];
            var sy = tl3d.Scene_data.viewMatrx3D.m[5];
            if (this.viewBoxVecItem) {
                if (this.lastViewScale.x != sx || this.lastViewScale.y != sy) {
                    this.viewBoxVecItem[0] = (new tl3d.Vector3D(-$far / sx, -$far / sy, $far));
                    this.viewBoxVecItem[1] = (new tl3d.Vector3D(-$far / sx, +$far / sy, $far));
                    this.viewBoxVecItem[2] = (new tl3d.Vector3D(+$far / sx, -$far / sy, $far));
                    this.viewBoxVecItem[3] = (new tl3d.Vector3D(+$far / sx, +$far / sy, $far));
                    this.viewBoxVecItem[4] = (new tl3d.Vector3D(0, 0, 0));
                }
            }
            else {
                this.lastViewScale = new tl3d.Vector2D(sx, sy);
                this.viewBoxVecItem = new Array;
                this.viewBoxVecItem.push(new tl3d.Vector3D(-$far / sx, -$far / sy, $far));
                this.viewBoxVecItem.push(new tl3d.Vector3D(-$far / sx, +$far / sy, $far));
                this.viewBoxVecItem.push(new tl3d.Vector3D(+$far / sx, -$far / sy, $far));
                this.viewBoxVecItem.push(new tl3d.Vector3D(+$far / sx, +$far / sy, $far));
                this.viewBoxVecItem.push(new tl3d.Vector3D(0, 0, 0));
            }
        };
        MathClass.GetViewHitBoxDataCopy = function ($dis) {
            if (!this.viewBoxVecItem) {
                this.viewBoxVecItem = new Array;
                this.viewBoxVecItem.push(new tl3d.Vector3D());
                this.viewBoxVecItem.push(new tl3d.Vector3D());
                this.viewBoxVecItem.push(new tl3d.Vector3D());
                this.viewBoxVecItem.push(new tl3d.Vector3D());
            }
            var $disNum = $dis / (tl3d.Scene_data.sceneViewHW / 2);
            var $far = tl3d.Scene_data.sceneViewHW / 2 * $disNum;
            var fovw = tl3d.Scene_data.stageWidth;
            var fovh = tl3d.Scene_data.stageHeight;
            var m = new tl3d.Matrix3D;
            m.prependRotation(-tl3d.Scene_data.cam3D.rotationY, tl3d.Vector3D.Y_AXIS);
            m.prependRotation(-tl3d.Scene_data.cam3D.rotationX, tl3d.Vector3D.X_AXIS);
            var uc = tl3d.Scene_data.viewMatrx3D.transformVector(new tl3d.Vector3D(500, 0, 500));
            var zScale = uc.x / uc.w;
            var ss = 0.8;
            var fw = (fovw / 2 / zScale) * $disNum * ss;
            var fh = (fovh / 2 / zScale) * $disNum * ss;
            this.viewBoxVecItem[0] = this.gettempPos(new tl3d.Vector3D(-fw, -fh, $far), m);
            this.viewBoxVecItem[1] = this.gettempPos(new tl3d.Vector3D(+fw, -fh, $far), m);
            this.viewBoxVecItem[2] = this.gettempPos(new tl3d.Vector3D(+fw, +fh, $far), m);
            this.viewBoxVecItem[3] = this.gettempPos(new tl3d.Vector3D(-fw, +fh, $far), m);
        };
        MathClass.gettempPos = function (a, m) {
            var b = m.transformVector(a);
            b = b.add(new tl3d.Vector3D(tl3d.Scene_data.cam3D.x, tl3d.Scene_data.cam3D.y, tl3d.Scene_data.cam3D.z));
            return b;
        };
        MathClass.mathmidpoint = function (a, b, t) {
            var _nx, _ny, _nz;
            _nx = a.x + (b.x - a.x) * t;
            _ny = a.y + (b.y - a.y) * t;
            _nz = a.z + (b.z - a.z) * t;
            a.x = _nx;
            a.y = _ny;
            a.z = _nz;
        };
        MathClass.drawbezier = function (_array, _time) {
            var _newarray = new Array();
            if (_array.length == 0) {
                return { x: 0, y: 0, z: 0 };
            }
            for (var i = 0; i < _array.length; i++) {
                _newarray.push({ x: _array[i].x, y: _array[i].y, z: _array[i].z });
            }
            while (_newarray.length > 1) {
                for (var j = 0; j < _newarray.length - 1; j++) {
                    this.mathmidpoint(_newarray[j], _newarray[j + 1], _time);
                }
                _newarray.pop();
            }
            return _newarray[0];
        };
        MathClass.math_distance = function (x1, y1, x2, y2) {
            return Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));
        };
        MathClass.math_angle = function (x1, y1, x2, y2) {
            var d_x = x1 - x2;
            var d_y = y1 - y2;
            var z = Math.atan(d_y / d_x) * 180 / Math.PI;
            return z;
        };
        MathClass.easeIn = function (t, b, c, d) {
            return c * (t /= d) * t + b;
        };
        MathClass.easeOut = function (t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        };
        MathClass.easeInOut = function (t, b, c, d) {
            if ((t /= d / 2) < 1) {
                return c / 2 * t * t + b;
            }
            else {
                return -c / 2 * ((--t) * (t - 2) - 1) + b;
            }
        };
        /**
         * 2D坐标转换成3D坐标，当然要给一个相离镜头的深度
         * @param $stage3DVO 为stage3d的坐标信息
         * @param $point  2d位置是场景的坐标，
         * @param $depht  默认深度为500,
         * @return  3D的坐标
         *
         */
        MathClass.mathDisplay2Dto3DWorldPos = function ($stage3DVO, $point, $depht) {
            if ($depht === void 0) { $depht = 300; }
            var cameraMatrixInvert = tl3d.Scene_data.cam3D.cameraMatrix.clone();
            var viewMatrx3DInvert = tl3d.Scene_data.viewMatrx3D.clone();
            cameraMatrixInvert.invert();
            viewMatrx3DInvert.invert();
            var a = new tl3d.Vector3D();
            a.x = $point.x - $stage3DVO.x;
            a.y = $point.y - $stage3DVO.y;
            a.x = a.x * 2 / $stage3DVO.width - 1;
            a.y = 1 - a.y * 2 / $stage3DVO.height;
            a.w = $depht;
            a.x = a.x * a.w;
            a.y = a.y * a.w;
            a = viewMatrx3DInvert.transformVector(a);
            a.z = $depht;
            a = cameraMatrixInvert.transformVector(a);
            return a;
        };
        MathClass.SetShock = true;
        return MathClass;
    }());
    tl3d.MathClass = MathClass;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MathUtil = /** @class */ (function () {
        function MathUtil() {
        }
        /**
         * 2D坐标转换成3D坐标，当然要给一个相离镜头的深度
         * @param $point  2d位置是场景的坐标，
         * @param $depht  默认深度为500,
         * @return  3D的坐标
         *
         */
        MathUtil.mathDisplay2Dto3DWorldPos = function ($point, $depht) {
            if ($depht === void 0) { $depht = 300; }
            var $disNum = $depht / (tl3d.Scene_data.sceneViewHW / 2);
            var $far = tl3d.Scene_data.sceneViewHW / 2 * $disNum;
            var fovw = tl3d.Scene_data.stageWidth;
            var fovh = tl3d.Scene_data.stageHeight;
            var m = new tl3d.Matrix3D;
            m.prependRotation(-tl3d.Scene_data.cam3D.rotationY, tl3d.Vector3D.Y_AXIS);
            m.prependRotation(-tl3d.Scene_data.cam3D.rotationX, tl3d.Vector3D.X_AXIS);
            var uc = tl3d.Scene_data.viewMatrx3D.transformVector(new tl3d.Vector3D(500, 0, 500));
            var zScale = uc.x / uc.w;
            var fw = (fovw / 2 / zScale) * $disNum;
            var fh = (fovh / 2 / zScale) * $disNum;
            var tx = (($point.x / fovw) * fw) * 2;
            var ty = (($point.y / fovh) * fh) * 2;
            var p = this.gettempPos(new tl3d.Vector3D(-fw + tx, +fh - ty, $far), m);
            return p;
        };
        //计算出鼠标与地面Y为0的坐标点
        MathUtil.getGroundPanelPos = function ($evt) {
            var pos = tl3d.MathClass.mathDisplay2Dto3DWorldPos(new tl3d.Rectangle(0, 0, tl3d.Scene_data.stageWidth, tl3d.Scene_data.stageHeight), new tl3d.Vector2D($evt.x, $evt.y), 300);
            var triItem = new Array;
            triItem.push(new tl3d.Vector3D(0, 0, 0));
            triItem.push(new tl3d.Vector3D(-100, 0, 100));
            triItem.push(new tl3d.Vector3D(+100, 0, 100));
            var camPos = new tl3d.Vector3D(tl3d.Scene_data.cam3D.x, tl3d.Scene_data.cam3D.y, tl3d.Scene_data.cam3D.z);
            return this.getLinePlaneInterectPointByTri(camPos, pos, triItem);
        };
        MathUtil.gettempPos = function (a, m) {
            var b = m.transformVector(a);
            b = b.add(new tl3d.Vector3D(tl3d.Scene_data.cam3D.x, tl3d.Scene_data.cam3D.y, tl3d.Scene_data.cam3D.z));
            return b;
        };
        //3d坐标转换成场景像素坐标
        MathUtil.math3DWorldtoDisplay2DPos = function ($pos) {
            var m = tl3d.Scene_data.cam3D.cameraMatrix.clone();
            m.append(tl3d.Scene_data.viewMatrx3D.clone());
            var fovw = tl3d.Scene_data.stageWidth;
            var fovh = tl3d.Scene_data.stageHeight;
            var p = m.transformVector($pos);
            var b = new tl3d.Vector2D;
            b.x = ((p.x / p.w) + 1) * (fovw / 2);
            b.y = ((-p.y / p.w) + 1) * (fovh / 2);
            return b;
        };
        MathUtil.argbToHex = function (a, r, g, b) {
            // 转换颜色
            var color = a << 24 | r << 16 | g << 8 | b;
            return color;
        };
        MathUtil.hexToArgb = function (expColor) {
            var color = new tl3d.Vector3D();
            color.w = (expColor >> 24) & 0xFF;
            color.x = (expColor >> 16) & 0xFF;
            color.y = (expColor >> 8) & 0xFF;
            color.z = (expColor) & 0xFF;
            return color;
        };
        /**
     *
     * @param linePoint_a  线起点
     * @param linePoint_b  线结点
     * @param planePoint  构成面的三个点
     * @return 交点坐标
     *
     */
        MathUtil.getLinePlaneInterectPointByTri = function (linePoint_a, linePoint_b, planePoint) {
            if (planePoint.length < 3)
                return null;
            var nomal = new tl3d.Vector3D(0, 2000, 0);
            return this.getLineAndPlaneIntersectPoint(linePoint_a, linePoint_b, planePoint[0], nomal);
        };
        /**
         * 空间一条射线和平面的交点
         * @param linePoint_a  过直线的一点
         * @param linePoint_b  过直线另一点
         * @param planePoint   过平面一点
         * @param planeNormal  平面的法线
         * @return
         *
         */
        MathUtil.getLineAndPlaneIntersectPoint = function (linePoint_a, linePoint_b, planePoint, planeNormal) {
            var lineVector = new tl3d.Vector3D(linePoint_a.x - linePoint_b.x, linePoint_a.y - linePoint_b.y, linePoint_a.z - linePoint_b.z);
            lineVector.normalize();
            var pt = lineVector.x * planeNormal.x + lineVector.y * planeNormal.y + lineVector.z * planeNormal.z;
            var t = ((planePoint.x - linePoint_a.x) * planeNormal.x + (planePoint.y - linePoint_a.y) * planeNormal.y + (planePoint.z - linePoint_a.z) * planeNormal.z) / pt;
            var aPro1 = new tl3d.Vector3D;
            aPro1.setTo(linePoint_a.x + lineVector.x * t, linePoint_a.y + lineVector.y * t, linePoint_a.z + lineVector.z * t);
            return aPro1;
        };
        MathUtil.lookAt = function (eyePos, lookAt) {
            var matr = new tl3d.Matrix3D();
            matr.buildLookAtLH(eyePos, lookAt, tl3d.Vector3D.Y_AXIS);
            return matr;
        };
        /**
         *  功能:根据两个点返回角度
         *  参数:
         **/
        MathUtil.getTowPointsAngle2 = function (x1, y1, x2, y2) {
            var radian = Math.atan2(y2 - y1, x2 - x1);
            if (radian < 0)
                radian += Math.PI * 2;
            return (radian * 180 / Math.PI) | 0;
        };
        /**
         * 返回两点的夹角
         * @param $p0
         * @param $p1
         * @return
         */
        MathUtil.getTowPointsAngle = function ($p0, $p1) {
            var radian = Math.atan2($p1.y - $p0.y, $p1.x - $p0.x);
            if (radian < 0)
                radian += 2 * Math.PI;
            return radian * 180 / Math.PI;
        };
        /** 返回两个点的距离
         *  **/
        MathUtil.getDisSquare = function (x1, y1, x2, y2) {
            return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
        };
        return MathUtil;
    }());
    tl3d.MathUtil = MathUtil;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Matrix3D = /** @class */ (function () {
        function Matrix3D() {
            this.isIdentity = true;
            var mk = [
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ];
            this.m = new Float32Array(mk);
        }
        Matrix3D.prototype.clone = function ($target) {
            if ($target === void 0) { $target = null; }
            //var $target: Matrix3D = new Matrix3D;
            if (!$target) {
                $target = new Matrix3D;
            }
            $target.m[0] = this.m[0];
            $target.m[1] = this.m[1];
            $target.m[2] = this.m[2];
            $target.m[3] = this.m[3];
            $target.m[4] = this.m[4];
            $target.m[5] = this.m[5];
            $target.m[6] = this.m[6];
            $target.m[7] = this.m[7];
            $target.m[8] = this.m[8];
            $target.m[9] = this.m[9];
            $target.m[10] = this.m[10];
            $target.m[11] = this.m[11];
            $target.m[12] = this.m[12];
            $target.m[13] = this.m[13];
            $target.m[14] = this.m[14];
            $target.m[15] = this.m[15];
            return $target;
        };
        Object.defineProperty(Matrix3D.prototype, "position", {
            get: function () {
                return new tl3d.Vector3D(this.m[12], this.m[13], this.m[14], this.m[15]);
            },
            enumerable: true,
            configurable: true
        });
        Matrix3D.prototype.copyTo = function ($target) {
            $target.m[0] = this.m[0];
            $target.m[1] = this.m[1];
            $target.m[2] = this.m[2];
            $target.m[3] = this.m[3];
            $target.m[4] = this.m[4];
            $target.m[5] = this.m[5];
            $target.m[6] = this.m[6];
            $target.m[7] = this.m[7];
            $target.m[8] = this.m[8];
            $target.m[9] = this.m[9];
            $target.m[10] = this.m[10];
            $target.m[11] = this.m[11];
            $target.m[12] = this.m[12];
            $target.m[13] = this.m[13];
            $target.m[14] = this.m[14];
            $target.m[15] = this.m[15];
        };
        Matrix3D.prototype.identity = function () {
            this.m[0] = 1;
            this.m[1] = 0;
            this.m[2] = 0;
            this.m[3] = 0;
            this.m[4] = 0;
            this.m[5] = 1;
            this.m[6] = 0;
            this.m[7] = 0;
            this.m[8] = 0;
            this.m[9] = 0;
            this.m[10] = 1;
            this.m[11] = 0;
            this.m[12] = 0;
            this.m[13] = 0;
            this.m[14] = 0;
            this.m[15] = 1;
        };
        Matrix3D.prototype.invert = function () {
            var a = this.m;
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, 
            // Calculate the determinant
            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (!det) {
                return null;
            }
            det = 1.0 / det;
            this.m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            this.m[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            this.m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            this.m[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            this.m[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            this.m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            this.m[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            this.m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            this.m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            this.m[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            this.m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            this.m[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            this.m[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            this.m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            this.m[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            this.m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        };
        Matrix3D.prototype.invertToMatrix = function ($target) {
            var a = this.m;
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, 
            // Calculate the determinant
            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (!det) {
                return null;
            }
            det = 1.0 / det;
            $target.m[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            $target.m[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            $target.m[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            $target.m[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            $target.m[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            $target.m[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            $target.m[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            $target.m[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            $target.m[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            $target.m[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            $target.m[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            $target.m[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            $target.m[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            $target.m[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            $target.m[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            $target.m[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        };
        Matrix3D.prototype.appendTranslation = function (x, y, z) {
            Matrix3D.tempM.identity();
            Matrix3D.tempM.prependTranslation(x, y, z);
            this.append(Matrix3D.tempM);
        };
        Matrix3D.prototype.prependTranslation = function (x, y, z) {
            var out = this.m;
            out[12] = out[0] * x + out[4] * y + out[8] * z + out[12];
            out[13] = out[1] * x + out[5] * y + out[9] * z + out[13];
            out[14] = out[2] * x + out[6] * y + out[10] * z + out[14];
            out[15] = out[3] * x + out[7] * y + out[11] * z + out[15];
        };
        Matrix3D.prototype.transformVector = function ($p) {
            var out = new tl3d.Vector3D;
            out.x = this.m[0] * $p.x + this.m[4] * $p.y + this.m[8] * $p.z + this.m[12] * $p.w;
            out.y = this.m[1] * $p.x + this.m[5] * $p.y + this.m[9] * $p.z + this.m[13] * $p.w;
            out.z = this.m[2] * $p.x + this.m[6] * $p.y + this.m[10] * $p.z + this.m[14] * $p.w;
            out.w = this.m[3] * $p.x + this.m[7] * $p.y + this.m[11] * $p.z + this.m[15] * $p.w;
            return out;
        };
        Matrix3D.prototype.append = function ($matrx3d) {
            Matrix3D.tempM.m[0] = $matrx3d.m[0];
            Matrix3D.tempM.m[1] = $matrx3d.m[1];
            Matrix3D.tempM.m[2] = $matrx3d.m[2];
            Matrix3D.tempM.m[3] = $matrx3d.m[3];
            Matrix3D.tempM.m[4] = $matrx3d.m[4];
            Matrix3D.tempM.m[5] = $matrx3d.m[5];
            Matrix3D.tempM.m[6] = $matrx3d.m[6];
            Matrix3D.tempM.m[7] = $matrx3d.m[7];
            Matrix3D.tempM.m[8] = $matrx3d.m[8];
            Matrix3D.tempM.m[9] = $matrx3d.m[9];
            Matrix3D.tempM.m[10] = $matrx3d.m[10];
            Matrix3D.tempM.m[11] = $matrx3d.m[11];
            Matrix3D.tempM.m[12] = $matrx3d.m[12];
            Matrix3D.tempM.m[13] = $matrx3d.m[13];
            Matrix3D.tempM.m[14] = $matrx3d.m[14];
            Matrix3D.tempM.m[15] = $matrx3d.m[15];
            Matrix3D.tempM.prepend(this);
            this.m[0] = Matrix3D.tempM.m[0];
            this.m[1] = Matrix3D.tempM.m[1];
            this.m[2] = Matrix3D.tempM.m[2];
            this.m[3] = Matrix3D.tempM.m[3];
            this.m[4] = Matrix3D.tempM.m[4];
            this.m[5] = Matrix3D.tempM.m[5];
            this.m[6] = Matrix3D.tempM.m[6];
            this.m[7] = Matrix3D.tempM.m[7];
            this.m[8] = Matrix3D.tempM.m[8];
            this.m[9] = Matrix3D.tempM.m[9];
            this.m[10] = Matrix3D.tempM.m[10];
            this.m[11] = Matrix3D.tempM.m[11];
            this.m[12] = Matrix3D.tempM.m[12];
            this.m[13] = Matrix3D.tempM.m[13];
            this.m[14] = Matrix3D.tempM.m[14];
            this.m[15] = Matrix3D.tempM.m[15];
            /*
            var $mat: Matrix3D = $matrx3d.clone();
            $mat.prepend(this);
    
            this.m[0] = $mat.m[0];
            this.m[1] = $mat.m[1];
            this.m[2] = $mat.m[2];
            this.m[3] = $mat.m[3];
            this.m[4] = $mat.m[4];
            this.m[5] = $mat.m[5];
            this.m[6] = $mat.m[6];
            this.m[7] = $mat.m[7];
            this.m[8] = $mat.m[8];
            this.m[9] = $mat.m[9];
            this.m[10] = $mat.m[10];
            this.m[11] = $mat.m[11];
            this.m[12] = $mat.m[12];
            this.m[13] = $mat.m[13];
            this.m[14] = $mat.m[14];
            this.m[15] = $mat.m[15];
            */
        };
        Matrix3D.prototype.prepend = function ($matrx3d) {
            var b = $matrx3d.m;
            var out = this.m;
            var a = this.m;
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
            // Cache only the current line of the second matrix
            var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[4];
            b1 = b[5];
            b2 = b[6];
            b3 = b[7];
            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[8];
            b1 = b[9];
            b2 = b[10];
            b3 = b[11];
            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[12];
            b1 = b[13];
            b2 = b[14];
            b3 = b[15];
            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        };
        Matrix3D.prototype.appendRotation = function (rad, axis) {
            Matrix3D.tempM.identity();
            Matrix3D.tempM.prependRotation(rad, axis);
            this.append(Matrix3D.tempM);
        };
        Matrix3D.prototype.tomat3 = function () {
            var mk = Array.prototype.concat.apply([], arguments);
            mk = [
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
            ];
            var b = new Float32Array(mk);
            b[0] = this.m[0];
            b[1] = this.m[1];
            b[2] = this.m[2];
            b[3] = this.m[4];
            b[4] = this.m[5];
            b[5] = this.m[6];
            b[6] = this.m[8];
            b[7] = this.m[9];
            b[8] = this.m[10];
            return b;
        };
        Matrix3D.prototype.getRotaion = function (b) {
            b[0] = this.m[0];
            b[1] = this.m[1];
            b[2] = this.m[2];
            b[3] = this.m[4];
            b[4] = this.m[5];
            b[5] = this.m[6];
            b[6] = this.m[8];
            b[7] = this.m[9];
            b[8] = this.m[10];
        };
        Matrix3D.prototype.identityPostion = function () {
            this.m[12] = 0;
            this.m[13] = 0;
            this.m[14] = 0;
        };
        Object.defineProperty(Matrix3D.prototype, "x", {
            get: function () {
                return this.m[12];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3D.prototype, "y", {
            get: function () {
                return this.m[13];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Matrix3D.prototype, "z", {
            get: function () {
                return this.m[14];
            },
            enumerable: true,
            configurable: true
        });
        Matrix3D.prototype.prependRotation = function (rad, axis) {
            var out = this.m;
            var a = this.m;
            var x = axis.x, y = axis.y, z = axis.z, len = Math.sqrt(x * x + y * y + z * z), s, c, t, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, b00, b01, b02, b10, b11, b12, b20, b21, b22;
            if (Math.abs(len) < 0.000001) {
                return null;
            }
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
            s = Math.sin(rad * Math.PI / 180);
            c = Math.cos(rad * Math.PI / 180);
            t = 1 - c;
            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            // Construct the elements of the rotation matrix
            b00 = x * x * t + c;
            b01 = y * x * t + z * s;
            b02 = z * x * t - y * s;
            b10 = x * y * t - z * s;
            b11 = y * y * t + c;
            b12 = z * y * t + x * s;
            b20 = x * z * t + y * s;
            b21 = y * z * t - x * s;
            b22 = z * z * t + c;
            // Perform rotation-specific matrix multiplication
            out[0] = a00 * b00 + a10 * b01 + a20 * b02;
            out[1] = a01 * b00 + a11 * b01 + a21 * b02;
            out[2] = a02 * b00 + a12 * b01 + a22 * b02;
            out[3] = a03 * b00 + a13 * b01 + a23 * b02;
            out[4] = a00 * b10 + a10 * b11 + a20 * b12;
            out[5] = a01 * b10 + a11 * b11 + a21 * b12;
            out[6] = a02 * b10 + a12 * b11 + a22 * b12;
            out[7] = a03 * b10 + a13 * b11 + a23 * b12;
            out[8] = a00 * b20 + a10 * b21 + a20 * b22;
            out[9] = a01 * b20 + a11 * b21 + a21 * b22;
            out[10] = a02 * b20 + a12 * b21 + a22 * b22;
            out[11] = a03 * b20 + a13 * b21 + a23 * b22;
            if (a !== out) { // If the source and destination differ, copy the unchanged last row
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }
            return out;
        };
        Matrix3D.prototype.prependScale = function (x, y, z) {
            var a = this.m;
            var out = this.m;
            out[0] = a[0] * x;
            out[1] = a[1] * x;
            out[2] = a[2] * x;
            out[3] = a[3] * x;
            out[4] = a[4] * y;
            out[5] = a[5] * y;
            out[6] = a[6] * y;
            out[7] = a[7] * y;
            out[8] = a[8] * z;
            out[9] = a[9] * z;
            out[10] = a[10] * z;
            out[11] = a[11] * z;
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        };
        ;
        Matrix3D.prototype.appendScale = function (x, y, z) {
            Matrix3D.tempM.identity();
            Matrix3D.tempM.prependScale(x, y, z);
            this.append(Matrix3D.tempM);
        };
        Matrix3D.prototype.perspectiveFieldOfViewLH = function (fieldOfViewY, aspectRatio, zNear, zFar) {
            var yScale = 1.0 / Math.tan(fieldOfViewY / 2.0);
            var xScale = yScale / aspectRatio;
            var out = this.m;
            out[0] = xScale;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = yScale;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = zFar / (zFar - zNear);
            out[11] = 1;
            out[12] = 0;
            out[13] = 0;
            out[14] = (zNear * zFar) / (zNear - zFar);
            out[15] = 0;
            /*
              public function perspectiveFieldOfViewLH(fieldOfViewY:Number,
                                                     aspectRatio:Number,
                                                     zNear:Number,
                                                     zFar:Number):void {
                var yScale:Number = 1.0/Math.tan(fieldOfViewY/2.0);
                var xScale:Number = yScale / aspectRatio;
                this.copyRawDataFrom(Vector.<Number>([
                    xScale, 0.0, 0.0, 0.0,
                    0.0, yScale, 0.0, 0.0,
                    0.0, 0.0, zFar/(zFar-zNear), 1.0,
                    0.0, 0.0, (zNear*zFar)/(zNear-zFar), 0.0
                ]));
            }
    
            */
        };
        Matrix3D.prototype.fromVtoV = function ($basePos, $newPos) {
            var axis = $basePos.cross($newPos);
            axis.normalize();
            var angle = Math.acos($basePos.dot($newPos));
            var q = new tl3d.Quaternion();
            q.fromAxisAngle(axis, angle);
            q.toMatrix3D(this);
        };
        Matrix3D.prototype.buildLookAtLH = function (eyePos, lookAt, up) {
            var out = this.m;
            var zaxis = new tl3d.Vector3D;
            zaxis.x = lookAt.x - eyePos.x;
            zaxis.y = lookAt.y - eyePos.y;
            zaxis.z = lookAt.z - eyePos.z;
            zaxis.normalize();
            var xaxis = up.cross(zaxis);
            xaxis.normalize();
            var yaxis = zaxis.cross(xaxis);
            out[0] = xaxis.x;
            out[1] = yaxis.x;
            out[2] = zaxis.x;
            out[3] = 0.0;
            out[4] = xaxis.y;
            out[5] = yaxis.y;
            out[6] = zaxis.y;
            out[7] = 0.0;
            out[8] = xaxis.z;
            out[9] = yaxis.z;
            out[10] = zaxis.z;
            out[11] = 0.0;
            out[12] = -xaxis.dot(eyePos);
            out[13] = -yaxis.dot(eyePos);
            out[14] = -zaxis.dot(eyePos);
            out[15] = 1.0;
        };
        Matrix3D.mul = function (a, b, c) {
            var d = b[0], e = b[1], f = b[2], g = b[3], h = b[4], k = b[5], l = b[6], m = b[7], n = b[8], r = b[9], p = b[10], q = b[11], u = b[12], s = b[13], z = b[14];
            b = b[15];
            var t = c[0], v = c[1], w = c[2], x = c[3];
            a[0] = t * d + v * h + w * n + x * u;
            a[1] = t * e + v * k + w * r + x * s;
            a[2] = t * f + v * l + w * p + x * z;
            a[3] = t * g + v * m + w * q + x * b;
            t = c[4];
            v = c[5];
            w = c[6];
            x = c[7];
            a[4] = t * d + v * h + w * n + x * u;
            a[5] = t * e + v * k + w * r + x * s;
            a[6] = t * f + v * l + w * p + x * z;
            a[7] = t * g + v * m + w * q + x * b;
            t = c[8];
            v = c[9];
            w = c[10];
            x = c[11];
            a[8] = t * d + v * h + w * n + x * u;
            a[9] = t * e + v * k + w * r + x * s;
            a[10] = t * f + v * l + w * p + x * z;
            a[11] =
                t * g + v * m + w * q + x * b;
            t = c[12];
            v = c[13];
            w = c[14];
            x = c[15];
            a[12] = t * d + v * h + w * n + x * u;
            a[13] = t * e + v * k + w * r + x * s;
            a[14] = t * f + v * l + w * p + x * z;
            a[15] = t * g + v * m + w * q + x * b;
            return a;
        };
        Matrix3D.prototype.toEulerAngles = function (target) {
            if (target === void 0) { target = null; }
            var $q = new tl3d.Quaternion();
            $q.fromMatrix(this);
            return $q.toEulerAngles(target);
        };
        Matrix3D.tempM = new Matrix3D();
        return Matrix3D;
    }());
    tl3d.Matrix3D = Matrix3D;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Quaternion = /** @class */ (function () {
        function Quaternion($x, $y, $z, $w) {
            if ($x === void 0) { $x = 0; }
            if ($y === void 0) { $y = 0; }
            if ($z === void 0) { $z = 0; }
            if ($w === void 0) { $w = 1; }
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
            this.x = $x;
            this.y = $y;
            this.z = $z;
            this.w = $w;
        }
        Quaternion.prototype.print = function () {
            alert(String(this.x) + " " + String(this.y) + " " + String(this.z) + " " + String(this.w));
        };
        Quaternion.prototype.toEulerAngles = function (target) {
            if (target === void 0) { target = null; }
            if (!target) {
                target = new tl3d.Vector3D;
            }
            var x = this.x, y = this.y, z = this.z, w = this.w;
            target.x = Math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y));
            target.y = Math.asin(2 * (w * y - z * x));
            target.z = Math.atan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z));
            return target;
        };
        Quaternion.prototype.toMatrix3D = function ($matrix3d) {
            if ($matrix3d === void 0) { $matrix3d = null; }
            if (!$matrix3d) {
                $matrix3d = new tl3d.Matrix3D;
            }
            var out = $matrix3d.m;
            var x = this.x, y = this.y, z = this.z, w = this.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, yx = y * x2, yy = y * y2, zx = z * x2, zy = z * y2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            out[0] = 1 - yy - zz;
            out[1] = yx + wz;
            out[2] = zx - wy;
            out[3] = 0;
            out[4] = yx - wz;
            out[5] = 1 - xx - zz;
            out[6] = zy + wx;
            out[7] = 0;
            out[8] = zx + wy;
            out[9] = zy - wx;
            out[10] = 1 - xx - yy;
            out[11] = 0;
            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;
            return $matrix3d;
        };
        Quaternion.prototype.fromAxisAngle = function (axis, angle) {
            var sin_a = Math.sin(angle / 2);
            var cos_a = Math.cos(angle / 2);
            this.x = axis.x * sin_a;
            this.y = axis.y * sin_a;
            this.z = axis.z * sin_a;
            this.w = cos_a;
            this.normalize();
        };
        Quaternion.prototype.normalize = function (val) {
            if (val === void 0) { val = 1; }
            var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            this.x *= mag;
            this.y *= mag;
            this.z *= mag;
            this.w *= mag;
        };
        Quaternion.prototype.fromMatrix = function ($matrix) {
            var m = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            m[0] = $matrix.m[0];
            m[1] = $matrix.m[1];
            m[2] = $matrix.m[2];
            m[3] = $matrix.m[4];
            m[4] = $matrix.m[5];
            m[5] = $matrix.m[6];
            m[6] = $matrix.m[8];
            m[7] = $matrix.m[9];
            m[8] = $matrix.m[10];
            var fTrace = m[0] + m[4] + m[8];
            var fRoot;
            var out = [0, 0, 0, 0];
            if (fTrace > 0.0) {
                // |w| > 1/2, may as well choose w > 1/2
                fRoot = Math.sqrt(fTrace + 1.0); // 2w
                out[3] = 0.5 * fRoot;
                fRoot = 0.5 / fRoot; // 1/(4w)
                out[0] = (m[5] - m[7]) * fRoot;
                out[1] = (m[6] - m[2]) * fRoot;
                out[2] = (m[1] - m[3]) * fRoot;
            }
            else {
                // |w| <= 1/2
                var i = 0;
                if (m[4] > m[0])
                    i = 1;
                if (m[8] > m[i * 3 + i])
                    i = 2;
                var j = (i + 1) % 3;
                var k = (i + 2) % 3;
                fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
                out[i] = 0.5 * fRoot;
                fRoot = 0.5 / fRoot;
                out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
                out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
                out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
            }
            this.x = out[0];
            this.y = out[1];
            this.z = out[2];
            this.w = out[3];
        };
        Quaternion.prototype.setMd5W = function () {
            this.w = 1 - (this.x * this.x + this.y * this.y + this.z * this.z);
            if (this.w < 0) {
                this.w = 0;
            }
            else {
                this.w = -Math.sqrt(this.w);
            }
        };
        Quaternion.prototype.slerp = function (qa, qb, t) {
            var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
            var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
            var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
            // shortest direction
            if (dot < 0) {
                dot = -dot;
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            if (dot < 0.95) {
                // interpolate angle linearly
                var angle = Math.acos(dot);
                var s = 1 / Math.sin(angle);
                var s1 = Math.sin(angle * (1 - t)) * s;
                var s2 = Math.sin(angle * t) * s;
                this.w = w1 * s1 + w2 * s2;
                this.x = x1 * s1 + x2 * s2;
                this.y = y1 * s1 + y2 * s2;
                this.z = z1 * s1 + z2 * s2;
            }
            else {
                // nearly identical angle, interpolate linearly
                this.w = w1 + t * (w2 - w1);
                this.x = x1 + t * (x2 - x1);
                this.y = y1 + t * (y2 - y1);
                this.z = z1 + t * (z2 - z1);
                var len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
                this.w *= len;
                this.x *= len;
                this.y *= len;
                this.z *= len;
            }
        };
        return Quaternion;
    }());
    tl3d.Quaternion = Quaternion;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Rectangle = /** @class */ (function () {
        function Rectangle($x, $y, $width, $height) {
            if ($x === void 0) { $x = 0; }
            if ($y === void 0) { $y = 0; }
            if ($width === void 0) { $width = 1; }
            if ($height === void 0) { $height = 1; }
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 1;
            this.x = $x;
            this.y = $y;
            this.width = $width;
            this.height = $height;
        }
        Rectangle.prototype.sets = function ($x, $y, $width, $height) {
            this.x = $x;
            this.y = $y;
            this.width = $width;
            this.height = $height;
        };
        Rectangle.prototype.setRec = function ($rec) {
            this.x = $rec.x;
            this.y = $rec.y;
            this.width = $rec.width;
            this.height = $rec.height;
        };
        Rectangle.prototype.isHitByPoint = function (tx, ty) {
            return (tx >= this.x && ty >= this.y && tx <= this.x + this.width && ty <= this.y + this.height);
        };
        return Rectangle;
    }());
    tl3d.Rectangle = Rectangle;
})(tl3d || (tl3d = {}));
/**
 * Endian 类中包含一些值，它们表示用于表示多字节数字的字节顺序。
 * 字节顺序为 bigEndian（最高有效字节位于最前）或 littleEndian（最低有效字节位于最前）。
 * @class egret.Endian
 * @classdesc
 */

(function (tl3d) {
    var Endian = /** @class */ (function () {
        function Endian() {
        }
        /**
         * 表示多字节数字的最低有效字节位于字节序列的最前面。
         * 十六进制数字 0x12345678 包含 4 个字节（每个字节包含 2 个十六进制数字）。最高有效字节为 0x12。最低有效字节为 0x78。（对于等效的十进制数字 305419896，最高有效数字是 3，最低有效数字是 6）。
         * @constant {string} egret.Endian.LITTLE_ENDIAN
         */
        Endian.LITTLE_ENDIAN = "littleEndian";
        /**
         * 表示多字节数字的最高有效字节位于字节序列的最前面。
         * 十六进制数字 0x12345678 包含 4 个字节（每个字节包含 2 个十六进制数字）。最高有效字节为 0x12。最低有效字节为 0x78。（对于等效的十进制数字 305419896，最高有效数字是 3，最低有效数字是 6）。
         * @constant {string} egret.Endian.BIG_ENDIAN
         */
        Endian.BIG_ENDIAN = "bigEndian";
        return Endian;
    }());
    tl3d.Endian = Endian;
    /**
     * @class ByteArray
     * @classdesc
     * ByteArray 类提供用于优化读取、写入以及处理二进制数据的方法和属性。
     * 注意：ByteArray 类适用于需要在字节层访问数据的高级 开发人员。
     */
    var TLByteArray = /** @class */ (function () {
        /**
         * 创建一个 ByteArray 对象以引用指定的 ArrayBuffer 对象
         * @param buffer {ArrayBuffer} 数据源
         */
        function TLByteArray(buffer) {
            this.BUFFER_EXT_SIZE = 0; //Buffer expansion size
            this.optcode = 0;
            this.EOF_byte = -1;
            this.EOF_code_point = -1;
            this._setArrayBuffer(buffer || new ArrayBuffer(this.BUFFER_EXT_SIZE));
            this.endian = Endian.BIG_ENDIAN;
        }
        TLByteArray.prototype._setArrayBuffer = function (buffer) {
            this.write_position = buffer.byteLength;
            this.data = new DataView(buffer);
            this._position = 0;
        };
        TLByteArray.prototype.setdata = function (srcByte) {
            this._setArrayBuffer(srcByte.buffer);
        };
        Object.defineProperty(TLByteArray.prototype, "buffer", {
            get: function () {
                return this.data.buffer;
            },
            /**
             * @private
             */
            set: function (value) {
                this.data = new DataView(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TLByteArray.prototype, "dataView", {
            get: function () {
                return this.data;
            },
            /**
             * @private
             */
            set: function (value) {
                this.data = value;
                this.write_position = value.byteLength;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TLByteArray.prototype, "bufferOffset", {
            /**
             * @private
             */
            get: function () {
                return this.data.byteOffset;
            },
            enumerable: true,
            configurable: true
        });
        TLByteArray.prototype.getByte = function (i) {
            return this.data.getUint8(i);
        };
        TLByteArray.prototype.setByte = function (i, num) {
            this.data.setUint8(i, num);
        };
        Object.defineProperty(TLByteArray.prototype, "position", {
            /**
             * 将文件指针的当前位置（以字节为单位）移动或返回到 ByteArray 对象中。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
             * @member {number} ByteArray#position
             */
            get: function () {
                return this._position;
            },
            set: function (value) {
                //if (this._position < value) {
                //    if (!this.validate(value - this._position)) {
                //        return;
                //    }
                //}
                this._position = value;
                this.write_position = value > this.write_position ? value : this.write_position;
            },
            enumerable: true,
            configurable: true
        });
        TLByteArray.prototype.reset = function () {
            this.clear();
        };
        Object.defineProperty(TLByteArray.prototype, "length", {
            /**
             * ByteArray 对象的长度（以字节为单位）。
             * 如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧。
             * 如果将长度设置为小于当前长度的值，将会截断该字节数组。
             * @member {number} ByteArray#length
             */
            get: function () {
                return this.write_position;
            },
            set: function (value) {
                this.validateBuffer(value, true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TLByteArray.prototype, "bytesAvailable", {
            /**
             * 可从字节数组的当前位置到数组末尾读取的数据的字节数。
             * 每次访问 ByteArray 对象时，将 bytesAvailable 属性与读取方法结合使用，以确保读取有效的数据。
             * @member {number} ByteArray#bytesAvailable
             */
            get: function () {
                return this.data.byteLength - this._position;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 清除字节数组的内容，并将 length 和 position 属性重置为 0。
         * @method ByteArray#clear
         */
        TLByteArray.prototype.clear = function () {
            this._setArrayBuffer(new ArrayBuffer(this.BUFFER_EXT_SIZE));
        };
        //public getArray():Uint8Array {
        //    if (this.array == null) {
        //        this.array = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
        //    }
        //    return this.array;
        //}
        /**
         * 从字节流中读取布尔值。读取单个字节，如果字节非零，则返回 true，否则返回 false
         * @return 如果字节不为零，则返回 true，否则返回 false
         * @method ByteArray#readBoolean
         */
        TLByteArray.prototype.readBoolean = function () {
            //if (!this.validate(ByteArray.SIZE_OF_BOOLEAN)) return null;
            return this.data.getUint8(this.position++) != 0;
        };
        /**
         * 从字节流中读取带符号的字节
         * @return 介于 -128 和 127 之间的整数
         * @method ByteArray#readByte
         */
        TLByteArray.prototype.readByte = function () {
            //if (!this.validate(ByteArray.SIZE_OF_INT8)) return null;
            return this.data.getInt8(this.position++);
        };
        /**
         * 从字节流中读取 length 参数指定的数据字节数。从 offset 指定的位置开始，将字节读入 bytes 参数指定的 ByteArray 对象中，并将字节写入目标 ByteArray 中
         * @param bytes 要将数据读入的 ByteArray 对象
         * @param offset bytes 中的偏移（位置），应从该位置写入读取的数据
         * @param length 要读取的字节数。默认值 0 导致读取所有可用的数据
         * @method ByteArray#readBytes
         */
        TLByteArray.prototype.readBytes = function (bytes, offset, length) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = 0; }
            //if (length == 0) {
            //    length = this.bytesAvailable;
            //}
            //else if (!this.validate(length)) {
            //    return null;
            //}
            //if (bytes) {
            //    bytes.validateBuffer(length);
            //}
            //else {
            //    bytes = new ByteArray(new ArrayBuffer(length));
            //}
            //This method is expensive
            for (var i = 0; i < length; i++) {
                bytes.data.setUint8(i + offset, this.data.getUint8(this.position++));
            }
        };
        //public get leftBytes():ArrayBuffer {
        //    var begin = this.data.byteOffset + this.position;
        //    var end = this.data.byteLength;
        //    var result = new ArrayBuffer(end - begin);
        //    var resultBytes = new Uint8Array(result);
        //    var sourceBytes = new Uint8Array(this.data.buffer, begin, end - begin);
        //    resultBytes.set(sourceBytes);
        //    return resultBytes.buffer;
        //}
        /**
         * 从字节流中读取一个 IEEE 754 双精度（64 位）浮点数
         * @return 双精度（64 位）浮点数
         * @method ByteArray#readDouble
         */
        TLByteArray.prototype.readDouble = function () {
            //if (!this.validate(ByteArray.SIZE_OF_FLOAT64)) return null;
            var value = this.data.getFloat64(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_FLOAT64;
            return value;
        };
        /**
         * 从字节流中读取一个 IEEE 754 单精度（32 位）浮点数
         * @return 单精度（32 位）浮点数
         * @method ByteArray#readFloat
         */
        TLByteArray.prototype.readFloat = function () {
            //if (!this.validate(ByteArray.SIZE_OF_FLOAT32)) return null;
            var value = this.data.getFloat32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_FLOAT32;
            return value;
        };
        /**
         * 从字节流中读取一个带符号的 32 位整数
         * @return 介于 -2147483648 和 2147483647 之间的 32 位带符号整数
         * @method ByteArray#readFloat
         */
        TLByteArray.prototype.readInt = function () {
            //if (!this.validate(ByteArray.SIZE_OF_INT32)) return null;
            var value = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_INT32;
            return value;
        };
        TLByteArray.prototype.getInt = function () {
            var value = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            return value;
        };
        TLByteArray.prototype.readInt32 = function () {
            return this.readInt();
        };
        //        public readInt64():Int64{
        //            if (!this.validate(ByteArray.SIZE_OF_UINT32)) return null;
        //
        //            var low = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_INT32;
        //            var high = this.data.getInt32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_INT32;
        //            return new Int64(low,high);
        //        }
        /**
         * 使用指定的字符集从字节流中读取指定长度的多字节字符串
         * @param length 要从字节流中读取的字节数
         * @param charSet 表示用于解释字节的字符集的字符串。可能的字符集字符串包括 "shift-jis"、"cn-gb"、"iso-8859-1"”等
         * @return UTF-8 编码的字符串
         * @method ByteArray#readMultiByte
         */
        //public readMultiByte(length:number, charSet?:string):string {
        //    if (!this.validate(length)) return null;
        //
        //    return "";
        //}
        /**
         * 从字节流中读取一个带符号的 16 位整数
         * @return 介于 -32768 和 32767 之间的 16 位带符号整数
         * @method ByteArray#readShort
         */
        TLByteArray.prototype.readShort = function () {
            //if (!this.validate(ByteArray.SIZE_OF_INT16)) return null;
            if (this.position >= this.data.byteLength) {
                //console.log("readShort")
            }
            var value = this.data.getInt16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_INT16;
            return value;
        };
        //自己添加的读无符号短整行2个字节 Pan
        TLByteArray.prototype.readFloatTwoByte = function ($scaleNum) {
            return this.readShort() / $scaleNum;
            // return (this.readByte() * 127 + this.readByte()) / $scaleNum
        };
        //自己添加的读无符号短整行1个字节 lyf
        TLByteArray.prototype.readFloatOneByte = function () {
            return (this.readByte() + 128) / 256;
        };
        /**
         * 从字节流中读取无符号的字节
         * @return 介于 0 和 255 之间的 32 位无符号整数
         * @method ByteArray#readUnsignedByte
         */
        TLByteArray.prototype.readUnsignedByte = function () {
            //if (!this.validate(ByteArray.SIZE_OF_UINT8)) return null;
            return this.data.getUint8(this.position++);
        };
        TLByteArray.prototype.readUint8 = function () {
            return this.readUnsignedByte();
        };
        TLByteArray.prototype.readInt8 = function () {
            return this.readByte();
        };
        /**
         * 从字节流中读取一个无符号的 32 位整数
         * @return 介于 0 和 4294967295 之间的 32 位无符号整数
         * @method ByteArray#readUnsignedInt
         */
        TLByteArray.prototype.readUnsignedInt = function () {
            //if (!this.validate(ByteArray.SIZE_OF_UINT32)) return null;
            var value = this.data.getUint32(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_UINT32;
            return value;
        };
        TLByteArray.prototype.readUint32 = function () {
            return this.readUnsignedInt();
        };
        TLByteArray.prototype.readUint64 = function () {
            return this.readDouble();
        };
        //public readVariableSizedUnsignedInt():number {
        //    var i:number;
        //    var c:number = this.data.getUint8(this.position++);
        //    if (c != 0xFF) {
        //        i = c << 8;
        //        c = this.data.getUint8(this.position++);
        //        i |= c;
        //    }
        //    else {
        //        c = this.data.getUint8(this.position++);
        //        i = c << 16;
        //        c = this.data.getUint8(this.position++);
        //        i |= c << 8;
        //        c = this.data.getUint8(this.position++);
        //        i |= c;
        //    }
        //    return i;
        //}
        //		public readUnsignedInt64():UInt64{
        //            if (!this.validate(ByteArray.SIZE_OF_UINT32)) return null;
        //
        //            var low = this.data.getUint32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_UINT32;
        //            var high = this.data.getUint32(this.position, this.endian == Endian.LITTLE_ENDIAN);
        //            this.position += ByteArray.SIZE_OF_UINT32;
        //			return new UInt64(low,high);
        //        }
        /**
         * 从字节流中读取一个无符号的 16 位整数
         * @return 介于 0 和 65535 之间的 16 位无符号整数
         * @method ByteArray#readUnsignedShort
         */
        TLByteArray.prototype.readUnsignedShort = function () {
            //if (!this.validate(ByteArray.SIZE_OF_UINT16)) return null;
            var value = this.data.getUint16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_UINT16;
            return value;
        };
        TLByteArray.prototype.readUint16 = function () {
            return this.readUnsignedShort();
        };
        /**
         * 从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是无符号的短整型（以字节表示长度）
         * @return UTF-8 编码的字符串
         * @method ByteArray#readUTF
         */
        TLByteArray.prototype.readUTF = function () {
            //if (!this.validate(ByteArray.SIZE_OF_UINT16)) return null;
            var length = this.data.getUint16(this.position, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_UINT16;
            if (length > 0) {
                return this.readUTFBytes(length);
            }
            else {
                return "";
            }
        };
        TLByteArray.prototype.readString = function () {
            return this.readUTF();
        };
        /**
         * 从字节流中读取一个由 length 参数指定的 UTF-8 字节序列，并返回一个字符串
         * @param length 指明 UTF-8 字节长度的无符号短整型数
         * @return 由指定长度的 UTF-8 字节组成的字符串
         * @method ByteArray#readUTFBytes
         */
        TLByteArray.prototype.readUTFBytes = function (length) {
            //if (!this.validate(length)) return null;
            var bytes = new Uint8Array(this.buffer, this.bufferOffset + this.position, length);
            this.position += length;
            /*var bytes: Uint8Array = new Uint8Array(new ArrayBuffer(length));
             for (var i = 0; i < length; i++) {
             bytes[i] = this.data.getUint8(this.position++);
             }*/
            return this.decodeUTF8(bytes);
        };
        TLByteArray.prototype.readStringByLen = function (len) {
            return this.readUTFBytes(len);
        };
        //public readStandardString(length:number):string {
        //    if (!this.validate(length)) return null;
        //
        //    var str:string = "";
        //
        //    for (var i = 0; i < length; i++) {
        //        str += String.fromCharCode(this.data.getUint8(this.position++));
        //    }
        //    return str;
        //}
        //public readStringTillNull(keepEvenByte:boolean = true):string {
        //
        //    var str:string = "";
        //    var num:number = 0;
        //    while (this.bytesAvailable > 0) {
        //        var b:number = this.data.getUint8(this.position++);
        //        num++;
        //        if (b != 0) {
        //            str += String.fromCharCode(b);
        //        } else {
        //            if (keepEvenByte && num % 2 != 0) {
        //                this.position++;
        //            }
        //            break;
        //        }
        //    }
        //    return str;
        //}
        /**
         * 写入布尔值。根据 value 参数写入单个字节。如果为 true，则写入 1，如果为 false，则写入 0
         * @param value 确定写入哪个字节的布尔值。如果该参数为 true，则该方法写入 1；如果该参数为 false，则该方法写入 0
         * @method ByteArray#writeBoolean
         */
        TLByteArray.prototype.writeBoolean = function (value) {
            this.validateBuffer(TLByteArray.SIZE_OF_BOOLEAN);
            this.data.setUint8(this.position++, value ? 1 : 0);
        };
        /**
         * 在字节流中写入一个字节
         * 使用参数的低 8 位。忽略高 24 位
         * @param value 一个 32 位整数。低 8 位将被写入字节流
         * @method ByteArray#writeByte
         */
        TLByteArray.prototype.writeByte = function (value) {
            this.validateBuffer(TLByteArray.SIZE_OF_INT8);
            this.data.setInt8(this.position++, value);
        };
        TLByteArray.prototype.writeUint8 = function (value) {
            this.writeByte(value);
        };
        TLByteArray.prototype.writeInt8 = function (value) {
            this.writeByte(value);
        };
        //public writeUnsignedByte(value:number):void {
        //    this.validateBuffer(ByteArray.SIZE_OF_UINT8);
        //
        //    this.data.setUint8(this.position++, value);
        //}
        /**
         * 将指定字节数组 bytes（起始偏移量为 offset，从零开始的索引）中包含 length 个字节的字节序列写入字节流
         * 如果省略 length 参数，则使用默认长度 0；该方法将从 offset 开始写入整个缓冲区。如果还省略了 offset 参数，则写入整个缓冲区
         * 如果 offset 或 length 超出范围，它们将被锁定到 bytes 数组的开头和结尾
         * @param bytes ByteArray 对象
         * @param offset 从 0 开始的索引，表示在数组中开始写入的位置
         * @param length 一个无符号整数，表示在缓冲区中的写入范围
         * @method ByteArray#writeBytes
         */
        TLByteArray.prototype.writeBytes = function (bytes, offset, length) {
            if (offset === void 0) { offset = 0; }
            if (length === void 0) { length = 0; }
            var writeLength;
            if (offset < 0) {
                return;
            }
            if (length < 0) {
                return;
            }
            else if (length == 0) {
                writeLength = bytes.length - offset;
            }
            else {
                writeLength = Math.min(bytes.length - offset, length);
            }
            if (writeLength > 0) {
                this.validateBuffer(writeLength);
                var tmp_data = new DataView(bytes.buffer);
                for (var i = offset; i < writeLength + offset; i++) {
                    this.data.setUint8(this.position++, tmp_data.getUint8(i));
                }
            }
        };
        /**
         * 在字节流中写入一个 IEEE 754 双精度（64 位）浮点数
         * @param value 双精度（64 位）浮点数
         * @method ByteArray#writeDouble
         */
        TLByteArray.prototype.writeDouble = function (value) {
            this.validateBuffer(TLByteArray.SIZE_OF_FLOAT64);
            this.data.setFloat64(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_FLOAT64;
        };
        /**
         * 在字节流中写入一个 IEEE 754 单精度（32 位）浮点数
         * @param value 单精度（32 位）浮点数
         * @method ByteArray#writeFloat
         */
        TLByteArray.prototype.writeFloat = function (value) {
            this.validateBuffer(TLByteArray.SIZE_OF_FLOAT32);
            this.data.setFloat32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_FLOAT32;
        };
        /**
         * 在字节流中写入一个带符号的 32 位整数
         * @param value 要写入字节流的整数
         * @method ByteArray#writeInt
         */
        TLByteArray.prototype.writeInt = function (value) {
            this.validateBuffer(TLByteArray.SIZE_OF_INT32);
            this.data.setInt32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_INT32;
        };
        TLByteArray.prototype.writeInt32 = function (value) {
            this.writeInt(value);
        };
        /**
         * 使用指定的字符集将多字节字符串写入字节流
         * @param value 要写入的字符串值
         * @param charSet 表示要使用的字符集的字符串。可能的字符集字符串包括 "shift-jis"、"cn-gb"、"iso-8859-1"”等
         * @method ByteArray#writeMultiByte
         */
        //public writeMultiByte(value:string, charSet:string):void {
        //
        //}
        /**
         * 在字节流中写入一个 16 位整数。使用参数的低 16 位。忽略高 16 位
         * @param value 32 位整数，该整数的低 16 位将被写入字节流
         * @method ByteArray#writeShort
         */
        TLByteArray.prototype.writeUnsignedShort = function (value) {
            this.validateBuffer(TLByteArray.SIZE_OF_INT16);
            this.data.setInt16(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_INT16;
        };
        TLByteArray.prototype.writeUint16 = function (value) {
            this.writeUnsignedShort(value);
        };
        TLByteArray.prototype.writeUint64 = function (value) {
            this.validateBuffer(TLByteArray.SIZE_OF_FLOAT64);
            this.data.setFloat64(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_FLOAT64;
        };
        TLByteArray.prototype.writeShort = function (value) {
            this.validateBuffer(TLByteArray.SIZE_OF_INT16);
            this.data.setUint16(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_INT16;
        };
        //public writeUnsignedShort(value:number):void {
        //    this.validateBuffer(ByteArray.SIZE_OF_UINT16);
        //
        //    this.data.setUint16(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
        //    this.position += ByteArray.SIZE_OF_UINT16;
        //}
        /**
         * 在字节流中写入一个无符号的 32 位整数
         * @param value 要写入字节流的无符号整数
         * @method ByteArray#writeUnsignedInt
         */
        TLByteArray.prototype.writeUnsignedInt = function (value) {
            this.validateBuffer(TLByteArray.SIZE_OF_UINT32);
            this.data.setUint32(this.position, value, this.endian == Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_UINT32;
        };
        TLByteArray.prototype.writeUint32 = function (value) {
            this.writeUnsignedInt(value);
        };
        /**
         * 将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节
         * @param value 要写入的字符串值
         * @method ByteArray#writeUTF
         */
        TLByteArray.prototype.writeUTF = function (value) {
            var utf8bytes = this.encodeUTF8(value);
            var length = utf8bytes.length;
            this.validateBuffer(TLByteArray.SIZE_OF_UINT16 + length);
            this.data.setUint16(this.position, length, this.endian === Endian.LITTLE_ENDIAN);
            this.position += TLByteArray.SIZE_OF_UINT16;
            this._writeUint8Array(utf8bytes, false);
        };
        TLByteArray.prototype.writeString = function (value) {
            var strByteArray = new TLByteArray();
            strByteArray.writeUTFBytes(value);
            this.writeUint16(strByteArray.length + 1); //标识字符数量
            this.writeBytes(strByteArray, 0, strByteArray.length);
            this.writeByte(0);
        };
        TLByteArray.prototype.writeStringByLen = function (value, len) {
            var curPos = this.position;
            this.writeUTFBytes(value);
            this.position = curPos + len;
            this.length = this.position + 1;
        };
        TLByteArray.prototype.readVector3D = function ($w) {
            if ($w === void 0) { $w = false; }
            var $p = new tl3d.Vector3D;
            $p.x = this.readFloat();
            $p.y = this.readFloat();
            $p.z = this.readFloat();
            if ($w) {
                $p.w = this.readFloat();
            }
            return $p;
        };
        /**
         * 将 UTF-8 字符串写入字节流。类似于 writeUTF() 方法，但 writeUTFBytes() 不使用 16 位长度的词为字符串添加前缀
         * @param value 要写入的字符串值
         * @method ByteArray#writeUTFBytes
         */
        TLByteArray.prototype.writeUTFBytes = function (value) {
            this._writeUint8Array(this.encodeUTF8(value));
        };
        TLByteArray.prototype.toString = function () {
            return "[ByteArray] length:" + this.length + ", bytesAvailable:" + this.bytesAvailable;
        };
        /**
         * 将 Uint8Array 写入字节流
         * @param bytes 要写入的Uint8Array
         * @param validateBuffer
         */
        TLByteArray.prototype._writeUint8Array = function (bytes, validateBuffer) {
            if (validateBuffer === void 0) { validateBuffer = true; }
            if (validateBuffer) {
                this.validateBuffer(this.position + bytes.length);
            }
            for (var i = 0; i < bytes.length; i++) {
                this.data.setUint8(this.position++, bytes[i]);
            }
        };
        /**
         * @private
         */
        TLByteArray.prototype.validate = function (len) {
            //len += this.data.byteOffset;
            if (this.data.byteLength > 0 && this._position + len <= this.data.byteLength) {
                return true;
            }
            else {
                // $error(1025);
                console.error("unvalidate byte len code:1025");
                return false;
            }
        };
        /**********************/
        /*  PRIVATE METHODS   */
        /**********************/
        TLByteArray.prototype.validateBuffer = function (len, needReplace) {
            if (needReplace === void 0) { needReplace = false; }
            this.write_position = len > this.write_position ? len : this.write_position;
            len += this._position;
            if (this.data.byteLength < len || needReplace) {
                var tmp = new Uint8Array(new ArrayBuffer(len + this.BUFFER_EXT_SIZE));
                var length = Math.min(this.data.buffer.byteLength, len + this.BUFFER_EXT_SIZE);
                tmp.set(new Uint8Array(this.data.buffer, 0, length));
                this.buffer = tmp.buffer;
            }
        };
        /**
         * UTF-8 Encoding/Decoding
         */
        TLByteArray.prototype.encodeUTF8 = function (str) {
            var pos = 0;
            var codePoints = this.stringToCodePoints(str);
            var outputBytes = [];
            while (codePoints.length > pos) {
                var code_point = codePoints[pos++];
                if (this.inRange(code_point, 0xD800, 0xDFFF)) {
                    this.encoderError(code_point);
                }
                else if (this.inRange(code_point, 0x0000, 0x007f)) {
                    outputBytes.push(code_point);
                }
                else {
                    var count, offset;
                    if (this.inRange(code_point, 0x0080, 0x07FF)) {
                        count = 1;
                        offset = 0xC0;
                    }
                    else if (this.inRange(code_point, 0x0800, 0xFFFF)) {
                        count = 2;
                        offset = 0xE0;
                    }
                    else if (this.inRange(code_point, 0x10000, 0x10FFFF)) {
                        count = 3;
                        offset = 0xF0;
                    }
                    outputBytes.push(this.div(code_point, Math.pow(64, count)) + offset);
                    while (count > 0) {
                        var temp = this.div(code_point, Math.pow(64, count - 1));
                        outputBytes.push(0x80 + (temp % 64));
                        count -= 1;
                    }
                }
            }
            return new Uint8Array(outputBytes);
        };
        TLByteArray.prototype.decodeUTF8 = function (data) {
            var fatal = false;
            var pos = 0;
            var result = "";
            var code_point;
            var utf8_code_point = 0;
            var utf8_bytes_needed = 0;
            var utf8_bytes_seen = 0;
            var utf8_lower_boundary = 0;
            while (data.length > pos) {
                var _byte = data[pos++];
                if (_byte === this.EOF_byte) {
                    if (utf8_bytes_needed !== 0) {
                        code_point = this.decoderError(fatal);
                    }
                    else {
                        code_point = this.EOF_code_point;
                    }
                }
                else {
                    if (utf8_bytes_needed === 0) {
                        if (this.inRange(_byte, 0x00, 0x7F)) {
                            code_point = _byte;
                        }
                        else {
                            if (this.inRange(_byte, 0xC2, 0xDF)) {
                                utf8_bytes_needed = 1;
                                utf8_lower_boundary = 0x80;
                                utf8_code_point = _byte - 0xC0;
                            }
                            else if (this.inRange(_byte, 0xE0, 0xEF)) {
                                utf8_bytes_needed = 2;
                                utf8_lower_boundary = 0x800;
                                utf8_code_point = _byte - 0xE0;
                            }
                            else if (this.inRange(_byte, 0xF0, 0xF4)) {
                                utf8_bytes_needed = 3;
                                utf8_lower_boundary = 0x10000;
                                utf8_code_point = _byte - 0xF0;
                            }
                            else {
                                this.decoderError(fatal);
                            }
                            utf8_code_point = utf8_code_point * Math.pow(64, utf8_bytes_needed);
                            code_point = null;
                        }
                    }
                    else if (!this.inRange(_byte, 0x80, 0xBF)) {
                        utf8_code_point = 0;
                        utf8_bytes_needed = 0;
                        utf8_bytes_seen = 0;
                        utf8_lower_boundary = 0;
                        pos--;
                        code_point = this.decoderError(fatal, _byte);
                    }
                    else {
                        utf8_bytes_seen += 1;
                        utf8_code_point = utf8_code_point + (_byte - 0x80) * Math.pow(64, utf8_bytes_needed - utf8_bytes_seen);
                        if (utf8_bytes_seen !== utf8_bytes_needed) {
                            code_point = null;
                        }
                        else {
                            var cp = utf8_code_point;
                            var lower_boundary = utf8_lower_boundary;
                            utf8_code_point = 0;
                            utf8_bytes_needed = 0;
                            utf8_bytes_seen = 0;
                            utf8_lower_boundary = 0;
                            if (this.inRange(cp, lower_boundary, 0x10FFFF) && !this.inRange(cp, 0xD800, 0xDFFF)) {
                                code_point = cp;
                            }
                            else {
                                code_point = this.decoderError(fatal, _byte);
                            }
                        }
                    }
                }
                //Decode string
                if (code_point !== null && code_point !== this.EOF_code_point) {
                    if (code_point <= 0xFFFF) {
                        if (code_point > 0)
                            result += String.fromCharCode(code_point);
                    }
                    else {
                        code_point -= 0x10000;
                        result += String.fromCharCode(0xD800 + ((code_point >> 10) & 0x3ff));
                        result += String.fromCharCode(0xDC00 + (code_point & 0x3ff));
                    }
                }
            }
            return result;
        };
        TLByteArray.prototype.encoderError = function (code_point) {
            //$error(1026, code_point);
            console.error("encoderError 1026", code_point);
        };
        TLByteArray.prototype.decoderError = function (fatal, opt_code_point) {
            if (fatal) {
                //$error(1027);
                console.error("decoderError 1027");
            }
            return opt_code_point || 0xFFFD;
        };
        TLByteArray.prototype.inRange = function (a, min, max) {
            return min <= a && a <= max;
        };
        TLByteArray.prototype.div = function (n, d) {
            return Math.floor(n / d);
        };
        TLByteArray.prototype.stringToCodePoints = function (string) {
            /** @type {Array.<number>} */
            var cps = [];
            // Based on http://www.w3.org/TR/WebIDL/#idl-DOMString
            var i = 0, n = string.length;
            while (i < string.length) {
                var c = string.charCodeAt(i);
                if (!this.inRange(c, 0xD800, 0xDFFF)) {
                    cps.push(c);
                }
                else if (this.inRange(c, 0xDC00, 0xDFFF)) {
                    cps.push(0xFFFD);
                }
                else { // (inRange(c, 0xD800, 0xDBFF))
                    if (i === n - 1) {
                        cps.push(0xFFFD);
                    }
                    else {
                        var d = string.charCodeAt(i + 1);
                        if (this.inRange(d, 0xDC00, 0xDFFF)) {
                            var a = c & 0x3FF;
                            var b = d & 0x3FF;
                            i += 1;
                            cps.push(0x10000 + (a << 10) + b);
                        }
                        else {
                            cps.push(0xFFFD);
                        }
                    }
                }
                i += 1;
            }
            return cps;
        };
        TLByteArray.SIZE_OF_BOOLEAN = 1;
        TLByteArray.SIZE_OF_INT8 = 1;
        TLByteArray.SIZE_OF_INT16 = 2;
        TLByteArray.SIZE_OF_INT32 = 4;
        TLByteArray.SIZE_OF_UINT8 = 1;
        TLByteArray.SIZE_OF_UINT16 = 2;
        TLByteArray.SIZE_OF_UINT32 = 4;
        TLByteArray.SIZE_OF_FLOAT32 = 4;
        TLByteArray.SIZE_OF_FLOAT64 = 8;
        return TLByteArray;
    }());
    tl3d.TLByteArray = TLByteArray;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TestTriangle = /** @class */ (function () {
        function TestTriangle($p1, $p2, $p3, $precision) {
            if ($p1 === void 0) { $p1 = null; }
            if ($p2 === void 0) { $p2 = null; }
            if ($p3 === void 0) { $p3 = null; }
            if ($precision === void 0) { $precision = 0.1; }
            this.p1 = $p1;
            this.p2 = $p2;
            this.p3 = $p3;
            this.precision = $precision;
        }
        TestTriangle.prototype.setAllPoint = function ($p1, $p2, $p3) {
            this.p1 = $p1;
            this.p2 = $p2;
            this.p3 = $p3;
        };
        TestTriangle.prototype.checkPointIn = function (tp) {
            var area = this.getArea();
            var targetThreeTimesArea = 0;
            targetThreeTimesArea += TestTriangle.getAreaByPoints(tp, this.p1, this.p2);
            targetThreeTimesArea += TestTriangle.getAreaByPoints(tp, this.p2, this.p3);
            targetThreeTimesArea += TestTriangle.getAreaByPoints(tp, this.p3, this.p1);
            return targetThreeTimesArea == area || Math.abs(targetThreeTimesArea - area) < this.precision;
        };
        TestTriangle.prototype.getArea = function () {
            return TestTriangle.getAreaByPoints(this.p1, this.p2, this.p3);
        };
        TestTriangle.getAreaByPoints = function (p1, p2, p3) {
            // 方法一
            // 利用两点之间距离公式，求出三角形的三边长a，b，c后，
            // 令p = (a+b+c)/2。再套入以下公式就可以求出三角形的面积S :
            // S = sqrt(p*(p-a)*(p-b)*(p-c))
            var dx = p1.x - p2.x;
            var dy = p1.y - p2.y;
            var p1Len = Math.sqrt(dx * dx + dy * dy);
            dx = p2.x - p3.x;
            dy = p2.y - p3.y;
            var p2Len = Math.sqrt(dx * dx + dy * dy);
            dx = p3.x - p1.x;
            dy = p3.y - p1.y;
            var p3Len = Math.sqrt(dx * dx + dy * dy);
            var p = (p1Len + p2Len + p3Len) / 2;
            var v = p * (p - p1Len) * (p - p2Len) * (p - p3Len);
            if (v > 0) {
                return Math.sqrt(v);
            }
            return 0;
        };
        TestTriangle.baseTri = new TestTriangle;
        return TestTriangle;
    }());
    tl3d.TestTriangle = TestTriangle;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Vector2D = /** @class */ (function () {
        function Vector2D($x, $y) {
            if ($x === void 0) { $x = 0; }
            if ($y === void 0) { $y = 0; }
            this.x = 0;
            this.y = 0;
            this.x = $x;
            this.y = $y;
        }
        Vector2D.prototype.normalize = function () {
            var le = this.length;
            if (le == 0) {
                return;
            }
            this.scaleBy(1 / le);
        };
        Object.defineProperty(Vector2D.prototype, "length", {
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            },
            enumerable: true,
            configurable: true
        });
        Vector2D.prototype.scaleBy = function (value) {
            this.x *= value;
            this.y *= value;
        };
        Vector2D.prototype.sub = function (val) {
            return new Vector2D(val.x - this.x, val.y - this.y);
        };
        Vector2D.prototype.add = function (val) {
            return new Vector2D(val.x + this.x, val.y + this.y);
        };
        Vector2D.prototype.toString = function () {
            return "Vector2D(" + String(this.x) + "," + String(this.y) + ")";
        };
        Vector2D.distance = function (p1, p2) {
            var xx = p1.x - p2.x;
            var yy = p1.y - p2.y;
            return Math.sqrt(xx * xx + yy * yy);
        };
        Vector2D.prototype.subtract = function (value) {
            return new Vector2D(this.x - value.x, this.y - value.y);
        };
        return Vector2D;
    }());
    tl3d.Vector2D = Vector2D;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Vector3D = /** @class */ (function () {
        function Vector3D($x, $y, $z, $w) {
            if ($x === void 0) { $x = 0; }
            if ($y === void 0) { $y = 0; }
            if ($z === void 0) { $z = 0; }
            if ($w === void 0) { $w = 1; }
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
            this.x = $x;
            this.y = $y;
            this.z = $z;
            this.w = $w;
        }
        Vector3D.prototype.normalize = function () {
            var le = this.length;
            if (le == 0) {
                return;
            }
            this.scaleBy(1 / le);
        };
        Object.defineProperty(Vector3D.prototype, "length", {
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        Vector3D.prototype.scaleBy = function (value) {
            this.x *= value;
            this.y *= value;
            this.z *= value;
            this.w *= value;
        };
        Vector3D.prototype.divideScalar = function (value) {
            if (value != 0) {
                this.x = this.x / value;
                this.y = this.y / value;
                this.z = this.z / value;
            }
            else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
            }
        };
        Vector3D.prototype.distanceToSquared = function (v) {
            return Vector3D.distance(this, v);
        };
        Vector3D.prototype.scaleByW = function () {
            this.x *= this.w;
            this.y *= this.w;
            this.z *= this.w;
        };
        Vector3D.prototype.add = function (value) {
            return new Vector3D(this.x + value.x, this.y + value.y, this.z + value.z);
        };
        Vector3D.prototype.subtract = function (value) {
            return new Vector3D(this.x - value.x, this.y - value.y, this.z - value.z);
        };
        Vector3D.prototype.addByNum = function ($x, $y, $z, $w) {
            if ($w === void 0) { $w = 0; }
            this.x += $x;
            this.y += $y;
            this.z += $z;
            this.w += $w;
        };
        Vector3D.prototype.setTo = function ($x, $y, $z) {
            this.x = $x;
            this.y = $y;
            this.z = $z;
        };
        Vector3D.prototype.setByte = function (byte) {
            this.x = byte.readFloat();
            this.y = byte.readFloat();
            this.z = byte.readFloat();
        };
        Vector3D.prototype.cross = function (value) {
            return new Vector3D(this.y * value.z - this.z * value.y, this.z * value.x - this.x * value.z, this.x * value.y - this.y * value.x);
        };
        Vector3D.prototype.dot = function (value) {
            return this.x * value.x + this.y * value.y + this.z * value.z;
        };
        Vector3D.prototype.clone = function () {
            return new Vector3D(this.x, this.y, this.z);
        };
        Vector3D.distance = function (v1, v2) {
            var x1 = v1.x - v2.x;
            var y1 = v1.y - v2.y;
            var z1 = v1.z - v2.z;
            return Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1);
        };
        Vector3D.prototype.toString = function () {
            return "Vector3D(" + String(this.x) + "," + String(this.y) + "," + String(this.z) + "," + String(this.w) + ")";
        };
        Vector3D.X_AXIS = new Vector3D(1, 0, 0);
        Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
        Vector3D.Z_AXIS = new Vector3D(0, 0, 1);
        return Vector3D;
    }());
    tl3d.Vector3D = Vector3D;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var CombineParticle = /** @class */ (function (_super) {
        __extends(CombineParticle, _super);
        function CombineParticle() {
            var _this = _super.call(this) || this;
            _this._maxTime = 1000000;
            _this._rotationX = 0;
            _this._rotationY = 0;
            _this._rotationZ = 0;
            _this.hasMulItem = false;
            _this.sceneVisible = true;
            _this.dynamic = false;
            _this.hasDestory = false;
            _this.timeScale = 1;
            _this._displayAry = new Array;
            _this._time = 0;
            _this.bindMatrix = new tl3d.Matrix3D;
            _this.invertBindMatrix = new tl3d.Matrix3D;
            _this.bindVecter3d = new tl3d.Vector3D();
            _this.bindScale = new tl3d.Vector3D(1, 1, 1);
            _this.groupMatrix = new tl3d.Matrix3D();
            _this.groupRotationMatrix = new tl3d.Matrix3D();
            return _this;
            //this.groupBindMatrix = new Matrix3D();
        }
        Object.defineProperty(CombineParticle.prototype, "displayAry", {
            get: function () {
                return this._displayAry;
            },
            set: function (value) {
                this._displayAry = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "maxTime", {
            set: function (value) {
                this._maxTime = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "bindTarget", {
            set: function (value) {
                this._bindTarget = value;
                this.invertBindMatrix.isIdentity = false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "bindSocket", {
            set: function (value) {
                this._bindSocket = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "x", {
            get: function () {
                return this.bindVecter3d.x;
            },
            set: function (value) {
                this.bindVecter3d.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "y", {
            get: function () {
                return this.bindVecter3d.y;
            },
            set: function (value) {
                this.bindVecter3d.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "z", {
            get: function () {
                return this.bindVecter3d.z;
            },
            set: function (value) {
                this.bindVecter3d.z = value;
            },
            enumerable: true,
            configurable: true
        });
        CombineParticle.prototype.setPos = function ($xpos, $ypos, $zpos) {
            this.bindVecter3d.setTo($xpos, $ypos, $zpos);
            for (var i = 0; i < this._displayAry.length; i++) {
                this._displayAry[i].resetPos();
            }
        };
        CombineParticle.prototype.setMulPos = function (ary) {
            for (var i = 0; i < this._displayAry.length; i++) {
                this._displayAry[i].resetMulPos(ary);
            }
        };
        Object.defineProperty(CombineParticle.prototype, "scaleX", {
            get: function () {
                return this.bindScale.x;
            },
            set: function (value) {
                this.bindScale.x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "scaleY", {
            get: function () {
                return this.bindScale.y;
            },
            set: function (value) {
                this.bindScale.y = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "scaleZ", {
            get: function () {
                return this.bindScale.z;
            },
            set: function (value) {
                this.bindScale.z = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "rotationX", {
            set: function (value) {
                this._rotationX = value;
                this.applyRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "rotationY", {
            set: function (value) {
                this._rotationY = value;
                this.applyRotation();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CombineParticle.prototype, "rotationZ", {
            set: function (value) {
                this._rotationZ = value;
                this.applyRotation();
            },
            enumerable: true,
            configurable: true
        });
        CombineParticle.prototype.applyRotation = function () {
            this.bindMatrix.identity();
            this.bindMatrix.appendRotation(this._rotationX, tl3d.Vector3D.X_AXIS);
            this.bindMatrix.appendRotation(this._rotationY, tl3d.Vector3D.Y_AXIS);
            this.bindMatrix.appendRotation(this._rotationZ, tl3d.Vector3D.Z_AXIS);
            this.bindMatrix.copyTo(this.invertBindMatrix);
            this.invertBindMatrix.invert();
            this.invertBindMatrix.isIdentity = false;
        };
        CombineParticle.prototype.setGroup = function ($pos, $rotaion, $scale) {
            this._isInGroup = true;
            this._groupPos = $pos;
            this._groupRotation = $rotaion;
            this._groupScale = $scale;
            this.groupMatrix.isIdentity = false;
            this.groupMatrix.identity();
            this.groupMatrix.appendScale($scale.x, $scale.y, $scale.z);
            this.groupMatrix.appendRotation($rotaion.x, tl3d.Vector3D.X_AXIS);
            this.groupMatrix.appendRotation($rotaion.y, tl3d.Vector3D.Y_AXIS);
            this.groupMatrix.appendRotation($rotaion.z, tl3d.Vector3D.Z_AXIS);
            this.groupMatrix.appendTranslation($pos.x, $pos.y, $pos.z);
            this.groupRotationMatrix.isIdentity = false;
            this.groupRotationMatrix.identity();
            this.groupRotationMatrix.prependRotation($rotaion.z, tl3d.Vector3D.Z_AXIS);
            this.groupRotationMatrix.prependRotation($rotaion.y, tl3d.Vector3D.Y_AXIS);
            this.groupRotationMatrix.prependRotation($rotaion.x, tl3d.Vector3D.X_AXIS);
        };
        CombineParticle.prototype.setDataByte = function (byte) {
            byte.position = 0;
            var version = byte.readInt();
            var len = byte.readInt();
            //this._sourceComNum = 0;
            this._maxTime = 0;
            //this._sourceAllNum = len;
            this._displayAry = new Array;
            for (var i = 0; i < len; i++) {
                var $particleType = byte.readInt();
                var display3D = this.getDisplay3DById($particleType);
                display3D.setAllByteInfo(byte, version);
                display3D.setBind(this.bindVecter3d, this.bindMatrix, this.bindScale, this.invertBindMatrix, this.groupMatrix);
                this._displayAry.push(display3D);
                if (display3D.timeline.maxFrameNum > this._maxTime) {
                    this._maxTime = display3D.timeline.maxFrameNum;
                }
            }
            this._maxTime *= tl3d.Scene_data.frameTime;
        };
        CombineParticle.prototype.addPrticleItem = function ($dis) {
            $dis.visible = false;
            $dis.setBind(this.bindVecter3d, this.bindMatrix, this.bindScale, this.invertBindMatrix, this.groupMatrix);
            this._displayAry.push($dis);
        };
        CombineParticle.prototype.getDisplay3DById = function (particleType) {
            var diaplayInfo = new Object;
            diaplayInfo.particleType = particleType;
            return this.getDisplay3D(diaplayInfo);
        };
        CombineParticle.prototype.setData = function (ary) {
            //this._sourceComNum = 0;
            //this._sourceAllNum = ary.length; 
            this._displayAry = new Array;
            this._maxTime = 0;
            for (var i = 0; i < ary.length; i++) {
                var diaplayInfo = ary[i].display;
                var display3D = this.getDisplay3D(diaplayInfo);
                //display3D.setAllInfo(ary[i]);
                display3D.setBind(this.bindVecter3d, this.bindMatrix, this.bindScale, this.invertBindMatrix, this.groupMatrix);
                //display3D.addEventListener(EngineEvent.COMPLETE, this.onSourceLoadCom, this);
                //display3D.bindTarget = _bindTarget;
                //display3D.bindSocket = _bindSocket;
                //display3D.setAllInfo(diaplayInfo);
                //display3D.priority = priority;
                //display3D.outVisible = this._visible;
                //display3D.isInGroup = _isInGroup;
                //display3D.groupPos = _groupPos;
                //display3D.groupRotation = _groupRotation;
                //display3D.groupScale = _groupScale;
                this._displayAry.push(display3D);
                if (display3D.timeline.maxFrameNum > this._maxTime) {
                    this._maxTime = display3D.timeline.maxFrameNum;
                }
            }
            this._maxTime *= tl3d.Scene_data.frameTime;
            //updateMatrix();
            //updateBind();
            //if (_hasStage) {
            //    addToRender();
            //}
            //maxTime = getMaxNum();
            //_hasData = true;
            //if (_cloneList) {//如果有对应的克隆队列
            //    for (i = 0; i < _cloneList.length; i++) {
            //        _cloneList[i].cloneData(this);
            //    }
            //    _cloneList.length = 0;
            //    _cloneList = null;
            //}
            //if (_hasRealDispose) {
            //    realDispose();
            //}
        };
        CombineParticle.prototype.updateTime = function (t) {
            this._time += t * this.timeScale;
            if (!this._displayAry) {
                return;
            }
            for (var i = 0; i < this._displayAry.length; i++) {
                this._displayAry[i].updateTime(this._time);
            }
            this.updateBind();
            if (this._time >= this._maxTime) {
                if (this.hasEventListener(tl3d.BaseEvent.COMPLETE)) { //优化没有监听事件就可以不用抛出
                    this.dispatchEvent(new tl3d.BaseEvent(tl3d.BaseEvent.COMPLETE));
                }
                if (this.onComplete != null) { //回调清除粒子
                    this.onComplete(this);
                    this.onComplete = null;
                }
            }
        };
        CombineParticle.prototype.updateBind = function () {
            if (this._bindTarget) {
                this._bindTarget.getSocket(this._bindSocket, this.bindMatrix);
                this.bindVecter3d.setTo(this.bindMatrix.x, this.bindMatrix.y, this.bindMatrix.z);
                this.bindMatrix.identityPostion();
                if (!this.groupRotationMatrix.isIdentity) {
                    this.bindMatrix.copyTo(this.invertBindMatrix);
                    this.invertBindMatrix.prepend(this.groupRotationMatrix);
                    this.invertBindMatrix.invert();
                }
                else {
                    this.bindMatrix.invertToMatrix(this.invertBindMatrix);
                }
                //if (this.hasMulItem){
                //    if (this._bindTarget.getSunType() == 1){
                //        var bt: any = this._bindTarget;
                //        if (typeof bt.getMulSocket == 'function') {
                //            for (var i: number = 0; i < this._displayAry.length; i++) {
                //                bt.getMulSocket(this._displayAry[i].getMulBindList());
                //            }
                //        }
                //    }
                //}
            }
        };
        CombineParticle.prototype.reset = function () {
            if (this.hasDestory) {
                return;
            }
            this._time = 0;
            for (var i = 0; this._displayAry && i < this._displayAry.length; i++) {
                this._displayAry[i].reset();
            }
        };
        CombineParticle.prototype.update = function () {
            if (!this.sceneVisible) {
                return;
            }
            if (!this._displayAry) {
                return;
            }
            for (var i = 0; i < this._displayAry.length; i++) {
                this._displayAry[i].update();
            }
        };
        CombineParticle.prototype.updateItem = function (idx) {
            if (!this.sceneVisible) {
                return;
            }
            if (this.hasDestory) {
                return;
            }
            this._displayAry[idx].update();
        };
        Object.defineProperty(CombineParticle.prototype, "size", {
            get: function () {
                if (!this._displayAry) {
                    return 0;
                }
                return this._displayAry.length;
            },
            enumerable: true,
            configurable: true
        });
        //private onSourceLoadCom(event: BaseEvent): void {
        //    //console.log(event.type);
        //    event.target.removeEventListener(BaseEvent.COMPLETE, this.onSourceLoadCom, this);
        //}
        CombineParticle.prototype.getDisplay3D = function (obj) {
            var types = obj.particleType;
            var display3D;
            switch (types) {
                case 1:
                    {
                        display3D = new tl3d.Display3DFacetParticle();
                        break;
                    }
                case 18:
                    {
                        display3D = new tl3d.Display3DBallPartilce();
                        break;
                    }
                case 3:
                    {
                        display3D = new tl3d.Display3DLocusPartilce();
                        break;
                    }
                case 14:
                    {
                        display3D = new tl3d.Display3DLocusBallPartilce();
                        break;
                    }
                case 9:
                    {
                        display3D = new tl3d.Display3DModelObjParticle();
                        break;
                    }
                case 4:
                    {
                        display3D = new tl3d.Display3DModelPartilce();
                        break;
                    }
                case 7:
                    {
                        display3D = new tl3d.Display3dModelAnimParticle();
                        break;
                    }
                case 8:
                    {
                        display3D = new tl3d.Display3DFollowPartilce();
                        break;
                    }
                // case 12:
                //     {
                //         display3D = new Display3DFollowLocusPartilce();
                //         break;
                //     }
                //case 22:
                //    {
                //        display3D = new Display3DFollowMulLocusParticle();
                //        this.hasMulItem = true;
                //        break;
                //    }
            }
            display3D.visible = false;
            return display3D;
        };
        CombineParticle.prototype.destory = function () {
            if (this.hasDestory) {
                return;
            }
            if (this.sourceData) {
                this.sourceData.useNum--;
            }
            for (var i = 0; i < this._displayAry.length; i++) {
                this._displayAry[i].destory();
            }
            this._displayAry.length = 0;
            this._displayAry = null;
            this.bindMatrix = null;
            this.bindVecter3d = null;
            this.bindScale = null;
            this.invertBindMatrix = null;
            this._bindTarget = null;
            this._bindSocket = null;
            this._groupPos = null;
            this._groupRotation = null;
            this._groupScale = null;
            this.groupMatrix = null;
            this.groupRotationMatrix = null;
            this.hasDestory = true;
        };
        return CombineParticle;
    }(tl3d.EventDispatcher));
    tl3d.CombineParticle = CombineParticle;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var CombineParticleData = /** @class */ (function (_super) {
        __extends(CombineParticleData, _super);
        function CombineParticleData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CombineParticleData.prototype.destory = function () {
            for (var i = 0; i < this.dataAry.length; i++) {
                this.dataAry[i].destory();
            }
        };
        CombineParticleData.prototype.getCombineParticle = function () {
            var particle = new tl3d.CombineParticle();
            particle.maxTime = this.maxTime;
            for (var i = 0; i < this.dataAry.length; i++) {
                var display = this.dataAry[i].creatPartilce();
                particle.addPrticleItem(display);
            }
            particle.sourceData = this;
            this.useNum++;
            return particle;
        };
        CombineParticleData.prototype.setDataByte = function (byte) {
            byte.position = 0;
            var version = byte.readInt();
            var len = byte.readInt();
            this.maxTime = 0;
            this.dataAry = new Array;
            for (var i = 0; i < len; i++) {
                var $particleType = byte.readInt();
                var pdata = this.getParticleDataType($particleType);
                pdata.version = version;
                pdata.setAllByteInfo(byte);
                this.dataAry.push(pdata);
                if (pdata.timelineData.maxFrameNum > this.maxTime) {
                    this.maxTime = pdata.timelineData.maxFrameNum;
                }
            }
            this.maxTime *= tl3d.Scene_data.frameTime;
        };
        CombineParticleData.prototype.getParticleDataType = function ($type) {
            var pdata;
            switch ($type) {
                case 1:
                    {
                        pdata = new tl3d.ParticleFacetData();
                        break;
                    }
                case 18:
                    {
                        pdata = new tl3d.ParticleBallData();
                        break;
                    }
                case 3:
                    {
                        pdata = new tl3d.ParticleLocusData();
                        break;
                    }
                case 14:
                    {
                        pdata = new tl3d.ParticleLocusballData();
                        break;
                    }
                case 9:
                case 4:
                case 7:
                    {
                        pdata = new tl3d.ParticleModelData();
                        break;
                    }
                case 8:
                    {
                        pdata = new tl3d.ParticleFollowData();
                        break;
                    }
                case 12:
                    {
                        pdata = new tl3d.ParticleFollowLocusData();
                        break;
                    }
                case 13:
                    {
                        pdata = new tl3d.ParticleBoneData();
                        break;
                    }
            }
            return pdata;
        };
        return CombineParticleData;
    }(tl3d.ResCount));
    tl3d.CombineParticleData = CombineParticleData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DParticle = /** @class */ (function (_super) {
        __extends(Display3DParticle, _super);
        function Display3DParticle() {
            var _this = _super.call(this) || this;
            _this.isInGroup = false;
            _this.visible = true;
            _this._rotationMatrix = new tl3d.Matrix3D();
            _this.modelMatrix = new tl3d.Matrix3D();
            return _this;
        }
        Display3DParticle.prototype.onCreated = function () {
        };
        Display3DParticle.prototype.setBind = function ($pos, $rotation, $scale, $invertRotation, $groupMatrix) {
            this.bindVecter3d = $pos;
            this.bindMatrix = $rotation;
            this.bindScale = $scale;
            this.invertBindMatrix = $invertRotation;
            this.groupMatrix = $groupMatrix;
        };
        Display3DParticle.prototype.getMulBindList = function () {
            return null;
        };
        Display3DParticle.prototype.updateMatrix = function () {
            if (!this.bindMatrix) {
                return;
            }
            this.modelMatrix.identity();
            if (!this.groupMatrix.isIdentity) {
                this.posMatrix.append(this.groupMatrix);
            }
            this.modelMatrix.append(this.posMatrix);
            this.modelMatrix.append(this.bindMatrix);
            this.modelMatrix.appendTranslation(this.bindVecter3d.x, this.bindVecter3d.y, this.bindVecter3d.z);
        };
        Object.defineProperty(Display3DParticle.prototype, "cantUseEffectsLev", {
            //特效配置等级显示  是否能显示
            get: function () {
                var temp = this.data._renderPriority <= tl3d.Scene_data.effectsLev; //0
                return !temp;
            },
            enumerable: true,
            configurable: true
        });
        Display3DParticle.prototype.updateTime = function (t) {
            if (this.cantUseEffectsLev) {
                return;
            }
            this._time = t - this._beginTime;
            this._time += this.data._delayedTime; //加上延时 
            this.timeline.updateTime(t);
            this.visible = this.timeline.visible;
            this.posMatrix.identity();
            this.posMatrix.prependScale(this._scaleX * 0.1 * this.bindScale.x * this.data.overAllScale, this._scaleY * 0.1 * this.bindScale.y * this.data.overAllScale, this._scaleZ * 0.1 * this.bindScale.z * this.data.overAllScale);
            this.timeline.updateMatrix(this.posMatrix, this);
        };
        Display3DParticle.prototype.reset = function () {
            this.timeline.reset();
            this.updateTime(0);
        };
        Display3DParticle.prototype.clearAllAnim = function () {
        };
        Display3DParticle.prototype.update = function () {
            if (this.cantUseEffectsLev) {
                return;
            }
            if (!this.visible) {
                return;
            }
            if (!this.data.materialParam) {
                return;
            }
            if (this.data._alphaMode == 0) {
                this.data._alphaMode = -1; //特殊调整，还需要AS那边核对
                //  console.log("改了")
            }
            tl3d.Scene_data.context3D.setBlendParticleFactors(this.data._alphaMode);
            tl3d.Scene_data.context3D.cullFaceBack(this.data.materialParam.material.backCull);
            if (this.data.materialParam) {
                tl3d.Scene_data.context3D.setProgram(this.data.materialParam.program);
            }
            this.updateMatrix();
            this.setVc();
            this.setVa();
            this.resetVa();
        };
        Display3DParticle.prototype.setVc = function () {
        };
        Display3DParticle.prototype.pushVc = function () {
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "vcmat", this.data.vcmatData);
        };
        Display3DParticle.prototype.setVa = function () {
        };
        Display3DParticle.prototype.resetVa = function () {
        };
        Display3DParticle.prototype.setMaterialVc = function () {
            if (!this.data.materialParam) {
                return;
            }
            var dynamicConstList = this.data.materialParam.dynamicConstList;
            var t = this._time % (tl3d.Scene_data.frameTime * this.data._life);
            ////console.log(this._time);
            for (var i = 0; i < dynamicConstList.length; i++) {
                dynamicConstList[i].update(t);
            }
            if (this.data.materialParam.material.fcNum <= 0) {
                return;
            }
            t = t * this.data.materialParam.material.timeSpeed;
            this.data.materialParam.material.update(t);
            ////console.log("fc5",this.data.materialParam.material.fcData[4]);
            tl3d.Scene_data.context3D.setVc4fv(this.data.materialParam.shader, "fc", this.data.materialParam.material.fcData);
            // Scene_data.context3D.setVc4fv(this.data.materialParam.shader,"fc",[1,0,0,0,this.data.materialParam.material.fcData[4],0,0,0]); 
            /**
            if (this.data.materialParam.material.hasTime) {
                t = t * this.data.materialParam.material.timeSpeed;
    
                Scene_data.context3D.setVc4fv(this.data.materialParam.shader, "fc0", [1, 0, 0, t])
            }
    
            var constVec: Array<ConstItem> = this.data.materialParam.material.constList;
            for (var i:number = 0; i < constVec.length; i++) {
                Scene_data.context3D.setVc4fv(this.data.materialParam.shader, "fc" + constVec[i].id, constVec[i].vecNum);
            }
             */
        };
        Display3DParticle.prototype.setMaterialTexture = function () {
            if (!this.data.materialParam) {
                return;
            }
            var texVec = this.data.materialParam.material.texList;
            for (var i = 0; i < texVec.length; i++) {
                if (texVec[i].isDynamic) {
                    continue;
                }
                //_context3D.setTextureAt(texVec[i].id, texVec[i].texture);
                tl3d.Scene_data.context3D.setRenderTexture(this.data.materialParam.shader, texVec[i].name, texVec[i].texture, texVec[i].id, true);
            }
            var texDynamicVec = this.data.materialParam.dynamicTexList;
            for (var i = 0; i < texDynamicVec.length; i++) {
                // _context3D.setTextureAt(texDynamicVec[i].target.id, texDynamicVec[i].texture);
                tl3d.Scene_data.context3D.setRenderTexture(this.data.materialParam.shader, texDynamicVec[i].target.name, texDynamicVec[i].texture, texDynamicVec[i].target.id, true);
            }
        };
        Display3DParticle.prototype.inverBind = function () {
            if (!this.invertBindMatrix.isIdentity) {
                //this.bindMatrix.invert();
                this._rotationMatrix.prepend(this.invertBindMatrix);
                //this.bindMatrix.invert();
            }
        };
        Display3DParticle.prototype.resetPos = function () {
        };
        Display3DParticle.prototype.resetMulPos = function (ary) {
        };
        Display3DParticle.prototype.getVector3DByObject = function (obj) {
            if (!obj) {
                return null;
            }
            return new tl3d.Vector3D(obj.x, obj.y, obj.z, obj.w);
        };
        Display3DParticle.prototype.clone = function () {
            return null;
        };
        Display3DParticle.prototype.setAllByteInfo = function ($byte, version) {
            if (version === void 0) { version = 0; }
            this.creatData();
            this.data.version = version;
            this.data.setAllByteInfo($byte);
            this.timeline = new tl3d.TimeLine();
            this.timeline.setAllDataInfo(this.data.timelineData);
            this._beginTime = this.timeline.beginTime;
        };
        Display3DParticle.prototype.creatData = function () {
            this.data = new tl3d.ParticleData;
        };
        Display3DParticle.prototype.setTimeLine = function ($tl) {
            this.timeline = $tl;
            this._beginTime = $tl.beginTime;
        };
        Display3DParticle.prototype.destory = function () {
            this.timeline = null;
            this.bindMatrix = null;
            this.bindVecter3d = null;
            this.bindScale = null;
            this.invertBindMatrix = null;
            this.groupMatrix = null;
            this._rotationMatrix = null;
            this.modelMatrix = null;
            this.groupPos = null;
            this.groupScale = null;
            this.groupRotation = null;
        };
        return Display3DParticle;
    }(tl3d.Object3D));
    tl3d.Display3DParticle = Display3DParticle;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleData = /** @class */ (function () {
        function ParticleData() {
            this._delayedTime = 0;
            this._width = 100; //宽度
            this._height = 100; //高度
            this._originWidthScale = 0.5; //原点宽度比例
            this._originHeightScale = 0.5; //原点高度比例
            this._eyeDistance = 0; //距离视点距离
            this._watchEye = false; //是否面向视点
            this._isZiZhuan = false;
            this.overAllScale = 1;
        }
        //public vcData:Float32Array;
        ParticleData.prototype.destory = function () {
            if (this.objData) {
                this.objData.destory();
            }
            this.materialParam.destory();
            this.timelineData.destory();
            this.timelineData = null;
        };
        ParticleData.prototype.uploadGpu = function () {
        };
        ParticleData.prototype.regShader = function () {
        };
        ParticleData.prototype.initVcData = function () {
        };
        ParticleData.prototype.creatPartilce = function () {
            var particle = this.getParticle();
            particle.data = this;
            var tl = new tl3d.TimeLine();
            tl.setAllDataInfo(this.timelineData);
            particle.setTimeLine(tl);
            particle.onCreated();
            return particle;
        };
        ParticleData.prototype.getParticle = function () {
            return null;
        };
        ParticleData.prototype.setAllByteInfo = function ($byte) {
            this.timelineData = new tl3d.TimeLineData();
            this.timelineData.setByteData($byte);
            this._beginTime = this.timelineData.beginTime;
            if (this.version >= 15) {
                this._delayedTime = $byte.readFloat();
            }
            this._width = $byte.readFloat();
            this._height = $byte.readFloat();
            this._widthFixed = $byte.readBoolean();
            this._heightFixed = $byte.readBoolean();
            this._originWidthScale = $byte.readFloat();
            this._originHeightScale = $byte.readFloat();
            this._eyeDistance = $byte.readFloat();
            this._alphaMode = $byte.readFloat();
            this._uSpeed = $byte.readFloat();
            this._vSpeed = $byte.readFloat();
            this._animLine = $byte.readFloat();
            this._animRow = $byte.readFloat();
            this._animInterval = $byte.readFloat();
            this._renderPriority = $byte.readFloat();
            this._distortion = $byte.readBoolean();
            this._isUV = $byte.readBoolean();
            this._isU = $byte.readBoolean();
            this._isV = $byte.readBoolean();
            this._life = $byte.readFloat();
            this._life = this._life > 10000 ? tl3d.Scene_data.MAX_NUMBER : this._life;
            this._watchEye = $byte.readBoolean();
            this._ziZhuanAngly = new tl3d.Vector3D();
            this._ziZhuanAngly.x = $byte.readFloat();
            this._ziZhuanAngly.y = $byte.readFloat();
            this._ziZhuanAngly.z = $byte.readFloat();
            this._ziZhuanAngly.w = $byte.readFloat();
            this.rotationV3d = new tl3d.Vector3D;
            this.rotationV3d.x = $byte.readFloat();
            this.rotationV3d.y = $byte.readFloat();
            this.rotationV3d.z = $byte.readFloat();
            this.center = new tl3d.Vector3D();
            this.center.x = $byte.readFloat();
            this.center.y = $byte.readFloat();
            this.center.z = $byte.readFloat();
            this.center.w = $byte.readFloat();
            this.overAllScale = $byte.readFloat();
            //var materialParamStr: string = $byte.readUTF();
            //this.materialParamData = JSON.parse(materialParamStr);
            if (this._ziZhuanAngly && (this._ziZhuanAngly.x != 0 || this._ziZhuanAngly.y != 0 || this._ziZhuanAngly.z != 0)) {
                this._isZiZhuan = true;
            }
            this.readMaterialPara($byte);
            var strMaterialUrl = $byte.readUTF();
            strMaterialUrl = strMaterialUrl.replace("_byte.txt", ".txt");
            strMaterialUrl = strMaterialUrl.replace(".txt", "_byte.txt");
            this.materialByteUrl = strMaterialUrl;
        };
        Object.defineProperty(ParticleData.prototype, "materialByteUrl", {
            set: function (value) {
                var _this = this;
                if (this._materialUrl == value) {
                    return;
                }
                this._materialUrl = value;
                tl3d.MaterialManager.getInstance().getMaterialByte(tl3d.Scene_data.fileRoot + value, function ($matrial) { _this.onMaterialLoad($matrial); });
            },
            enumerable: true,
            configurable: true
        });
        ParticleData.prototype.onMaterialLoad = function ($matrial) {
            this.materialParam = new tl3d.MaterialParam;
            this.materialParam.setMaterial($matrial);
            this.materialParam.setLife(this._life);
            if (this.materialParamData) {
                this.materialParam.setTextObj(this.materialParamData.texAry);
                this.materialParam.setConstObj(this.materialParamData.conAry);
            }
            tl3d.MaterialManager.getInstance().loadDynamicTexUtil(this.materialParam);
            this.regShader();
        };
        ParticleData.prototype.readMaterialPara = function ($byte) {
            this.materialParamData = new Object();
            var $materlUrl = $byte.readUTF();
            //  this.materialParamData.materialUrl = materialUrl;
            var texAryLen = $byte.readInt();
            this.materialParamData.texAry = new Array;
            for (var i = 0; i < texAryLen; i++) {
                var temp = new Object;
                temp.isParticleColor = $byte.readBoolean();
                temp.paramName = $byte.readUTF();
                temp.url = $byte.readUTF();
                if (temp.isParticleColor) {
                    temp.curve = new Object;
                    this.readTempCurve($byte, temp.curve);
                }
                this.materialParamData.texAry.push(temp);
            }
            this.readMaterialParaConAry($byte);
        };
        ParticleData.prototype.readTempCurve = function ($byte, curve) {
            curve.values = new Array();
            var has = false;
            if (this.version >= 12) {
                var valuesLen = $byte.readInt();
                if (valuesLen > 0) {
                    var scaleNum = $byte.readFloat();
                }
                for (var j = 0; j < valuesLen; j++) {
                    var rgbLen = $byte.readInt();
                    var valuesArr = new Array;
                    for (var k = 0; k < rgbLen; k++) {
                        valuesArr.push($byte.readByte() / 127 * scaleNum);
                    }
                    curve.values.push(valuesArr);
                }
                has = true;
            }
            curve.type = $byte.readFloat();
            curve.maxFrame = $byte.readFloat();
            curve.sideType = $byte.readBoolean();
            curve.speedType = $byte.readBoolean();
            curve.useColorType = $byte.readBoolean();
            curve.items = this.readItems($byte);
            if (!has) {
                this.makeCurveData(curve);
            }
        };
        ParticleData.prototype.readItems = function ($byte) {
            var items = new Array();
            var itemsLen = $byte.readInt();
            for (var u = 0; u < itemsLen; u++) {
                var $obj = new Object;
                $obj.frame = $byte.readInt();
                $obj.vec3 = $byte.readVector3D(true);
                $obj.rotation = $byte.readVector3D(true);
                $obj.rotationLeft = $byte.readVector3D(true);
                items.push($obj);
            }
            return items;
        };
        ParticleData.prototype.makeCurveData = function ($curve) {
            var arr = $curve.items;
            var r = new Array;
            var g = new Array;
            var b = new Array;
            var a = new Array;
            for (var i = 0; i < arr.length; i++) {
                if (i == (arr.length - 1)) { //最后一个
                    r.push(arr[i].vec3.x);
                    g.push(arr[i].vec3.y);
                    b.push(arr[i].vec3.z);
                    a.push(arr[i].vec3.w);
                }
                else {
                    var $speedNum = arr[i + 1].frame - arr[i].frame;
                    var $A = arr[i].vec3;
                    var $B = arr[i + 1].vec3;
                    var $a = $curve.items[i].rotation;
                    var $b = $curve.items[i + 1].rotationLeft;
                    r = r.concat(this.getBzData($A.x, $B.x, $a.x, $b.x, $speedNum));
                    g = g.concat(this.getBzData($A.y, $B.y, $a.y, $b.y, $speedNum));
                    b = b.concat(this.getBzData($A.z, $B.z, $a.z, $b.z, $speedNum));
                    a = a.concat(this.getBzData($A.w, $B.w, $a.w, $b.w, $speedNum));
                }
            }
            $curve.values = new Array();
            $curve.values[0] = r;
            $curve.values[1] = g;
            $curve.values[2] = b;
            $curve.values[3] = a;
        };
        ParticleData.prototype.getBzData = function ($ax, $bx, ar, br, $speedNum) {
            var num80 = 10;
            var a = new tl3d.Vector2D(0, $ax * num80);
            var d = new tl3d.Vector2D($speedNum, $bx * num80);
            var m = new tl3d.Matrix3D;
            var p = new tl3d.Vector3D;
            m.identity();
            m.appendRotation(-ar, tl3d.Vector3D.Z_AXIS);
            p = m.transformVector(new tl3d.Vector3D($speedNum / 2, 0, 0));
            var b = new tl3d.Vector2D($speedNum / 2, a.y + p.y);
            m.identity();
            m.appendRotation(-br, tl3d.Vector3D.Z_AXIS);
            p = m.transformVector(new tl3d.Vector3D(-$speedNum / 2, 0, 0));
            var c = new tl3d.Vector2D($speedNum / 2, d.y + p.y);
            var ary = [a, b, c, d];
            var posAry = new Array;
            var baseW = 3;
            for (var i = 1; i < $speedNum * 3; i++) {
                posAry.push(this.drawbezier(ary, i / ($speedNum * 3)));
            }
            var _valueVec = new Array;
            for (i = 0; i < $speedNum; i++) {
                for (var j = 0; j < posAry.length; j++) {
                    if (posAry[j].x >= i) {
                        _valueVec.push(posAry[j].y / num80);
                        break;
                    }
                }
            }
            return _valueVec;
        };
        ParticleData.prototype.drawbezier = function (_array, _time) {
            var _newarray = new Array();
            if (_array.length == 0) {
                return new tl3d.Vector2D();
            }
            for (var i in _array) {
                _newarray.push(new tl3d.Vector2D(_array[i].x, _array[i].y));
            }
            while (_newarray.length > 1) {
                for (var j = 0; j < _newarray.length - 1; j++) {
                    this.mathmidpoint(_newarray[j], _newarray[j + 1], _time);
                }
                _newarray.pop();
            }
            return _newarray[0];
        };
        ParticleData.prototype.mathmidpoint = function (a, b, t) {
            var _nx, _ny;
            _nx = a.x + (b.x - a.x) * t;
            _ny = a.y + (b.y - a.y) * t;
            a.x = _nx;
            a.y = _ny;
        };
        ParticleData.prototype.readMaterialParaConAry = function ($byte) {
            var arr = new Array;
            var conAryLen = $byte.readInt();
            for (var i = 0; i < conAryLen; i++) {
                var obj = new Object;
                obj.type = $byte.readFloat();
                obj.indexID = $byte.readFloat();
                obj.paramName = $byte.readUTF();
                obj.curve = new Object();
                this.readTempCurve($byte, obj.curve);
                arr.push(obj);
            }
            this.materialParamData.conAry = arr;
        };
        ParticleData.prototype.setFloat32Vec = function (key, ary) {
        };
        ParticleData.prototype.setFloat32Mat = function (key, ary) {
        };
        return ParticleData;
    }());
    tl3d.ParticleData = ParticleData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleGpuData = /** @class */ (function (_super) {
        __extends(ParticleGpuData, _super);
        function ParticleGpuData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ParticleGpuData;
    }(tl3d.ObjData));
    tl3d.ParticleGpuData = ParticleGpuData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleManager = /** @class */ (function (_super) {
        __extends(ParticleManager, _super);
        function ParticleManager() {
            return _super.call(this) || this;
        }
        ParticleManager.getInstance = function () {
            if (!ParticleManager._instance) {
                ParticleManager._instance = new ParticleManager();
            }
            return ParticleManager._instance;
        };
        ParticleManager.prototype.getParticleByte = function ($url) {
            $url = $url.replace("_byte.txt", ".txt");
            $url = $url.replace(".txt", "_byte.txt");
            var combineParticle;
            var url = $url;
            if (this._dic[url]) {
                var baseData = this._dic[url];
                combineParticle = baseData.getCombineParticle();
            }
            else {
                combineParticle = new tl3d.CombineParticle();
            }
            // else {
            //     LoadManager.getInstance().load(url, LoadManager.BYTE_TYPE, ($byte: ArrayBuffer) => {
            //         var byte: ByteArray = new ByteArray($byte);
            //         combineParticle.setDataByte(byte)
            //     });
            // }
            combineParticle.url = url;
            return combineParticle;
        };
        ParticleManager.prototype.registerUrl = function ($url) {
            $url = $url.replace("_byte.txt", ".txt");
            $url = $url.replace(".txt", "_byte.txt");
            if (this._dic[$url]) {
                var baseData = this._dic[$url];
                baseData.useNum++;
            }
        };
        ParticleManager.prototype.releaseUrl = function ($url) {
            $url = $url.replace("_byte.txt", ".txt");
            $url = $url.replace(".txt", "_byte.txt");
            if (this._dic[$url]) {
                var baseData = this._dic[$url];
                baseData.clearUseNum();
            }
        };
        ParticleManager.prototype.addResByte = function ($url, $data) {
            if (!this._dic[$url]) {
                var baseData = new tl3d.CombineParticleData();
                ////console.log("load particle",$url);
                baseData.setDataByte($data);
                this._dic[$url] = baseData;
            }
        };
        return ParticleManager;
    }(tl3d.ResGC));
    tl3d.ParticleManager = ParticleManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DBallPartilce = /** @class */ (function (_super) {
        __extends(Display3DBallPartilce, _super);
        function Display3DBallPartilce() {
            return _super.call(this) || this;
            //this.objData = new ParticleBallGpuData();
        }
        Object.defineProperty(Display3DBallPartilce.prototype, "balldata", {
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        Display3DBallPartilce.prototype.creatData = function () {
            this.data = new tl3d.ParticleBallData;
        };
        Display3DBallPartilce.prototype.setVa = function () {
            this.setVaCompress();
            /**
            Scene_data.context3D.setVa(0, 3, this.data.objData.vertexBuffer);
            Scene_data.context3D.setVa(1, 3, this.data.objData.uvBuffer);
            Scene_data.context3D.setVa(2, 4, this.particleBallData.basePosBuffer);
            Scene_data.context3D.setVa(3, 3, this.particleBallData.beMoveBuffer);
    
            if (this.balldata._needSelfRotation) {
                Scene_data.context3D.setVa(4, 2, this.particleBallData.baseRotationBuffer);
            }
    
            if (this.balldata._needRandomColor) {
                Scene_data.context3D.setVa(5, 4, this.particleBallData.randomColorBuffer);
            }
             */
            this.setMaterialTexture();
            tl3d.Scene_data.context3D.drawCall(this.data.objData.indexBuffer, this.data.objData.treNum);
        };
        Display3DBallPartilce.prototype.setVaCompress = function () {
            var tf = tl3d.Scene_data.context3D.pushVa(this.data.objData.vertexBuffer);
            if (tf) {
                return;
            }
            tl3d.Scene_data.context3D.setVaOffset(0, 3, this.data.objData.stride, 0);
            tl3d.Scene_data.context3D.setVaOffset(1, 3, this.data.objData.stride, 12);
            tl3d.Scene_data.context3D.setVaOffset(2, 4, this.data.objData.stride, 24);
            tl3d.Scene_data.context3D.setVaOffset(3, 3, this.data.objData.stride, 40);
            if (this.balldata._needSelfRotation) {
                tl3d.Scene_data.context3D.setVaOffset(4, 2, this.data.objData.stride, 52);
            }
            if (this.balldata._needRandomColor) {
                tl3d.Scene_data.context3D.setVaOffset(5, 4, this.particleBallData.stride, this.particleBallData.randomOffset);
            }
        };
        Display3DBallPartilce.prototype.resetVa = function () {
            //Scene_data.context3D.clearVa(2);
            //Scene_data.context3D.clearVa(3);
            //Scene_data.context3D.clearVa(4);
            //Scene_data.context3D.clearVa(5);
        };
        Display3DBallPartilce.prototype.setVc = function () {
            this.updateWatchCaramMatrix();
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "viewMatrix3D", Scene_data.viewMatrx3D.m);
            //this.balldata.setFloat32Mat("viewMatrix3D", Scene_data.viewMatrx3D.m);
            this.balldata.vcmatData.set(tl3d.Scene_data.viewMatrx3D.m, 0);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            //this.balldata.setFloat32Mat("camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            this.balldata.vcmatData.set(tl3d.Scene_data.cam3D.cameraMatrix.m, 16);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "modelMatrix", this.modelMatrix.m);
            //this.balldata.setFloat32Mat("modelMatrix", this.modelMatrix.m);//32
            this.balldata.vcmatData.set(this.modelMatrix.m, 32);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "watheye", this._rotationMatrix.m);
            //this.balldata.setFloat32Mat("watheye", this._rotationMatrix.m);//48
            this.balldata.vcmatData.set(this._rotationMatrix.m, 48);
            this.balldata._timeVec[0] = this._time / tl3d.Scene_data.frameTime * this.balldata._playSpeed;
            //Scene_data.context3D.setVc4fv(this.data.materialParam.shader, "time", this.balldata._timeVec);
            //this.balldata.setFloat32Vec("time", this.balldata._timeVec);//80
            this.balldata.vcmatData.set(this.balldata._timeVec, 80);
            /**
             if (this.balldata._needAddSpeed){
                 Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "force", this.balldata._addSpeedVec);
             }
    
             if (this.balldata._needScale){
                 Scene_data.context3D.setVc4fv(this.data.materialParam.shader, "scale", this.balldata._scaleVec);
                 Scene_data.context3D.setVc4fv(this.data.materialParam.shader, "scaleCtrl", this.balldata._scaleCtrlVec);
             }
            */
            if (this.balldata._is3Dlizi) {
                this.updateAllRotationMatrix();
                this.balldata._wordPosVec[0] = this.bindVecter3d.x;
                this.balldata._wordPosVec[1] = this.bindVecter3d.y;
                this.balldata._wordPosVec[2] = this.bindVecter3d.z;
                this.balldata._caramPosVec[0] = tl3d.Scene_data.cam3D.x;
                this.balldata._caramPosVec[1] = tl3d.Scene_data.cam3D.y;
                this.balldata._caramPosVec[2] = tl3d.Scene_data.cam3D.z;
                //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "rotationMatrix", this.balldata._allRotationMatrix.m);
                //this.balldata.setFloat32Mat("rotationMatrix", this.balldata._allRotationMatrix.m);//64
                this.balldata.vcmatData.set(this.balldata._allRotationMatrix.m, 64);
                //Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "worldPos", this.balldata._wordPosVec);
                //this.balldata.setFloat32Vec("worldPos", this.balldata._wordPosVec);//96
                this.balldata.vcmatData.set(this.balldata._wordPosVec, 96);
                //Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "camPos", this.balldata._caramPosVec);
                //this.balldata.setFloat32Vec("camPos", this.balldata._caramPosVec);//100
                this.balldata.vcmatData.set(this.balldata._caramPosVec, 100);
            }
            /**
            if (this.balldata._uvType == 1) {
                Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "animCtrl", this.balldata._animCtrlVec);
            } else if (this.balldata._uvType == 2) {
                Scene_data.context3D.setVc2fv(this.data.materialParam.shader, "uvCtrl", this.balldata._uvCtrlVec);
            }
             */
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "vcmat", this.balldata.vcmatData);
            this.setMaterialVc();
        };
        Display3DBallPartilce.prototype.updateWatchCaramMatrix = function () {
            this._rotationMatrix.identity();
            if (this.balldata.facez) {
                this._rotationMatrix.prependRotation(90, tl3d.Vector3D.X_AXIS);
            }
            else if (this.balldata._is3Dlizi) {
                //if (_axisRotaion) {
                //    _rotationMatrix.prependRotation(-_axisRotaion.num, _axisRotaion.axis);
                //}
                this.timeline.inverAxisRotation(this._rotationMatrix);
                this.inverBind();
            }
            else if (this.balldata._watchEye) {
                //if (_axisRotaion) {
                //    _rotationMatrix.prependRotation(-_axisRotaion.num, _axisRotaion.axis);
                //}
                this.timeline.inverAxisRotation(this._rotationMatrix);
                this.inverBind();
                this._rotationMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationY, tl3d.Vector3D.Y_AXIS);
                this._rotationMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationX, tl3d.Vector3D.X_AXIS);
            }
        };
        Display3DBallPartilce.prototype.updateAllRotationMatrix = function () {
            this.balldata._allRotationMatrix.identity();
            this.balldata._allRotationMatrix.prependScale(this.data.overAllScale * this._scaleX * 0.1 * this.bindScale.x, this.data.overAllScale * this._scaleY * 0.1 * this.bindScale.y, this.data.overAllScale * this._scaleZ * 0.1 * this.bindScale.z);
            //if (_axisRotaion) {
            //    _allRotationMatrix.appendRotation(_axisRotaion.num, _axisRotaion.axis, _axisRotaion.axisPos);
            //}
            this.timeline.inverAxisRotation(this._rotationMatrix);
            if (this.isInGroup) {
                this.balldata._allRotationMatrix.appendRotation(this.groupRotation.x, tl3d.Vector3D.X_AXIS);
                this.balldata._allRotationMatrix.appendRotation(this.groupRotation.y, tl3d.Vector3D.Y_AXIS);
                this.balldata._allRotationMatrix.appendRotation(this.groupRotation.z, tl3d.Vector3D.Z_AXIS);
            }
            if (this.bindMatrix) {
                this.balldata._allRotationMatrix.append(this.bindMatrix);
            }
        };
        Object.defineProperty(Display3DBallPartilce.prototype, "particleBallData", {
            get: function () {
                return (this.data.objData);
            },
            enumerable: true,
            configurable: true
        });
        return Display3DBallPartilce;
    }(tl3d.Display3DParticle));
    tl3d.Display3DBallPartilce = Display3DBallPartilce;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DBallShader = /** @class */ (function (_super) {
        __extends(Display3DBallShader, _super);
        function Display3DBallShader() {
            return _super.call(this) || this;
        }
        Display3DBallShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "vPosition");
            $context.bindAttribLocation(this.program, 1, "texcoord");
            $context.bindAttribLocation(this.program, 2, "basePos");
            $context.bindAttribLocation(this.program, 3, "speed");
            var needRotation = this.paramAry[3];
            if (needRotation) {
                $context.bindAttribLocation(this.program, 4, "rotation");
            }
            var hasRandomClolr = this.paramAry[1];
            if (hasRandomClolr) {
                $context.bindAttribLocation(this.program, 5, "color");
            }
        };
        //static shader_vec4 = {time:[0,0],scale:[1,1],scaleCtrl:[2,2],force:[3,3],worldPos:[4,0],camPos:[5,1],animCtrl:[6,2],uvCtrl:[7,3]};
        Display3DBallShader.prototype.getMat4Str = function (key) {
            return "vcmat[" + Display3DBallShader.shader_mat4[key] + "]";
        };
        Display3DBallShader.prototype.getVec4Str = function (key) {
            return "vcmat[" + Display3DBallShader.shader_vec4[key][0] + "][" + Display3DBallShader.shader_vec4[key][1] + "]";
            //return  "vc[" + Display3DBallShader.shader_vec4[key][0] + "]";
            //return key;
        };
        Display3DBallShader.getVcSize = function () {
            return 7;
        };
        Display3DBallShader.prototype.getVertexShaderString = function () {
            var baseStr;
            var scaleStr;
            var rotationStr;
            var posStr;
            var addSpeedStr;
            var mulStr;
            var resultPosStr;
            var uvStr;
            var particleColorStr;
            var randomColorStr;
            var uvDefaultStr;
            var uvAnimStr;
            var uvSpeedStr;
            var randomColorStr;
            var particleColorStr;
            var defineBaseStr;
            var defineScaleStr;
            var defineRotaionStr;
            var defineAddSpeedStr;
            var defineMulStr;
            var defineUvAnimStr;
            var defineUvSpeedStr;
            var defineRandomColor;
            var defineParticleColor;
            defineBaseStr =
                "attribute vec4 vPosition;\n" +
                    "attribute vec3 texcoord;\n" + //uv坐标xy
                    "attribute vec4 basePos;\n" + //基础位置xyz，发射起始时间w
                    "attribute vec3 speed;\n" + //速度xyz
                    "uniform mat4 vcmat[" + Display3DBallShader.getVcSize() + "];\n" + //所有vc值
                    //"uniform mat4 watheye;\n" +//面向视点矩阵
                    //"uniform mat4 viewMatrix3D;\n" +//模型矩阵
                    //"uniform mat4 modelMatrix;\n" +//模型矩阵
                    //"uniform mat4 camMatrix3D;\n" +//摄像机矩阵
                    //"uniform vec4 time;\n" +//当前时间x,自身加速度y,粒子生命z,是否循环w
                    "varying vec2 v0;\n";
            defineRandomColor =
                "attribute vec4 color;\n" + //随机颜色
                    "varying vec4 v2;\n"; //随机颜色
            defineScaleStr = "";
            //"uniform vec4 scale;\n" +//缩放x，抖动周期y，抖动振幅z
            //"uniform vec4 scaleCtrl;\n"//宽度不变，高度不变，最大比例，最小比例
            defineRotaionStr =
                "attribute vec2 rotation;\n"; //基础旋转x ， 旋转速度y
            defineAddSpeedStr = "";
            //"uniform vec3 force;\n";//外力x，外力y，外力z
            defineMulStr = "";
            //"uniform mat4 rotationMatrix;\n" +//旋转矩阵
            //"uniform vec3 worldPos;\n" +//世界中的位置
            //"uniform vec3 camPos;\n"//世界中的位置
            defineUvAnimStr = "";
            //"uniform vec3 animCtrl;\n"//动画行数x，动画列数，动画间隔
            defineUvSpeedStr = "";
            //"uniform vec2 uvCtrl;\n"//u滚动速度，v滚动速度
            defineParticleColor =
                "varying vec2 v1;\n"; //粒子颜色坐标
            baseStr =
                "float ctime = " + this.getVec4Str("time") + ".x - basePos.w;\n" + //计算当前时间
                    "if (" + this.getVec4Str("time") + ".w > 0.0 && ctime >= 0.0) {\n" +
                    "    ctime = fract(ctime / " + this.getVec4Str("time") + ".z) * " + this.getVec4Str("time") + ".z;\n" +
                    "}\n" +
                    "vec4 pos = vPosition;\n"; //自身位置
            scaleStr =
                "float stime = ctime - " + this.getVec4Str("scale") + ".w;\n" +
                    "stime = max(stime,0.0);\n" +
                    "float sf = " + this.getVec4Str("scale") + ".x * stime;\n" +
                    "if (" + this.getVec4Str("scale") + ".y != 0.0 && " + this.getVec4Str("scale") + ".z != 0.0) {\n" +
                    "    sf += sin(" + this.getVec4Str("scale") + ".y * stime) * " + this.getVec4Str("scale") + ".z;\n" +
                    "}\n" +
                    "if (sf > " + this.getVec4Str("scaleCtrl") + ".z) {\n" +
                    "    sf = " + this.getVec4Str("scaleCtrl") + ".z;\n" +
                    "} else if (sf < " + this.getVec4Str("scaleCtrl") + ".w) {\n" +
                    "    sf = " + this.getVec4Str("scaleCtrl") + ".w;\n" +
                    "}\n" +
                    "vec2 sv2 = vec2(" + this.getVec4Str("scaleCtrl") + ".x * sf, " + this.getVec4Str("scaleCtrl") + ".y * sf);\n" +
                    "sv2 = sv2 + 1.0;\n" +
                    "pos.x *= sv2.x;\n" +
                    "pos.y *= sv2.y;\n";
            rotationStr =
                "float angle = rotation.x + rotation.y * ctime;\n" +
                    "vec4 np = vec4(sin(angle), cos(angle), 0, 0);\n" +
                    "np.z = np.x * pos.y + np.y * pos.x;\n" + //b.x = sin_z * a.y + cos_z * a.x;
                    "np.w = np.y * pos.y - np.x * pos.x;\n" + //b.y = cos_z * a.y - sin_z * a.x;
                    "pos.xy = np.zw;\n";
            posStr =
                "vec3 addPos = speed * ctime;\n" + //运动部分
                    "vec3 uspeed = vec3(0,0,0);\n" +
                    "if (ctime < 0.0 || ctime >= " + this.getVec4Str("time") + ".z) {\n" + //根据时间控制粒子是否显示
                    "    addPos.y = addPos.y + 100000.0;\n" +
                    "}\n";
            addSpeedStr =
                "if(" + this.getVec4Str("time") + ".y != 0.0 && length(speed) != 0.0) {\n" +
                    "    uspeed = vec3(speed.x, speed.y, speed.z);\n" +
                    "    uspeed = normalize(uspeed);\n" +
                    "    uspeed = uspeed * " + this.getVec4Str("time") + ".y;\n" +
                    "    uspeed.xyz = uspeed.xyz + " + this.getVec4Str("force") + ".xyz;\n" +
                    "} else {\n" +
                    "    uspeed = vec3(" + this.getVec4Str("force") + ".x, " + this.getVec4Str("force") + ".y, " + this.getVec4Str("force") + ".z);\n" +
                    "}\n" +
                    "addPos.xyz = addPos.xyz + uspeed.xyz * ctime * ctime;\n";
            mulStr =
                "uspeed = speed + uspeed * ctime * 2.0;\n" + //当前速度方向
                    "uspeed = normalize(uspeed);\n" +
                    "vec4 tempMul = " + this.getMat4Str("rotationMatrix") + " * vec4(uspeed,1.0);\n" +
                    "uspeed.xyz = tempMul.xyz;\n" +
                    "uspeed = normalize(uspeed);\n" +
                    "vec3 cPos = addPos;\n" + //v(视点-位置)
                    "tempMul = " + this.getMat4Str("rotationMatrix") + " * vec4(cPos,1.0);\n" +
                    "cPos.xyz = tempMul.xyz; \n" +
                    "cPos.xyz = " + this.getVec4Str("worldPos") + ".xyz + cPos.xyz;\n" +
                    "cPos.xyz = " + this.getVec4Str("camPos") + ".xyz - cPos.xyz;\n" +
                    "cPos = normalize(cPos);\n" +
                    "cPos = cross(uspeed, cPos);\n" + //法线
                    "cPos = normalize(cPos);\n" +
                    "uspeed = uspeed * pos.x;\n" +
                    "cPos = cPos * pos.y;\n" +
                    "pos.xyz = uspeed.xyz + cPos.xyz;\n";
            resultPosStr =
                "pos = " + this.getMat4Str("watheye") + " * pos;\n" + //控制是否面向视点
                    "pos.xyz = pos.xyz + basePos.xyz + addPos.xyz;\n" +
                    "gl_Position = " + this.getMat4Str("viewMatrix3D") + " * " + this.getMat4Str("camMatrix3D") + " * " + this.getMat4Str("modelMatrix") + " * pos;\n";
            uvDefaultStr =
                "v0 = vec2(texcoord.x,texcoord.y);\n";
            uvAnimStr =
                "vec2 uv = vec2(texcoord.x,texcoord.y);\n" +
                    "float animframe = floor(ctime / " + this.getVec4Str("animCtrl") + ".z);\n" +
                    "animframe = animframe / " + this.getVec4Str("animCtrl") + ".x;\n" +
                    "uv.x += animframe;\n" +
                    "animframe = floor(animframe);\n" +
                    "uv.y += animframe / " + this.getVec4Str("animCtrl") + ".y;\n" +
                    "v0.xy = uv.xy;\n";
            uvSpeedStr =
                "vec2 uv = vec2(" + this.getVec4Str("uvCtrl") + ".x," + this.getVec4Str("uvCtrl") + ".y);\n" +
                    "uv.xy = uv.xy * ctime + texcoord.xy;\n" +
                    "v0.xy = uv.xy;\n";
            randomColorStr =
                "v2 = color;\n";
            particleColorStr =
                "v1 = vec2(ctime/" + this.getVec4Str("time") + ".z,1.0);\n";
            //this.paramAry
            var hasParticle = this.paramAry[0];
            var hasRandomClolr = this.paramAry[1];
            var isMul = this.paramAry[2];
            var needRotation = this.paramAry[3];
            var needScale = this.paramAry[4];
            var needAddSpeed = this.paramAry[5];
            var uvType = this.paramAry[6];
            var str = "";
            var defineStr = "";
            str += baseStr;
            defineStr += defineBaseStr;
            if (needScale) {
                str += scaleStr;
                defineStr += defineScaleStr;
            }
            if (needRotation) {
                str += rotationStr;
                defineStr += defineRotaionStr;
            }
            str += posStr;
            if (needAddSpeed) {
                str += addSpeedStr;
                defineStr += defineAddSpeedStr;
            }
            if (isMul) {
                str += mulStr;
                defineStr += defineMulStr;
            }
            str += resultPosStr;
            if (uvType == 1) {
                str += uvAnimStr;
                defineStr += defineUvAnimStr;
            }
            else if (uvType == 2) {
                str += uvSpeedStr;
                defineStr += defineUvSpeedStr;
            }
            else {
                str += uvDefaultStr;
            }
            if (hasRandomClolr) {
                str += randomColorStr;
                defineStr += defineRandomColor;
            }
            if (hasParticle) {
                str += particleColorStr;
                defineStr += defineParticleColor;
            }
            //str += uvStr
            //str += particleColorStr
            //str += randomColorStr
            var resultAllStr = defineStr + "void main(){\n" + str + "}";
            ////console.log(resultAllStr);
            return resultAllStr;
        };
        Display3DBallShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D tex;\n" +
                "varying vec2 v0;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(tex, v0.xy);\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        Display3DBallShader.Display3D_Ball_Shader = "Display3DBallShader";
        Display3DBallShader.shader_mat4 = { viewMatrix3D: 0, camMatrix3D: 1, modelMatrix: 2, watheye: 3, rotationMatrix: 4 };
        Display3DBallShader.shader_vec4 = { time: [5, 0], scale: [5, 1], scaleCtrl: [5, 2], force: [5, 3], worldPos: [6, 0], camPos: [6, 1], animCtrl: [6, 2], uvCtrl: [6, 3] };
        return Display3DBallShader;
    }(tl3d.Shader3D));
    tl3d.Display3DBallShader = Display3DBallShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleBallData = /** @class */ (function (_super) {
        __extends(ParticleBallData, _super);
        function ParticleBallData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._totalNum = 1;
            _this._acceleration = 0.2;
            _this._toscale = 0.00;
            _this._shootAngly = new tl3d.Vector3D(1, 0, 0);
            _this._shootSpeed = 0;
            _this._isRandom = false;
            _this._isSendRandom = false;
            _this._isSendAngleRandom = false;
            _this._paticleMaxScale = 1;
            _this._paticleMinScale = 1;
            _this._addforce = new tl3d.Vector3D(0, 0, 0);
            _this._lixinForce = new tl3d.Vector3D(0, 0, 0);
            _this._waveform = new tl3d.Vector3D(0, 0, 0, 0);
            _this._round = new tl3d.Vector3D();
            _this._is3Dlizi = false;
            _this._speed = 1;
            _this._isLoop = false;
            _this._basePositon = new tl3d.Vector3D(0, 0, 0);
            _this._baseRandomAngle = 0;
            _this._shapeType = 0;
            _this._playSpeed = 1;
            _this._beginScale = 0;
            return _this;
        }
        ParticleBallData.prototype.getParticle = function () {
            return new tl3d.Display3DBallPartilce;
        };
        ParticleBallData.prototype.setAllByteInfo = function ($byte) {
            this._totalNum = $byte.readFloat();
            this._acceleration = $byte.readFloat();
            this._toscale = $byte.readFloat();
            this._shootSpeed = $byte.readFloat();
            this._isRandom = $byte.readBoolean();
            this._isSendRandom = $byte.readBoolean();
            this._round.x = $byte.readFloat();
            this._round.y = $byte.readFloat();
            this._round.z = $byte.readFloat();
            this._round.w = $byte.readFloat();
            this._is3Dlizi = $byte.readBoolean();
            this._halfCircle = $byte.readBoolean();
            this._shootAngly.x = $byte.readFloat();
            this._shootAngly.y = $byte.readFloat();
            this._shootAngly.z = $byte.readFloat();
            this._shootAngly.w = $byte.readFloat();
            this._shootAngly.normalize(); //发射锥角，设置为摸范围内 原来没有做处理，新加
            this._speed = $byte.readFloat();
            this._isLoop = $byte.readBoolean();
            this._isSendAngleRandom = $byte.readBoolean();
            this._waveform.x = $byte.readFloat();
            this._waveform.y = $byte.readFloat();
            this._waveform.z = $byte.readFloat();
            this._waveform.w = $byte.readFloat();
            this._closeSurface = $byte.readBoolean();
            this._isEven = $byte.readBoolean();
            this._paticleMaxScale = $byte.readFloat();
            this._paticleMinScale = $byte.readFloat();
            this._basePositon.x = $byte.readFloat();
            this._basePositon.y = $byte.readFloat();
            this._basePositon.z = $byte.readFloat();
            this._basePositon.w = $byte.readFloat();
            this._baseRandomAngle = $byte.readFloat();
            this._shapeType = $byte.readFloat();
            this._lockX = $byte.readBoolean();
            this._lockY = $byte.readBoolean();
            this._addforce.x = $byte.readFloat();
            this._addforce.y = $byte.readFloat();
            this._addforce.z = $byte.readFloat();
            this._addforce.w = $byte.readFloat();
            this._addforce.scaleByW();
            this._lixinForce.x = $byte.readFloat();
            this._lixinForce.y = $byte.readFloat();
            this._lixinForce.z = $byte.readFloat();
            this._lixinForce.w = $byte.readFloat();
            this._islixinAngly = $byte.readBoolean();
            this._particleRandomScale = new tl3d.Vector3D();
            this._particleRandomScale.x = $byte.readFloat();
            this._particleRandomScale.y = $byte.readFloat();
            this._particleRandomScale.z = $byte.readFloat();
            this._particleRandomScale.w = $byte.readFloat();
            this._playSpeed = $byte.readFloat();
            this.facez = $byte.readBoolean();
            this._beginScale = $byte.readFloat();
            this._widthFixed = $byte.readBoolean();
            this._heightFixed = $byte.readBoolean();
            this.readRandomColor($byte);
            if (this._acceleration != 0 || this._addforce.x != 0 || this._addforce.y != 0 || this._addforce.z != 0) {
                this._needAddSpeed = true;
                this._addSpeedVec = [this._addforce.x, this._addforce.y, this._addforce.z];
            }
            else {
                this._needAddSpeed = false;
            }
            if (this._toscale != 0 || this._waveform.x != 0 || this._waveform.y != 0) {
                this._needScale = true;
                this._scaleVec = [this._toscale, this._waveform.x, this._waveform.y, this._beginScale];
                this._scaleCtrlVec = [this._widthFixed ? 0 : 1, this._heightFixed ? 0 : 1, this._paticleMaxScale - 1, this._paticleMinScale - 1];
            }
            else {
                this._needScale = false;
            }
            _super.prototype.setAllByteInfo.call(this, $byte);
            this._timeVec = [0, this._acceleration, this._life, this._isLoop ? 1 : -1];
            if (this._is3Dlizi) {
                this._wordPosVec = [0, 0, 0];
                this._caramPosVec = [0, 0, 0];
                this._allRotationMatrix = new tl3d.Matrix3D();
            }
            this.initVcData();
        };
        ParticleBallData.prototype.readRandomColor = function ($byte) {
            var randomColorLen = $byte.readInt();
            var obj = new Object;
            obj.alpha = new Array;
            obj.color = new Array;
            obj.pos = new Array;
            //fs.writeFloat(randomColor.alpha[i])
            //fs.writeFloat(randomColor.color[i])
            //fs.writeFloat(randomColor.pos[i])
            for (var i = 0; i < randomColorLen; i++) {
                obj.alpha.push($byte.readFloat());
                obj.color.push($byte.readFloat());
                obj.pos.push($byte.readFloat());
            }
            this._textureRandomColorInfo = obj;
        };
        Object.defineProperty(ParticleBallData.prototype, "objBallData", {
            get: function () {
                return (this.objData);
            },
            enumerable: true,
            configurable: true
        });
        ParticleBallData.prototype.uploadGpu = function () {
            this.objData = new tl3d.ParticleBallGpuData();
            this.initBaseData();
            this.initBasePos();
            this.initSpeed();
            this.initSelfRotaion();
            if (this._needRandomColor) {
                this.initBaseColor();
            }
            this.pushToGpu();
        };
        ParticleBallData.prototype.initBaseData = function () {
            var verterList = new Array;
            var uvAry = new Array;
            var indexs = new Array;
            for (var i = 0; i < this._totalNum; i++) {
                this.makeRectangleData(verterList, uvAry, this._width, this._height, this._originWidthScale, this._originHeightScale, this._isUV, this._isU, this._isV, this._animLine, this._animRow, i);
                indexs.push(0 + i * 4, 1 + i * 4, 2 + i * 4, 0 + i * 4, 2 + i * 4, 3 + i * 4);
            }
            this.objBallData.vertices = verterList;
            this.objBallData.uvs = uvAry;
            this.objBallData.indexs = indexs;
        };
        ParticleBallData.prototype.makeRectangleData = function (verterList, uvAry, width, height, offsetX, offsetY, isUV, isU, isV, animLine, animRow, indexID) {
            if (offsetX === void 0) { offsetX = 0.5; }
            if (offsetY === void 0) { offsetY = 0.5; }
            if (isUV === void 0) { isUV = false; }
            if (isU === void 0) { isU = false; }
            if (isV === void 0) { isV = false; }
            if (animLine === void 0) { animLine = 1; }
            if (animRow === void 0) { animRow = 1; }
            if (indexID === void 0) { indexID = 0; }
            var ranScale = Math.random() * (this._particleRandomScale.x - this._particleRandomScale.y) + this._particleRandomScale.y;
            verterList.push((-offsetX * width) * ranScale, (height - offsetY * height) * ranScale, 0);
            verterList.push((width - offsetX * width) * ranScale, (height - offsetY * height) * ranScale, 0);
            verterList.push((width - offsetX * width) * ranScale, (-offsetY * height) * ranScale, 0);
            verterList.push((-offsetX * width) * ranScale, (-offsetY * height) * ranScale, 0);
            var ary = new Array;
            ary.push(new tl3d.Vector2D(0, 0));
            ary.push(new tl3d.Vector2D(0, 1 / animRow));
            ary.push(new tl3d.Vector2D(1 / animLine, 1 / animRow));
            ary.push(new tl3d.Vector2D(1 / animLine, 0));
            if (isU) {
                for (var i = 0; i < ary.length; i++) {
                    ary[i].x = -ary[i].x;
                }
            }
            if (isV) {
                for (var i = 0; i < ary.length; i++) {
                    ary[i].y = -ary[i].y;
                }
            }
            if (isUV) {
                ary.push(ary.shift());
            }
            for (var i = 0; i < ary.length; i++) {
                uvAry.push(ary[i].x, ary[i].y, indexID);
            }
        };
        ParticleBallData.prototype.initBasePos = function () {
            var basePos = new Array;
            for (var i = 0; i < this._totalNum; i++) {
                var v3d;
                var ma;
                if (this._isRandom) {
                    var roundv3d = new tl3d.Vector3D(this._round.x * this._round.w, this._round.y * this._round.w, this._round.z * this._round.w);
                    if (this._isEven) { //圆柱
                        if (this._closeSurface) { //紧贴表面
                            v3d = new tl3d.Vector3D(0, 0, roundv3d.z);
                            ma = new tl3d.Matrix3D;
                            ma.appendRotation(Math.random() * 360, tl3d.Vector3D.Y_AXIS);
                            v3d = ma.transformVector(v3d);
                            v3d.y = roundv3d.y * Math.random() * 2 - roundv3d.y;
                        }
                        else {
                            v3d = new tl3d.Vector3D(0, 0, roundv3d.z * Math.random() * 2 - roundv3d.z);
                            ma = new tl3d.Matrix3D;
                            ma.appendRotation(Math.random() * 360, tl3d.Vector3D.Y_AXIS);
                            v3d = ma.transformVector(v3d);
                            v3d.y = roundv3d.y * Math.random() * 2 - roundv3d.y;
                        }
                    }
                    else { //圆球
                        if (this._closeSurface) { //只有xyz相等时候才能紧贴表面
                            v3d = new tl3d.Vector3D(0, 0, roundv3d.z);
                            ma = new tl3d.Matrix3D;
                            if (this._halfCircle) {
                                ma.appendRotation(-Math.random() * 180, tl3d.Vector3D.X_AXIS);
                            }
                            else {
                                ma.appendRotation(Math.random() * 360, tl3d.Vector3D.X_AXIS);
                            }
                            ma.appendRotation(Math.random() * 360, tl3d.Vector3D.Y_AXIS);
                            v3d = ma.transformVector(v3d);
                        }
                        else {
                            if (this._halfCircle) {
                                v3d = new tl3d.Vector3D(roundv3d.x * Math.random() * 2 - roundv3d.x, roundv3d.y * Math.random(), roundv3d.z * Math.random() * 2 - roundv3d.z);
                            }
                            else {
                                v3d = new tl3d.Vector3D(roundv3d.x * Math.random() * 2 - roundv3d.x, roundv3d.y * Math.random() * 2 - roundv3d.y, roundv3d.z * Math.random() * 2 - roundv3d.z);
                            }
                        }
                    }
                }
                else {
                    v3d = new tl3d.Vector3D();
                }
                v3d = v3d.add(this._basePositon);
                for (var j = 0; j < 4; j++) {
                    basePos.push(v3d.x, v3d.y, v3d.z, i * this._shootSpeed);
                }
            }
            this.objBallData.basePos = basePos;
        };
        ParticleBallData.prototype.initSpeed = function () {
            var beMove = new Array;
            for (var i = 0; i < this._totalNum; i++) {
                var resultv3d = new tl3d.Vector3D;
                var v3d = new tl3d.Vector3D;
                // if(this._shootAngly.z == -1){
                //     //console.log(this._shootAngly.z);
                // }
                if (this._shootAngly.x != 0 || this._shootAngly.y != 0 || this._shootAngly.z != 0) { //锥形速度
                    var r = Math.tan(this._shootAngly.w * Math.PI / 180 * Math.random());
                    var a = 360 * Math.PI / 180 * Math.random();
                    v3d = new tl3d.Vector3D(Math.sin(a) * r, Math.cos(a) * r, 1);
                    var ma = new tl3d.Matrix3D(); //moveMatrix3D();
                    ma.fromVtoV(new tl3d.Vector3D(0, 0.0101, 0.99994), new tl3d.Vector3D(this._shootAngly.x, this._shootAngly.y, this._shootAngly.z));
                    v3d = ma.transformVector(v3d);
                    if (isNaN(v3d.x)) {
                        throw new Error("发射锥角，可能有问题，确定是否有取膜");
                    }
                    v3d.normalize();
                    resultv3d = resultv3d.add(v3d);
                }
                if (this._lixinForce.x != 0 || this._lixinForce.y != 0 || this._lixinForce.z != 0) {
                    v3d = new tl3d.Vector3D(Math.random() > 0.5 ? -this._lixinForce.x : this._lixinForce.x, Math.random() > 0.5 ? -this._lixinForce.y : this._lixinForce.y, Math.random() > 0.5 ? -this._lixinForce.z : this._lixinForce.z);
                    v3d.normalize();
                    resultv3d = resultv3d.add(v3d);
                }
                if (this._islixinAngly) {
                    if (this._isEven) {
                        v3d = new tl3d.Vector3D(this.objBallData.basePos[i * 16], 0, this.objBallData.basePos[i * 16 + 2]);
                    }
                    else {
                        v3d = new tl3d.Vector3D(this.objBallData.basePos[i * 16], this.objBallData.basePos[i * 16 + 1], this.objBallData.basePos[i * 16 + 2]);
                    }
                    v3d.normalize();
                    resultv3d = resultv3d.add(v3d);
                }
                resultv3d.normalize();
                if (this._isSendRandom) {
                    resultv3d.scaleBy(this._speed * Math.random());
                }
                else {
                    resultv3d.scaleBy(this._speed);
                }
                var ranAngle = this._baseRandomAngle * Math.random() * Math.PI / 180;
                for (var j = 0; j < 4; j++) {
                    beMove.push(resultv3d.x, resultv3d.y, resultv3d.z);
                }
            }
            this.objBallData.beMove = beMove;
        };
        ParticleBallData.prototype.initSelfRotaion = function () {
            var _baseRotationAngle = 0;
            var _baseRotationSpeed = 0;
            if (this._ziZhuanAngly.x == 0 && this._ziZhuanAngly.y == 0 && this._ziZhuanAngly.z == 0 && this._ziZhuanAngly.w == 0) {
                this._needSelfRotation = false;
                return;
            }
            if (this._is3Dlizi) {
                this._needSelfRotation = false;
                return;
            }
            this._needSelfRotation = true;
            var vecs = new Array;
            var flag = 0;
            while (flag < this._totalNum) {
                _baseRotationAngle = this._ziZhuanAngly.x;
                if (this._ziZhuanAngly.y == 1) {
                    _baseRotationAngle = _baseRotationAngle * Math.random();
                }
                _baseRotationSpeed = this._ziZhuanAngly.z;
                if (this._ziZhuanAngly.w == 1) {
                    _baseRotationSpeed = _baseRotationSpeed * Math.random();
                }
                else if (this._ziZhuanAngly.w == -1) {
                    _baseRotationSpeed = _baseRotationSpeed * (Math.random() * 2 - 1);
                }
                vecs.push(_baseRotationAngle, _baseRotationSpeed);
                vecs.push(_baseRotationAngle, _baseRotationSpeed);
                vecs.push(_baseRotationAngle, _baseRotationSpeed);
                vecs.push(_baseRotationAngle, _baseRotationSpeed);
                flag++;
            }
            this.objBallData.baseRotation = vecs;
        };
        ParticleBallData.prototype.initBaseColor = function () {
            var imgData = tl3d.ColorTransition.getInstance().getImageData(this._textureRandomColorInfo);
            var colorNum = imgData.data;
            var colors = new Array;
            for (var i = 0; i < this._totalNum; i++) {
                var index = tl3d.Util.float2int(128 * Math.random()) * 4;
                var ranColor = new tl3d.Vector3D(colorNum[index], colorNum[index + 1], colorNum[index + 2], colorNum[index + 3]);
                ranColor.scaleBy(1 / 0xff);
                colors.push(ranColor.x, ranColor.y, ranColor.z, ranColor.w);
                colors.push(ranColor.x, ranColor.y, ranColor.z, ranColor.w);
                colors.push(ranColor.x, ranColor.y, ranColor.z, ranColor.w);
                colors.push(ranColor.x, ranColor.y, ranColor.z, ranColor.w);
            }
            this.objBallData.randomColor = colors;
        };
        ParticleBallData.prototype.pushToGpu = function () {
            this.compressVertex();
            /**
            this.objBallData.vertexBuffer = Scene_data.context3D.uploadBuff3D(this.objBallData.vertices);//3
    
            this.objBallData.uvBuffer = Scene_data.context3D.uploadBuff3D(this.objBallData.uvs);//3
    
            this.objBallData.basePosBuffer = Scene_data.context3D.uploadBuff3D(this.objBallData.basePos);//4
    
            this.objBallData.beMoveBuffer = Scene_data.context3D.uploadBuff3D(this.objBallData.beMove);//3
    
            this.objBallData.indexBuffer = Scene_data.context3D.uploadIndexBuff3D(this.objBallData.indexs);
    
            this.objBallData.treNum = this.objBallData.indexs.length;
    
            if (this._needSelfRotation) {
                this.objBallData.baseRotationBuffer = Scene_data.context3D.uploadBuff3D(this.objBallData.baseRotation);//2
            }
    
            if (this._needRandomColor) {
                this.objBallData.randomColorBuffer = Scene_data.context3D.uploadBuff3D(this.objBallData.randomColor);//4
            }
             */
        };
        ParticleBallData.prototype.compressVertex = function () {
            var size = this.objBallData.vertices.length / 3;
            var itemSize = 13;
            if (this._needSelfRotation) {
                itemSize += 2;
            }
            if (this._needRandomColor) {
                this.objBallData.randomOffset = itemSize * 4;
                itemSize += 4;
            }
            this.objBallData.stride = itemSize * 4;
            var ary = new Array;
            for (var i = 0; i < size; i++) {
                for (var j = 0; j < 3; j++) {
                    ary.push(this.objBallData.vertices[i * 3 + j]);
                }
                for (var j = 0; j < 3; j++) {
                    ary.push(this.objBallData.uvs[i * 3 + j]);
                }
                for (var j = 0; j < 4; j++) {
                    ary.push(this.objBallData.basePos[i * 4 + j]);
                }
                for (var j = 0; j < 3; j++) {
                    ary.push(this.objBallData.beMove[i * 3 + j]);
                }
                if (this._needSelfRotation) {
                    for (var j = 0; j < 2; j++) {
                        ary.push(this.objBallData.baseRotation[i * 2 + j]);
                    }
                }
                if (this._needRandomColor) {
                    for (var j = 0; j < 4; j++) {
                        ary.push(this.objBallData.randomColor[i * 4 + j]);
                    }
                }
            }
            this.objBallData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(ary);
            this.objBallData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objBallData.indexs);
            this.objBallData.treNum = this.objBallData.indexs.length;
            ////console.log(ary.length);
        };
        ParticleBallData.prototype.setFloat32Vec = function (key, ary) {
            var idxary = tl3d.Display3DBallShader.shader_vec4[key];
            var idx = idxary[0] * 16 + idxary[1] * 4;
            //var idx:number = idxary[0] * 4;
            this.vcmatData.set(ary, idx);
        };
        ParticleBallData.prototype.setFloat32Mat = function (key, ary) {
            var idx = tl3d.Display3DBallShader.shader_mat4[key] * 16;
            this.vcmatData.set(ary, idx);
        };
        ParticleBallData.prototype.initVcData = function () {
            this.vcmatData = new Float32Array(tl3d.Display3DBallShader.getVcSize() * 16);
            this.setFloat32Vec("time", this._timeVec);
            if (this._needAddSpeed) {
                //Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "force", this.balldata._addSpeedVec);
                this.setFloat32Vec("force", this._addSpeedVec);
            }
            if (this._needScale) {
                //Scene_data.context3D.setVc4fv(this.data.materialParam.shader, "scale", this.balldata._scaleVec);
                //Scene_data.context3D.setVc4fv(this.data.materialParam.shader, "scaleCtrl", this.balldata._scaleCtrlVec);
                this.setFloat32Vec("scale", this._scaleVec);
                this.setFloat32Vec("scaleCtrl", this._scaleCtrlVec);
            }
            if (this._uvType == 1) {
                //Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "animCtrl", this.balldata._animCtrlVec);
                this.setFloat32Vec("animCtrl", this._animCtrlVec);
            }
            else if (this._uvType == 2) {
                //Scene_data.context3D.setVc2fv(this.data.materialParam.shader, "uvCtrl", this.balldata._uvCtrlVec);
                this.setFloat32Vec("uvCtrl", this._uvCtrlVec);
            }
        };
        ParticleBallData.prototype.regShader = function () {
            if (!this.materialParam) {
                return;
            }
            var shaderParameAry = this.getShaderParam();
            //var shader: Display3DBallShader = new Display3DBallShader()
            this.materialParam.shader = tl3d.ProgrmaManager.getInstance().getMaterialProgram(tl3d.Display3DBallShader.Display3D_Ball_Shader, tl3d.Display3DBallShader, this.materialParam.material, shaderParameAry);
            this.materialParam.program = this.materialParam.shader.program;
        };
        ParticleBallData.prototype.getShaderParam = function () {
            if (this._animRow != 1 || this._animLine != 1) {
                this._uvType = 1;
                this._animCtrlVec = [this._animLine, this._animRow, this._animInterval];
            }
            else if (this._uSpeed != 0 || this._vSpeed != 0) {
                this._uvType = 2;
                this._uvCtrlVec = [this._uSpeed, this._vSpeed];
            }
            else {
                this._uvType = 0;
            }
            var hasParticleColor = this.materialParam.material.hasParticleColor;
            this._needRandomColor = this.materialParam.material.hasVertexColor;
            this.uploadGpu(); //椭球粒子需要判断是否包含随机色来确定va结构
            var shaderParameAry;
            var hasParticle;
            if (hasParticleColor) {
                hasParticle = 1;
            }
            else {
                hasParticle = 0;
            }
            var hasRandomClolr = this._needRandomColor ? 1 : 0;
            var isMul = this._is3Dlizi ? 1 : 0;
            var needRotation = this._needSelfRotation ? 1 : 0;
            var needScale = this._needScale ? 1 : 0;
            var needAddSpeed = this._needAddSpeed ? 1 : 0;
            shaderParameAry = [hasParticle, hasRandomClolr, isMul, needRotation, needScale, needAddSpeed, this._uvType];
            return shaderParameAry;
        };
        return ParticleBallData;
    }(tl3d.ParticleData));
    tl3d.ParticleBallData = ParticleBallData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleBallGpuData = /** @class */ (function (_super) {
        __extends(ParticleBallGpuData, _super);
        function ParticleBallGpuData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ParticleBallGpuData.prototype.destory = function () {
            _super.prototype.destory.call(this);
            if (this.basePos) {
                this.basePos.length = 0;
                this.basePos = null;
                if (this.basePosBuffer) {
                    tl3d.Scene_data.context3D.deleteBuffer(this.basePosBuffer);
                    this.basePosBuffer = null;
                }
            }
            if (this.beMove) {
                this.beMove.length = 0;
                this.beMove = null;
                if (this.beMoveBuffer) {
                    tl3d.Scene_data.context3D.deleteBuffer(this.beMoveBuffer);
                    this.beMoveBuffer = null;
                }
            }
            if (this.randomColor) {
                this.randomColor.length = 0;
                this.randomColor = null;
                if (this.randomColorBuffer) {
                    tl3d.Scene_data.context3D.deleteBuffer(this.randomColorBuffer);
                    this.randomColorBuffer = null;
                }
            }
            if (this.baseRotation) {
                this.baseRotation.length = 0;
                this.baseRotation = null;
                if (this.baseRotationBuffer) {
                    tl3d.Scene_data.context3D.deleteBuffer(this.baseRotationBuffer);
                    this.baseRotationBuffer = null;
                }
            }
        };
        return ParticleBallGpuData;
    }(tl3d.ParticleGpuData));
    tl3d.ParticleBallGpuData = ParticleBallGpuData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DBoneShader = /** @class */ (function (_super) {
        __extends(Display3DBoneShader, _super);
        function Display3DBoneShader() {
            return _super.call(this) || this;
        }
        Display3DBoneShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "pos");
            $context.bindAttribLocation(this.program, 1, "v2uv");
            $context.bindAttribLocation(this.program, 2, "boneWeight");
            $context.bindAttribLocation(this.program, 3, "boneID");
        };
        Display3DBoneShader.prototype.getMat4Str = function (key) {
            //return key;
            return "vcmat[" + Display3DBoneShader.shader_mat4[key] + "]";
        };
        Display3DBoneShader.getVcSize = function () {
            return 3;
        };
        Display3DBoneShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 pos;" +
                "attribute vec2 v2uv;" +
                "attribute vec4 boneWeight;" +
                "attribute vec4 boneID;" +
                "uniform vec4 boneQ[54];\n" +
                "uniform vec3 boneD[54];\n" +
                "uniform mat4 vcmat[" + Display3DBoneShader.getVcSize() + "];\n" + //所有vc值
                //"uniform mat4 viewMatrix3D;\n" +
                //"uniform mat4 camMatrix3D;\n" +
                //"uniform mat4 posMatrix3D;\n" +
                "varying vec2 v0;\n" +
                tl3d.MaterialAnimShader.getMd5M44Str() +
                "void main(void)" +
                "{" +
                "v0 = v2uv;\n" +
                "vec4 vt0 = getQDdata(vec3(pos.x,pos.y,pos.z));\n" +
                " gl_Position = " + this.getMat4Str("viewMatrix3D") + " * " + this.getMat4Str("camMatrix3D") + " *" + this.getMat4Str("posMatrix3D") + "* vt0;" +
                "}";
            return $str;
        };
        Display3DBoneShader.prototype.getFragmentShaderString = function () {
            var $str = "precision mediump float;\n" +
                "varying vec2 v0;\n" +
                "void main(void)\n" +
                "{\n" +
                "gl_FragColor = vec4(1.0,0.0,1.0,1.0);\n" +
                "}";
            return $str;
        };
        Display3DBoneShader.Display3DBoneShader = "Display3DBoneShader";
        Display3DBoneShader.shader_mat4 = { viewMatrix3D: 0, camMatrix3D: 1, posMatrix3D: 2 };
        return Display3DBoneShader;
    }(tl3d.Shader3D));
    tl3d.Display3DBoneShader = Display3DBoneShader;
    var Display3DBonePartilce = /** @class */ (function (_super) {
        __extends(Display3DBonePartilce, _super);
        function Display3DBonePartilce() {
            var _this = _super.call(this) || this;
            _this.skipNum = 0;
            return _this;
        }
        Object.defineProperty(Display3DBonePartilce.prototype, "modeldata", {
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        Display3DBonePartilce.prototype.creatData = function () {
            this.data = new tl3d.ParticleBoneData;
        };
        Display3DBonePartilce.prototype.update = function () {
            tl3d.Scene_data.context3D.setWriteDepth(false);
            _super.prototype.update.call(this);
            //   Scene_data.context3D.setWriteDepth(false);
        };
        Display3DBonePartilce.prototype.setVc = function () {
            var currentFrame = tl3d.Util.float2int((this._time / tl3d.Scene_data.frameTime) / 2);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "viewMatrix3D", Scene_data.viewMatrx3D.m);
            //this.data.setFloat32Mat("viewMatrix3D", Scene_data.viewMatrx3D.m);
            this.data.vcmatData.set(tl3d.Scene_data.viewMatrx3D.m, 0);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            //this.data.setFloat32Mat("camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            this.data.vcmatData.set(tl3d.Scene_data.cam3D.cameraMatrix.m, 16);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "posMatrix3D", this.modelMatrix.m);
            //this.data.setFloat32Mat("posMatrix3D", this.modelMatrix.m);
            this.data.vcmatData.set(this.modelMatrix.m, 32);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "vcmat", this.data.vcmatData);
            var $frameDualQuat = this.modeldata.animData.boneQPAry[0];
            var $frameLen = $frameDualQuat.length;
            var $frameId = currentFrame % $frameLen;
            /*
            for (var i: number = 0; i < this.modeldata.boneQDitem[$frameId].length; i++) {
                var $dq: ObjectBone = this.modeldata.boneQDitem[$frameId][i]
    
                Scene_data.context3D.setVc4fv(this.data.materialParam.program, "boneQ[" + i + "]", [$dq.qx, $dq.qy, $dq.qz, $dq.qw]);
                Scene_data.context3D.setVc3fv(this.data.materialParam.program, "boneD[" + i + "]", [$dq.tx, $dq.ty, $dq.tz]);
            }
            */
            var $dualQuatFrame = $frameDualQuat[$frameId];
            tl3d.Scene_data.context3D.setVc4fv(this.data.materialParam.shader, "boneQ", $dualQuatFrame.quat); //旋转
            tl3d.Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "boneD", $dualQuatFrame.pos); //所有的位移
            this.setMaterialVc();
        };
        Display3DBonePartilce.prototype.setVa = function () {
            var tf = tl3d.Scene_data.context3D.pushVa(this.modeldata.meshData.vertexBuffer);
            if (!tf) {
                tl3d.Scene_data.context3D.setVaOffset(0, 3, this.modeldata.meshData.stride, 0);
                tl3d.Scene_data.context3D.setVaOffset(1, 2, this.modeldata.meshData.stride, 12);
                tl3d.Scene_data.context3D.setVaOffset(3, 4, this.modeldata.meshData.stride, 20);
                tl3d.Scene_data.context3D.setVaOffset(2, 4, this.modeldata.meshData.stride, 36);
            }
            // Scene_data.context3D.setVa(0, 3, this.modeldata.meshData.vertexBuffer);
            // Scene_data.context3D.setVa(1, 2, this.modeldata.meshData.uvBuffer);
            // Scene_data.context3D.setVa(2, 4, this.modeldata.meshData.boneWeightBuffer);
            // Scene_data.context3D.setVa(3, 4, this.modeldata.meshData.boneIdBuffer);
            this.setMaterialTexture();
            tl3d.Scene_data.context3D.drawCall(this.modeldata.meshData.indexBuffer, this.modeldata.meshData.treNum);
        };
        Display3DBonePartilce.prototype.resetVa = function () {
            //Scene_data.context3D.clearVa(2);
            //Scene_data.context3D.clearVa(3);
            _super.prototype.resetVa.call(this);
        };
        return Display3DBonePartilce;
    }(tl3d.Display3DParticle));
    tl3d.Display3DBonePartilce = Display3DBonePartilce;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleBoneData = /** @class */ (function (_super) {
        __extends(ParticleBoneData, _super);
        function ParticleBoneData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.objScale = 1;
            return _this;
        }
        ParticleBoneData.prototype.getParticle = function () {
            return new tl3d.Display3DBonePartilce();
        };
        ParticleBoneData.prototype.destory = function () {
            _super.prototype.destory.call(this);
            //this.timelineData.destory();
            //this.timelineData = null;
            this.meshData.destory();
            this.animData = null;
        };
        ParticleBoneData.prototype.setAllByteInfo = function ($byte) {
            this.meshData = new tl3d.MeshData();
            this.animData = new tl3d.AnimData();
            this.objScale = $byte.readFloat();
            var dataWidth = 13;
            var len = $byte.getInt();
            len *= dataWidth * 4;
            var arybuff = new ArrayBuffer(len);
            var data = new DataView(arybuff);
            tl3d.BaseRes.readBytes2ArrayBuffer($byte, data, 3, 0, dataWidth); //vertices
            tl3d.BaseRes.readBytes2ArrayBuffer($byte, data, 2, 3, dataWidth); //uvs
            tl3d.BaseRes.readIntForTwoByte($byte, this.meshData.indexs);
            tl3d.BaseRes.readBytes2ArrayBuffer($byte, data, 4, 5, dataWidth, 2); //boneIDAry
            tl3d.BaseRes.readBytes2ArrayBuffer($byte, data, 4, 9, dataWidth, 3); //boneWeightAry
            this.meshData.stride = dataWidth * 4;
            // BaseRes.readFloatTwoByte($byte, this.meshData.vertices)
            // //console.log($byte.position);
            // BaseRes.readFloatTwoByte($byte, this.meshData.uvs)
            // //console.log($byte.position);
            // BaseRes.readIntForTwoByte($byte, this.meshData.indexs);
            // //console.log($byte.position);
            // var numLength: number = $byte.readInt();
            // this.meshData.boneIDAry = new Array
            // for (var j: number = 0; j < numLength; j++) {
            //     this.meshData.boneIDAry.push($byte.readByte())
            // }
            // //console.log($byte.position);
            // numLength = $byte.readInt();
            // this.meshData.boneWeightAry = new Array
            // for (var j: number = 0; j < numLength; j++) {
            //     this.meshData.boneWeightAry.push(($byte.readByte() + 128) / 255);
            // }
            // //console.log($byte.position);
            this.readFrameQua($byte);
            ////console.log($byte.position);
            _super.prototype.setAllByteInfo.call(this, $byte);
            //this.uploadGpu();
            this.initVcData();
            this.meshData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3DArrayBuffer(arybuff);
            this.meshData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.meshData.indexs);
            this.meshData.treNum = this.meshData.indexs.length;
        };
        ParticleBoneData.prototype.initVcData = function () {
            this.vcmatData = new Float32Array(tl3d.Display3DBoneShader.getVcSize() * 16);
        };
        ParticleBoneData.prototype.setFloat32Mat = function (key, ary) {
            var idx = tl3d.Display3DBoneShader.shader_mat4[key] * 16;
            this.vcmatData.set(ary, idx);
        };
        ParticleBoneData.prototype.readFrameQua = function ($byte) {
            var $tempNum = $byte.readFloat();
            var $RGB32767 = 32767;
            var $frameNum = $byte.readInt();
            var $frameDualQuat = new Array;
            for (var i = 0; i < $frameNum; i++) {
                var $len = $byte.readInt();
                var $DualQuatFloat32Array = new tl3d.DualQuatFloat32Array;
                $DualQuatFloat32Array.quat = new Float32Array($len * 4);
                $DualQuatFloat32Array.pos = new Float32Array($len * 3);
                for (var j = 0; j < $len; j++) {
                    $DualQuatFloat32Array.quat[j * 4 + 0] = $byte.readShort() / $RGB32767;
                    $DualQuatFloat32Array.quat[j * 4 + 1] = $byte.readShort() / $RGB32767;
                    $DualQuatFloat32Array.quat[j * 4 + 2] = $byte.readShort() / $RGB32767;
                    $DualQuatFloat32Array.quat[j * 4 + 3] = $byte.readShort() / $RGB32767;
                    $DualQuatFloat32Array.pos[j * 3 + 0] = $byte.readShort() / $RGB32767 * $tempNum;
                    $DualQuatFloat32Array.pos[j * 3 + 1] = $byte.readShort() / $RGB32767 * $tempNum;
                    $DualQuatFloat32Array.pos[j * 3 + 2] = $byte.readShort() / $RGB32767 * $tempNum;
                }
                $frameDualQuat.push($DualQuatFloat32Array);
            }
            this.animData.boneQPAry = new Array;
            this.animData.boneQPAry.push($frameDualQuat);
        };
        ParticleBoneData.prototype.uploadGpu = function () {
            this.uploadMesh(this.meshData);
        };
        ParticleBoneData.prototype.uploadMesh = function ($mesh) {
            $mesh.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.vertices);
            $mesh.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.uvs);
            $mesh.boneIdBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.boneIDAry);
            $mesh.boneWeightBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.boneWeightAry);
            $mesh.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D($mesh.indexs);
            $mesh.treNum = $mesh.indexs.length;
        };
        ParticleBoneData.prototype.regShader = function () {
            this.materialParam.shader = tl3d.ProgrmaManager.getInstance().getMaterialProgram(tl3d.Display3DBoneShader.Display3DBoneShader, tl3d.Display3DBoneShader, this.materialParam.material);
            this.materialParam.program = this.materialParam.shader.program;
        };
        return ParticleBoneData;
    }(tl3d.ParticleData));
    tl3d.ParticleBoneData = ParticleBoneData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var BaseAnim = /** @class */ (function () {
        function BaseAnim() {
            this.baseNum = 0;
            this.num = 0;
            this.time = 0;
            this.speed = 0;
            this.aSpeed = 0;
            this.beginTime = 0;
            this.lastTime = 0;
            this.baseTime = 0;
        }
        BaseAnim.prototype.BaseAnim = function () {
        };
        BaseAnim.prototype.update = function (t) {
            if (this._isDeath) {
                return;
            }
            this.time = t - this.baseTime;
            if (this._isActiva) {
                this.time = this.time - this.beginTime;
                if (this.time > this.lastTime) {
                    this.time = this.lastTime - this.beginTime;
                    this._isDeath = true;
                }
                this.coreCalculate();
            }
            else {
                if (this.time >= this.beginTime) {
                    if (this.time >= this.lastTime) {
                        this.time = this.lastTime - this.beginTime;
                        this.coreCalculate();
                        this._isDeath = true;
                    }
                    else {
                        this.time = this.time - this.beginTime;
                        this.coreCalculate();
                    }
                    this._isActiva = true;
                }
            }
        };
        BaseAnim.prototype.coreCalculate = function () {
            this.num = this.speed * this.time + this.aSpeed * this.time * this.time + this.baseNum;
        };
        BaseAnim.prototype.reset = function () {
            this._isActiva = false;
            this._isDeath = false;
            //time = 0;
            //baseNum = num;
            this.time = 0;
            this.num = 0;
        };
        BaseAnim.prototype.depthReset = function () {
            this._isActiva = false;
            this._isDeath = false;
            this.time = 0;
            this.baseNum = 0;
            this.num = 0;
        };
        Object.defineProperty(BaseAnim.prototype, "data", {
            set: function (value) {
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseAnim.prototype, "isDeath", {
            get: function () {
                return this._isDeath;
            },
            set: function (value) {
                this._isDeath = value;
            },
            enumerable: true,
            configurable: true
        });
        BaseAnim.prototype.getAllNum = function (allTime) {
            allTime = Math.min(allTime, this.lastTime);
            allTime = allTime - this.beginTime;
            var num = this.speed * allTime + this.aSpeed * allTime * allTime;
            this.baseNum += num;
        };
        return BaseAnim;
    }());
    tl3d.BaseAnim = BaseAnim;
})(tl3d || (tl3d = {}));
/// <reference path="BaseAnim.ts" />

(function (tl3d) {
    var AxisMove = /** @class */ (function (_super) {
        __extends(AxisMove, _super);
        function AxisMove() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(AxisMove.prototype, "data", {
            set: function (value) {
                this.beginTime = Number(value[0].value);
                if (Number(value[1].value) == -1) {
                    this.lastTime = tl3d.Scene_data.MAX_NUMBER;
                }
                else {
                    this.lastTime = Number(value[1].value);
                }
                var vc = (value[2].value).split("|");
                this.axis = new tl3d.Vector3D(Number(vc[0]), Number(vc[1]), Number(vc[2]));
                this.axis.normalize();
                this.speed = Number(value[3].value) * 0.1;
                this.aSpeed = Number(value[4].value) * 0.001;
            },
            enumerable: true,
            configurable: true
        });
        AxisMove.prototype.dataByte = function (va, arr) {
            this.beginTime = arr[0];
            if (arr[1] == -1) {
                this.lastTime = tl3d.Scene_data.MAX_NUMBER;
            }
            else {
                this.lastTime = arr[1];
            }
            this.axis = arr[2];
            this.axis.normalize();
            this.speed = arr[3] * 0.1;
            this.aSpeed = arr[4] * 0.001;
        };
        return AxisMove;
    }(tl3d.BaseAnim));
    tl3d.AxisMove = AxisMove;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var AxisRotaion = /** @class */ (function (_super) {
        __extends(AxisRotaion, _super);
        function AxisRotaion() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(AxisRotaion.prototype, "data", {
            set: function (value) {
                this.beginTime = Number(value[0].value);
                if (Number(value[1].value) == -1) {
                    this.lastTime = tl3d.Scene_data.MAX_NUMBER;
                }
                else {
                    this.lastTime = Number(value[1].value);
                }
                var vc = String(value[2].value).split("|");
                this.axis = new tl3d.Vector3D(Number(vc[0]), Number(vc[1]), Number(vc[2]));
                vc = String(value[3].value).split("|");
                this.axisPos = new tl3d.Vector3D(Number(vc[0]) * 100, Number(vc[1]) * 100, Number(vc[2]) * 100);
                this.speed = Number(value[4].value) * 0.1;
                this.aSpeed = Number(value[5].value) * 0.1;
            },
            enumerable: true,
            configurable: true
        });
        AxisRotaion.prototype.dataByte = function (va, arr) {
            this.beginTime = Number(arr[0]);
            if (Number(arr[1]) == -1) {
                this.lastTime = tl3d.Scene_data.MAX_NUMBER;
            }
            else {
                this.lastTime = Number(arr[1]);
            }
            this.axis = arr[2];
            this.axisPos = arr[3];
            this.speed = arr[4] * 0.1;
            this.aSpeed = arr[5] * 0.1;
        };
        return AxisRotaion;
    }(tl3d.BaseAnim));
    tl3d.AxisRotaion = AxisRotaion;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var KeyFrame = /** @class */ (function () {
        function KeyFrame() {
        }
        return KeyFrame;
    }());
    tl3d.KeyFrame = KeyFrame;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ScaleAnim = /** @class */ (function (_super) {
        __extends(ScaleAnim, _super);
        function ScaleAnim() {
            var _this = _super.call(this) || this;
            _this.num = 1;
            return _this;
        }
        ScaleAnim.prototype.update = function (t) {
            if (this._isDeath) {
                return;
            }
            this.time = t - this.baseTime;
            if (this._isActiva) {
                this.coreCalculate();
                if (this.time > this.lastTime) {
                    this._isDeath = true;
                }
            }
            else {
                if (this.time >= this.beginTime) {
                    //this.time = this.time-this.beginTime;
                    this._isActiva = true;
                }
            }
        };
        ScaleAnim.prototype.coreCalculate = function () {
            var frameNum = tl3d.Util.float2int(this.time / tl3d.Scene_data.frameTime);
            if (frameNum >= this.numAry.length) {
                this.num = this.numAry[this.numAry.length - 1];
            }
            else {
                this.num = this.numAry[frameNum];
            }
        };
        ScaleAnim.prototype.reset = function () {
            _super.prototype.reset.call(this);
            this.num = 1;
        };
        ScaleAnim.prototype.depthReset = function () {
            _super.prototype.depthReset.call(this);
            this.num = 1;
        };
        Object.defineProperty(ScaleAnim.prototype, "data", {
            set: function (value) {
                this.numAry = new Array;
                this.beginTime = Number(value[0].value);
                if (Number(value[1].value) == -1) {
                    this.lastTime = tl3d.Scene_data.MAX_NUMBER;
                }
                else {
                    this.lastTime = Number(value[1].value);
                }
                this.beginScale = Number(value[2].value);
                this.scaleNum = Number(value[3].value);
                this.scaleAry = new Array;
                var addTime = 0;
                for (var i = 4; i < 4 + this.scaleNum * 2; i += 2) {
                    var obj = new Object;
                    obj.value = Number(value[i].value);
                    obj.time = Number(value[i + 1].value);
                    addTime += obj.time;
                    obj.beginTime = this.beginTime + addTime;
                    this.scaleAry.push(obj);
                }
                var frameNum;
                var btime = 0;
                var aTime = 1;
                if (this.scaleAry.length) {
                    frameNum = (this.scaleAry[this.scaleAry.length - 1].beginTime + this.scaleAry[this.scaleAry.length - 1].time) / tl3d.Scene_data.frameTime;
                    aTime = this.scaleAry[0].beginTime;
                    this._currentTarget = this.scaleAry[0];
                }
                else {
                    frameNum = 0;
                }
                var flag = 0;
                for (i = 0; i < frameNum; i++) {
                    var ctime = tl3d.Scene_data.frameTime * i;
                    if (ctime >= this._currentTarget.beginTime) {
                        this.beginScale = this._currentTarget.value;
                        btime = this._currentTarget.beginTime;
                        if (flag == this.scaleAry.length - 1) {
                            this._currentTarget = this.scaleAry[this.scaleAry.length - 1];
                        }
                        else {
                            flag++;
                            this._currentTarget = this.scaleAry[flag];
                        }
                        aTime = this._currentTarget.time;
                    }
                    var cNum = (ctime - btime) / aTime * (this._currentTarget.value - this.beginScale) + this.beginScale;
                    this.numAry.push(cNum);
                }
                this._currentTarget = this.scaleAry[0];
            },
            enumerable: true,
            configurable: true
        });
        ScaleAnim.prototype.dataByte = function (va, arr) {
            this.numAry = new Array;
            this.beginTime = arr[0];
            if (arr[1] == -1) {
                this.lastTime = tl3d.Scene_data.MAX_NUMBER;
            }
            else {
                this.lastTime = arr[1];
            }
            this.beginScale = arr[2];
            this.scaleNum = arr[3];
            this.scaleAry = new Array;
            var addTime = 0;
            for (var i = 4; i < 4 + this.scaleNum * 2; i += 2) {
                var obj = new Object;
                obj.value = arr[i];
                obj.time = arr[i + 1];
                addTime += obj.time;
                obj.beginTime = this.beginTime + addTime;
                this.scaleAry.push(obj);
            }
            var frameNum;
            var btime = 0;
            var aTime = 1;
            if (this.scaleAry.length) {
                frameNum = (this.scaleAry[this.scaleAry.length - 1].beginTime + this.scaleAry[this.scaleAry.length - 1].time) / tl3d.Scene_data.frameTime;
                aTime = this.scaleAry[0].beginTime;
                this._currentTarget = this.scaleAry[0];
            }
            else {
                frameNum = 0;
            }
            var flag = 0;
            for (i = 0; i < frameNum; i++) {
                var ctime = tl3d.Scene_data.frameTime * i;
                if (ctime >= this._currentTarget.beginTime) {
                    this.beginScale = this._currentTarget.value;
                    btime = this._currentTarget.beginTime;
                    if (flag == this.scaleAry.length - 1) {
                        this._currentTarget = this.scaleAry[this.scaleAry.length - 1];
                    }
                    else {
                        flag++;
                        this._currentTarget = this.scaleAry[flag];
                    }
                    aTime = this._currentTarget.time;
                }
                var cNum = (ctime - btime) / aTime * (this._currentTarget.value - this.beginScale) + this.beginScale;
                this.numAry.push(cNum);
            }
            this._currentTarget = this.scaleAry[0];
        };
        ScaleAnim.prototype.getAllNum = function (allTime) {
            allTime = Math.min(allTime, this.lastTime + this.beginTime);
            var target = this.scaleAry[this.scaleAry.length - 1];
            if (allTime >= (target.beginTime + target.time)) {
                this.baseNum = target.value;
                return;
            }
            var flag;
            for (var i = 0; i < this.scaleAry.length; i++) {
                if (allTime > this.scaleAry[i].this.beginTime) {
                    this._currentTarget = this.scaleAry[i];
                    this.beginTime = this._currentTarget.this.beginTime;
                    this.beginScale = this._currentTarget.value;
                    flag = i;
                }
            }
            flag++;
            this._currentTarget = this.scaleAry[flag];
            this.baseNum = (this._currentTarget.value - this.beginScale) / this._currentTarget.this.time * (allTime - this.beginTime) + this.beginScale;
        };
        return ScaleAnim;
    }(tl3d.BaseAnim));
    tl3d.ScaleAnim = ScaleAnim;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ScaleChange = /** @class */ (function (_super) {
        __extends(ScaleChange, _super);
        function ScaleChange() {
            var _this = _super.call(this) || this;
            _this.num = 1;
            return _this;
        }
        ScaleChange.prototype.coreCalculate = function () {
            this.num = 1 + this.speed * this.time + this.baseNum;
            if (this.num < this.minNum) {
                this.num = this.minNum;
            }
            else if (this.num > this.maxNum) {
                this.num = this.maxNum;
            }
        };
        Object.defineProperty(ScaleChange.prototype, "data", {
            /**
             *
             * @param value
             *
             */
            set: function (value) {
                this.beginTime = Number(value[0].value);
                if (Number(value[1].value) == -1) {
                    this.lastTime = tl3d.Scene_data.MAX_NUMBER;
                }
                else {
                    this.lastTime = Number(value[1].value);
                }
                this.speed = Number(value[2].value) * 0.001;
                this.minNum = Number(value[3].value) * 0.01;
                this.maxNum = Number(value[4].value) * 0.01;
            },
            enumerable: true,
            configurable: true
        });
        ScaleChange.prototype.dataByte = function (va, arr) {
            this.beginTime = arr[0];
            if (arr[1] == -1) {
                this.lastTime = tl3d.Scene_data.MAX_NUMBER;
            }
            else {
                this.lastTime = arr[1];
            }
            this.speed = arr[2] * 0.001;
            this.minNum = arr[3] * 0.01;
            this.maxNum = arr[4] * 0.01;
        };
        ScaleChange.prototype.getAllNum = function (allTime) {
            allTime = Math.min(allTime, this.lastTime);
            allTime = allTime - this.beginTime;
            var num = this.speed * allTime;
            this.baseNum += num;
            if (this.baseNum < this.minNum) {
                this.baseNum = this.minNum;
            }
            else if (num > this.maxNum) {
                this.baseNum = this.maxNum;
            }
        };
        ScaleChange.prototype.reset = function () {
            this._isActiva = false;
            this._isDeath = false;
            this.time = 0;
            this.num = 1;
        };
        ScaleChange.prototype.depthReset = function () {
            this._isActiva = false;
            this._isDeath = false;
            this.time = 0;
            this.baseNum = 0;
            this.num = 1;
        };
        return ScaleChange;
    }(tl3d.BaseAnim));
    tl3d.ScaleChange = ScaleChange;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ScaleNoise = /** @class */ (function (_super) {
        __extends(ScaleNoise, _super);
        function ScaleNoise() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ScaleNoise.prototype.coreCalculate = function () {
            this.num = this.amplitude + this.amplitude * Math.sin(this.speed * this.time);
        };
        Object.defineProperty(ScaleNoise.prototype, "data", {
            set: function (value) {
                this.beginTime = Number(value[0].value);
                if (Number(value[1].value) == -1) {
                    this.lastTime = tl3d.Scene_data.MAX_NUMBER;
                }
                else {
                    this.lastTime = Number(value[1].value);
                }
                this.amplitude = Number(value[2].value);
                this.speed = Number(value[3].value) * 0.01;
            },
            enumerable: true,
            configurable: true
        });
        ScaleNoise.prototype.dataByte = function (va, arr) {
            this.beginTime = arr[0];
            if (arr[1] == -1) {
                this.lastTime = tl3d.Scene_data.MAX_NUMBER;
            }
            else {
                this.lastTime = arr[1];
            }
            this.amplitude = arr[2];
            this.speed = arr[3] * 0.01;
        };
        ScaleNoise.prototype.getAllNum = function (allTime) {
            this.baseNum = this.amplitude + this.amplitude * Math.sin(this.speed * allTime);
        };
        return ScaleNoise;
    }(tl3d.BaseAnim));
    tl3d.ScaleNoise = ScaleNoise;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SelfRotation = /** @class */ (function (_super) {
        __extends(SelfRotation, _super);
        function SelfRotation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(SelfRotation.prototype, "data", {
            set: function (value) {
                this.beginTime = Number(value[0].value);
                if (Number(value[1].value) == -1) {
                    this.lastTime = tl3d.Scene_data.MAX_NUMBER;
                }
                else {
                    this.lastTime = Number(value[1].value);
                }
                this.speed = Number(value[2].value) * 0.1;
                this.aSpeed = Number(value[3].value) * 0.1;
            },
            enumerable: true,
            configurable: true
        });
        SelfRotation.prototype.dataByte = function (va, arr) {
            this.beginTime = arr[0];
            if (arr[1] == -1) {
                this.lastTime = tl3d.Scene_data.MAX_NUMBER;
            }
            else {
                this.lastTime = arr[1];
            }
            this.speed = arr[2] * 0.1;
            this.aSpeed = arr[3] * 0.1;
        };
        return SelfRotation;
    }(tl3d.BaseAnim));
    tl3d.SelfRotation = SelfRotation;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TimeLine = /** @class */ (function (_super) {
        __extends(TimeLine, _super);
        function TimeLine() {
            var _this = _super.call(this) || this;
            _this._time = 0; //播放时间
            _this.targetFlag = -1;
            _this.beginTime = 0;
            _this.isByteData = false;
            _this.targetFlag = -1;
            _this.visible = false;
            _this.maxFrameNum = 0;
            _this._time = 0;
            _this._keyFrameAry = new Array;
            return _this;
        }
        TimeLine.prototype.updateMatrix = function (posMatrix, $particle) {
            if (this._axisMove) {
                posMatrix.prependTranslation(this._axisMove.axis.x * this._axisMove.num, this._axisMove.axis.y * this._axisMove.num, this._axisMove.axis.z * this._axisMove.num);
            }
            if (this._axisRotaion) {
                posMatrix.prependRotation(this._axisRotaion.num, this._axisRotaion.axis);
            }
            posMatrix.prependTranslation($particle.data.center.x, $particle.data.center.y, $particle.data.center.z);
            if (this._scaleChange) {
                //processScale();
                posMatrix.prependScale($particle.data._widthFixed ? 1 : this._scaleChange.num, $particle.data._heightFixed ? 1 : this._scaleChange.num, $particle.data._widthFixed ? 1 : this._scaleChange.num);
            }
            else if (this._scaleNosie) {
                //processNosie();
                posMatrix.prependScale($particle.data._widthFixed ? 1 : (1 + this._scaleNosie.num), $particle.data._heightFixed ? 1 : (1 + this._scaleNosie.num), $particle.data._widthFixed ? 1 : (1 + this._scaleNosie.num));
            }
            else if (this._scaleAnim) {
                //processScaleAnim();
                posMatrix.prependScale($particle.data._widthFixed ? 1 : this._scaleAnim.num, $particle.data._heightFixed ? 1 : this._scaleAnim.num, $particle.data._widthFixed ? 1 : this._scaleAnim.num);
                ////console.log(this._scaleAnim.num);
            }
            posMatrix.prependRotation($particle.data.rotationV3d.z, tl3d.Vector3D.Z_AXIS);
            posMatrix.prependRotation($particle.data.rotationV3d.y, tl3d.Vector3D.Y_AXIS);
            posMatrix.prependRotation($particle.data.rotationV3d.x, tl3d.Vector3D.X_AXIS);
        };
        TimeLine.prototype.inverAxisRotation = function ($targetMatrix) {
            if (this._axisRotaion) {
                $targetMatrix.prependRotation(-this._axisRotaion.num, this._axisRotaion.axis);
            }
        };
        TimeLine.prototype.applySelfRotation = function ($targetMatrix, $axis) {
            if (this._selfRotaion) {
                $targetMatrix.prependRotation(this._selfRotaion.num, $axis);
            }
        };
        TimeLine.prototype.addKeyFrame = function (num) {
            var keyframe = new tl3d.KeyFrame();
            keyframe.frameNum = num;
            this._keyFrameAry.push(keyframe);
            return keyframe;
        };
        TimeLine.prototype.updateTime = function (t) {
            if (!this._currentKeyFrame) {
                return;
            }
            this._time = t;
            this.getTarget();
            if (this._axisRotaion) {
                this._axisRotaion.update(this._time);
            }
            if (this._selfRotaion) {
                this._selfRotaion.update(this._time);
            }
            if (this._axisMove) {
                this._axisMove.update(this._time);
            }
            if (this._scaleChange) {
                this._scaleChange.update(this._time);
            }
            else if (this._scaleNosie) {
                this._scaleNosie.update(this._time);
            }
            else if (this._scaleAnim) {
                this._scaleAnim.update(this._time);
            }
        };
        TimeLine.prototype.getTarget = function () {
            var flag = -1;
            for (var i = 0; i < this._keyFrameAry.length; i++) {
                if (this._keyFrameAry[i].frameNum * tl3d.Scene_data.frameTime < this._time) {
                    flag = i;
                }
                else {
                    break;
                }
            }
            if (flag != this.targetFlag) {
                this._currentKeyFrame = this._keyFrameAry[flag];
                this.targetFlag = flag;
                if (flag >= (this._keyFrameAry.length - 1) || !this._currentKeyFrame) {
                    this.visible = false;
                    this._currentKeyFrame = null;
                }
                else {
                    this.visible = true;
                    this.enterKeyFrame(this._currentKeyFrame.animData, this._currentKeyFrame.frameNum * tl3d.Scene_data.frameTime, this._currentKeyFrame.baseValue);
                }
            }
        };
        TimeLine.prototype.enterKeyFrame = function (ary, baseTime, baseValueAry) {
            if (baseTime === void 0) { baseTime = 0; }
            if (baseValueAry === void 0) { baseValueAry = null; }
            if (baseValueAry == null) {
                return;
            }
            for (var i = 0; i < 10; i++) {
                if (!baseValueAry[i]) {
                    continue;
                }
                switch (i) {
                    case 1:
                        if (!this._selfRotaion)
                            this._selfRotaion = new tl3d.SelfRotation;
                        this._selfRotaion.num = this._selfRotaion.baseNum = baseValueAry[i];
                        break;
                    case 2:
                        if (!this._axisRotaion)
                            this._axisRotaion = new tl3d.AxisRotaion;
                        this._axisRotaion.num = this._axisRotaion.baseNum = baseValueAry[i];
                        break;
                    case 6:
                        if (!this._scaleChange)
                            this._scaleChange = new tl3d.ScaleChange;
                        this._scaleChange.num = this._scaleChange.baseNum = baseValueAry[i];
                        break;
                    case 7:
                        if (!this._scaleAnim)
                            this._scaleAnim = new tl3d.ScaleAnim;
                        this._scaleAnim.num = this._scaleAnim.baseNum = baseValueAry[i];
                        break;
                    case 8:
                        if (!this._scaleNosie)
                            this._scaleNosie = new tl3d.ScaleNoise;
                        this._scaleNosie.num = this._scaleNosie.baseNum = baseValueAry[i];
                        break;
                    case 9:
                        if (!this._axisMove)
                            this._axisMove = new tl3d.AxisMove;
                        this._axisMove.num = this._axisMove.baseNum = baseValueAry[i];
                        break;
                }
            }
            if (this._selfRotaion)
                this._selfRotaion.isDeath = true;
            if (this._axisRotaion)
                this._axisRotaion.isDeath = true;
            if (this._scaleChange)
                this._scaleChange.isDeath = true;
            if (this._scaleAnim)
                this._scaleAnim.isDeath = true;
            if (this._scaleNosie)
                this._scaleNosie.isDeath = true;
            if (this._axisMove)
                this._axisMove.isDeath = true;
            if (!ary) {
                return;
            }
            this.setBaseTimeByte(ary, baseTime, baseValueAry);
        };
        TimeLine.prototype.reset = function () {
            this._time = 0;
            this._currentKeyFrame = this._keyFrameAry[0];
            this.visible = false;
            this.targetFlag = -1;
        };
        TimeLine.prototype.setAllByteInfo = function ($byte, $allObj) {
            this.isByteData = true;
            var len = $byte.readFloat();
            for (var i = 0; i < len; i++) {
                var frameNum = $byte.readFloat();
                var key = this.addKeyFrame(frameNum);
                key.frameNum = frameNum;
                key.baseValue = new Array();
                for (var j = 0; j < 10; j++) {
                    key.baseValue.push($byte.readFloat());
                }
                var animLen = $byte.readFloat();
                key.animData = new Array;
                if (animLen > 0) {
                    for (var k = 0; k < animLen; k++) {
                        key.animData.push(this.getByteDataTemp($byte));
                    }
                }
            }
            this.maxFrameNum = this._keyFrameAry[this._keyFrameAry.length - 1].frameNum;
            this.beginTime = this._keyFrameAry[0].frameNum * tl3d.Scene_data.frameTime;
            this._currentKeyFrame = this._keyFrameAry[0];
        };
        TimeLine.prototype.setAllDataInfo = function ($data) {
            this.isByteData = true;
            var len = $data.dataAry.length;
            for (var i = 0; i < len; i++) {
                var key = this.addKeyFrame($data.dataAry[i].frameNum);
                key.baseValue = $data.dataAry[i].baseValue;
                key.animData = $data.dataAry[i].animData;
            }
            this.maxFrameNum = $data.maxFrameNum;
            this.beginTime = $data.beginTime;
            this._currentKeyFrame = this._keyFrameAry[0];
        };
        TimeLine.prototype.setBaseTimeByte = function (ary, baseTime, baseValueAry) {
            if (baseTime === void 0) { baseTime = 0; }
            if (baseValueAry === void 0) { baseValueAry = null; }
            for (var i = 0; i < ary.length; i++) {
                if (ary[i].type == 1) {
                    if (!this._selfRotaion) {
                        this._selfRotaion = new tl3d.SelfRotation;
                    }
                    else {
                        this._selfRotaion.reset();
                    }
                    // this._selfRotaion.data = (ary[i].data);
                    this._selfRotaion.dataByte(ary[i].data, ary[i].dataByte);
                    this._selfRotaion.baseTime = baseTime;
                }
                else if (ary[i].type == 2) {
                    if (!this._axisRotaion) {
                        this._axisRotaion = new tl3d.AxisRotaion;
                    }
                    else {
                        this._axisRotaion.reset();
                    }
                    this._axisRotaion.dataByte(ary[i].data, ary[i].dataByte);
                    this._axisRotaion.baseTime = baseTime;
                }
                else if (ary[i].type == 6) {
                    if (!this._scaleChange) {
                        this._scaleChange = new tl3d.ScaleChange;
                    }
                    else {
                        this._scaleChange.reset();
                    }
                    //this._scaleChange.data = (ary[i].data);
                    this._scaleChange.dataByte(ary[i].data, ary[i].dataByte);
                    this._scaleChange.baseTime = baseTime;
                }
                else if (ary[i].type == 7) {
                    if (!this._scaleAnim) {
                        this._scaleAnim = new tl3d.ScaleAnim;
                    }
                    else {
                        this._scaleAnim.reset();
                    }
                    // this._scaleAnim.data = (ary[i].data);
                    this._scaleAnim.dataByte(ary[i].data, ary[i].dataByte);
                    this._scaleAnim.baseTime = baseTime;
                }
                else if (ary[i].type == 8) {
                    if (!this._scaleNosie) {
                        this._scaleNosie = new tl3d.ScaleNoise;
                    }
                    else {
                        this._scaleNosie.reset();
                    }
                    //this._scaleNosie.data = (ary[i].data);
                    this._scaleNosie.dataByte(ary[i].data, ary[i].dataByte);
                    this._scaleNosie.baseTime = baseTime;
                }
                else if (ary[i].type == 9) {
                    if (!this._axisMove) {
                        this._axisMove = new tl3d.AxisMove;
                    }
                    else {
                        this._axisMove.reset();
                    }
                    // this._axisMove.data = (ary[i].data);
                    this._axisMove.dataByte(ary[i].data, ary[i].dataByte);
                    this._axisMove.baseTime = baseTime;
                }
            }
        };
        TimeLine.prototype.getByteDataTemp = function ($byte) {
            var obj = new Object;
            var animType = $byte.readInt();
            var dataLen = $byte.readInt();
            obj.data = new Array;
            obj.dataByte = new Array;
            for (var i = 0; i < dataLen; i++) {
                var ko = new Object;
                ko.type = $byte.readInt();
                //  ko.value = $byte.readUTF();
                // obj.data.push(ko);
                if (ko.type == 1) {
                    var num = $byte.readFloat();
                    obj.dataByte.push(num);
                }
                if (ko.type == 2) {
                    var v = new tl3d.Vector3D();
                    v.x = $byte.readFloat();
                    v.y = $byte.readFloat();
                    v.z = $byte.readFloat();
                    obj.dataByte.push(v);
                }
            }
            obj.type = animType;
            return obj;
        };
        /**
         * 获取最大的帧数
         * @return 最大帧数
         *
         */
        TimeLine.prototype.getMaxFrame = function () {
            return this._keyFrameAry[this._keyFrameAry.length - 1].frameNum;
        };
        TimeLine.prototype.dispose = function () {
            //this._keyFrameAry = null;
            //this._display3D.clear();
            //this._display3D = null;
            //this._currentKeyFrame = null;
        };
        return TimeLine;
    }(tl3d.EventDispatcher));
    tl3d.TimeLine = TimeLine;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TimeLineData = /** @class */ (function () {
        function TimeLineData() {
            this.dataAry = new Array;
        }
        TimeLineData.prototype.destory = function () {
            this.dataAry = null;
        };
        TimeLineData.prototype.setByteData = function ($byte) {
            var len = $byte.readFloat();
            for (var i = 0; i < len; i++) {
                var frameNum = $byte.readFloat();
                var key = this.addKeyFrame(frameNum);
                key.frameNum = frameNum;
                key.baseValue = new Array();
                for (var j = 0; j < 10; j++) {
                    key.baseValue.push($byte.readFloat());
                }
                var animLen = $byte.readFloat();
                key.animData = new Array;
                if (animLen > 0) {
                    for (var k = 0; k < animLen; k++) {
                        key.animData.push(this.getByteDataTemp($byte));
                    }
                }
            }
            this.maxFrameNum = this.dataAry[this.dataAry.length - 1].frameNum;
            this.beginTime = this.dataAry[0].frameNum * tl3d.Scene_data.frameTime;
        };
        TimeLineData.prototype.addKeyFrame = function (num) {
            var keyframe = new Object();
            keyframe.frameNum = num;
            this.dataAry.push(keyframe);
            return keyframe;
        };
        TimeLineData.prototype.getByteDataTemp = function ($byte) {
            var obj = new Object;
            var animType = $byte.readInt();
            var dataLen = $byte.readInt();
            obj.data = new Array;
            obj.dataByte = new Array;
            for (var i = 0; i < dataLen; i++) {
                var ko = new Object;
                ko.type = $byte.readInt();
                //  ko.value = $byte.readUTF();
                // obj.data.push(ko);
                if (ko.type == 1) {
                    var num = $byte.readFloat();
                    obj.dataByte.push(num);
                }
                if (ko.type == 2) {
                    var v = new tl3d.Vector3D();
                    v.x = $byte.readFloat();
                    v.y = $byte.readFloat();
                    v.z = $byte.readFloat();
                    obj.dataByte.push(v);
                }
            }
            obj.type = animType;
            return obj;
        };
        return TimeLineData;
    }());
    tl3d.TimeLineData = TimeLineData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DFacetParticle = /** @class */ (function (_super) {
        __extends(Display3DFacetParticle, _super);
        function Display3DFacetParticle() {
            var _this = _super.call(this) || this;
            _this._lifeVisible = true;
            //this.objData = new ParticleGpuData();
            //this.program = ProgrmaManager.getInstance().getProgram(Display3DFacetShader.Display3D_Facet_Shader);
            _this._resultUvVec = new Array(2);
            return _this;
        }
        Object.defineProperty(Display3DFacetParticle.prototype, "facetdata", {
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        Display3DFacetParticle.prototype.creatData = function () {
            this.data = new tl3d.ParticleFacetData;
        };
        Display3DFacetParticle.prototype.update = function () {
            if (!this._lifeVisible) {
                return;
            }
            _super.prototype.update.call(this);
        };
        Display3DFacetParticle.prototype.reset = function () {
            _super.prototype.reset.call(this);
            this._lifeVisible = true;
        };
        Display3DFacetParticle.prototype.setVc = function () {
            this.updateRotaionMatrix();
            this.updateUV();
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "viewMatrix3D", Scene_data.viewMatrx3D.m);
            //this.data.setFloat32Mat("viewMatrix3D", Scene_data.viewMatrx3D.m);//0
            this.data.vcmatData.set(tl3d.Scene_data.viewMatrx3D.m, 0);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            //this.data.setFloat32Mat("camMatrix3D", Scene_data.cam3D.cameraMatrix.m);//16
            this.data.vcmatData.set(tl3d.Scene_data.cam3D.cameraMatrix.m, 16);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "posMatrix3D", this.modelMatrix.m);
            //this.data.setFloat32Mat("posMatrix3D", this.modelMatrix.m);//48
            this.data.vcmatData.set(this.modelMatrix.m, 48);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "rotationMatrix3D", this._rotationMatrix.m);
            //this.data.setFloat32Mat("rotationMatrix3D", this._rotationMatrix.m);//32
            this.data.vcmatData.set(this._rotationMatrix.m, 32);
            //Scene_data.context3D.setVc2fv(this.data.materialParam.shader, "uvMove", this._resultUvVec);
            //this.data.setFloat32Vec("uvMove",this._resultUvVec);//64
            this.data.vcmatData.set(this._resultUvVec, 64);
            this.setMaterialVc();
            if (!this.facetdata._isCycle && this._time / tl3d.Scene_data.frameTime > (this.data._life - 2)) {
                this._lifeVisible = false;
            }
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "vcmat", this.data.vcmatData);
        };
        Display3DFacetParticle.prototype.setVa = function () {
            var tf = tl3d.Scene_data.context3D.pushVa(this.data.objData.vertexBuffer);
            if (!tf) {
                tl3d.Scene_data.context3D.setVaOffset(0, 3, this.data.objData.stride, 0);
                tl3d.Scene_data.context3D.setVaOffset(1, 2, this.data.objData.stride, 12);
            }
            //Scene_data.context3D.setVa(0, 3, this.data.objData.vertexBuffer);
            //Scene_data.context3D.setVa(1, 2, this.data.objData.uvBuffer);
            this.setMaterialTexture();
            tl3d.Scene_data.context3D.drawCall(this.data.objData.indexBuffer, this.data.objData.treNum);
        };
        Display3DFacetParticle.prototype.updateRotaionMatrix = function () {
            this._rotationMatrix.identity();
            if (this.data._watchEye) {
                this.timeline.inverAxisRotation(this._rotationMatrix);
                if (!this.facetdata._locky && !this.facetdata._lockx) {
                    this.inverBind();
                }
                if (!this.facetdata._locky) {
                    this._rotationMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationY, tl3d.Vector3D.Y_AXIS);
                }
                if (!this.facetdata._lockx) {
                    this._rotationMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationX, tl3d.Vector3D.X_AXIS);
                }
            }
            if (this.data._isZiZhuan) {
                this.timeline.applySelfRotation(this._rotationMatrix, this.data._ziZhuanAngly);
            }
        };
        Display3DFacetParticle.prototype.updateUV = function () {
            var currentFrame = tl3d.Util.float2int(this._time / tl3d.Scene_data.frameTime);
            currentFrame = currentFrame > this.facetdata._maxAnimTime ? this.facetdata._maxAnimTime : currentFrame;
            currentFrame = (currentFrame / this.data._animInterval) % (this.data._animLine * this.data._animRow);
            this._resultUvVec[0] = tl3d.Util.float2int(currentFrame % this.data._animLine) / this.data._animLine + this._time / tl3d.Scene_data.frameTime * this.data._uSpeed;
            this._resultUvVec[1] = tl3d.Util.float2int(currentFrame / this.data._animLine) / this.data._animRow + this._time / tl3d.Scene_data.frameTime * this.data._vSpeed;
        };
        return Display3DFacetParticle;
    }(tl3d.Display3DParticle));
    tl3d.Display3DFacetParticle = Display3DFacetParticle;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DFacetShader = /** @class */ (function (_super) {
        __extends(Display3DFacetShader, _super);
        function Display3DFacetShader() {
            return _super.call(this) || this;
        }
        Display3DFacetShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "v2TexCoord");
        };
        Display3DFacetShader.prototype.getMat4Str = function (key) {
            //return key;
            return "vcmat[" + Display3DFacetShader.shader_mat4[key] + "]";
        };
        Display3DFacetShader.prototype.getVec4Str = function (key) {
            //return key;
            return "vcmat[" + Display3DFacetShader.shader_vec4[key][0] + "][" + Display3DFacetShader.shader_vec4[key][1] + "]";
        };
        Display3DFacetShader.getVcSize = function () {
            return 5;
        };
        Display3DFacetShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec4 v3Position;\n" +
                "attribute vec2 v2TexCoord;\n" +
                "uniform mat4 vcmat[" + Display3DFacetShader.getVcSize() + "];\n" + //所有vc值
                //"uniform mat4 viewMatrix3D;\n" +
                //"uniform mat4 camMatrix3D;\n" +
                // "uniform mat4 rotationMatrix3D;\n" +
                //"uniform mat4 posMatrix3D;\n" +
                //"uniform vec2 uvMove;\n" +
                "varying vec2 v0;\n" +
                "void main(void){\n" +
                "   v0 = v2TexCoord + vec2(" + this.getVec4Str("uvMove") + ".xy);\n" +
                "   gl_Position = " + this.getMat4Str("viewMatrix3D") + "  * " + this.getMat4Str("camMatrix3D") + " * "
                + this.getMat4Str("posMatrix3D") + " * " + this.getMat4Str("rotationMatrix3D") + " * v3Position;\n" +
                "}";
            return $str;
        };
        Display3DFacetShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D tex;\n" +
                "varying vec2 v0;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(tex, v0.xy);\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        Display3DFacetShader.Display3D_Facet_Shader = "Display3DFacetShader";
        Display3DFacetShader.shader_mat4 = { viewMatrix3D: 0, camMatrix3D: 1, rotationMatrix3D: 2, posMatrix3D: 3 };
        Display3DFacetShader.shader_vec4 = { uvMove: [4, 0] };
        return Display3DFacetShader;
    }(tl3d.Shader3D));
    tl3d.Display3DFacetShader = Display3DFacetShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleFacetData = /** @class */ (function (_super) {
        __extends(ParticleFacetData, _super);
        function ParticleFacetData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._isCycle = false; //是否循环
            return _this;
        }
        ParticleFacetData.prototype.setAllByteInfo = function ($byte) {
            this._maxAnimTime = $byte.readFloat();
            this._isCycle = $byte.readBoolean();
            this._lockx = $byte.readBoolean();
            this._locky = $byte.readBoolean();
            _super.prototype.setAllByteInfo.call(this, $byte);
            this.initVcData();
            this.uploadGpu();
        };
        ParticleFacetData.prototype.getParticle = function () {
            return new tl3d.Display3DFacetParticle;
        };
        ParticleFacetData.prototype.uploadGpu = function () {
            this.objData = new tl3d.ObjData;
            this.makeRectangleData(this._width, this._height, this._originWidthScale, this._originHeightScale, this._isUV, this._isU, this._isV, this._animLine, this._animRow);
        };
        ParticleFacetData.prototype.makeRectangleData = function (width, height, offsetX, offsetY, isUV, isU, isV, animLine, animRow) {
            if (offsetX === void 0) { offsetX = 0.5; }
            if (offsetY === void 0) { offsetY = 0.5; }
            if (isUV === void 0) { isUV = false; }
            if (isU === void 0) { isU = false; }
            if (isV === void 0) { isV = false; }
            if (animLine === void 0) { animLine = 1; }
            if (animRow === void 0) { animRow = 1; }
            var uvAry = new Array;
            var verterList = new Array;
            var ary = new Array;
            ary.push(new tl3d.Vector2D(0, 0));
            ary.push(new tl3d.Vector2D(0, 1 / animRow));
            ary.push(new tl3d.Vector2D(1 / animLine, 1 / animRow));
            ary.push(new tl3d.Vector2D(1 / animLine, 0));
            if (isU) {
                for (var i = 0; i < ary.length; i++) {
                    ary[i].x = -ary[i].x;
                }
            }
            if (isV) {
                for (var i = 0; i < ary.length; i++) {
                    ary[i].y = -ary[i].y;
                }
            }
            if (isUV) {
                ary.push(ary.shift());
            }
            for (var i = 0; i < ary.length; i++) {
                uvAry.push(ary[i].x, ary[i].y);
            }
            verterList.push(-offsetX * width, height - offsetY * height, 0);
            verterList.push(ary[0].x, ary[0].y);
            verterList.push(width - offsetX * width, height - offsetY * height, 0);
            verterList.push(ary[1].x, ary[1].y);
            verterList.push(width - offsetX * width, -offsetY * height, 0);
            verterList.push(ary[2].x, ary[2].y);
            verterList.push(-offsetX * width, -offsetY * height, 0);
            verterList.push(ary[3].x, ary[3].y);
            var indexs = new Array;
            indexs.push(0, 1, 2, 0, 2, 3);
            this.objData.stride = 5 * 4;
            this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(verterList);
            //this.objData.uvBuffer = Scene_data.context3D.uploadBuff3D(uvAry);
            this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(indexs);
            this.objData.treNum = indexs.length;
        };
        ParticleFacetData.prototype.initVcData = function () {
            this.vcmatData = new Float32Array(tl3d.Display3DFacetShader.getVcSize() * 16);
        };
        ParticleFacetData.prototype.setFloat32Vec = function (key, ary) {
            var idxary = tl3d.Display3DFacetShader.shader_vec4[key];
            var idx = idxary[0] * 16 + idxary[1] * 4;
            this.vcmatData.set(ary, idx);
        };
        ParticleFacetData.prototype.setFloat32Mat = function (key, ary) {
            var idx = tl3d.Display3DFacetShader.shader_mat4[key] * 16;
            this.vcmatData.set(ary, idx);
        };
        ParticleFacetData.prototype.regShader = function () {
            //var shader: Display3DFacetShader = new Display3DFacetShader();
            this.materialParam.shader = tl3d.ProgrmaManager.getInstance().getMaterialProgram(tl3d.Display3DFacetShader.Display3D_Facet_Shader, tl3d.Display3DFacetShader, this.materialParam.material);
            this.materialParam.program = this.materialParam.shader.program;
        };
        return ParticleFacetData;
    }(tl3d.ParticleData));
    tl3d.ParticleFacetData = ParticleFacetData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DFollowPartilce = /** @class */ (function (_super) {
        __extends(Display3DFollowPartilce, _super);
        function Display3DFollowPartilce() {
            var _this = _super.call(this) || this;
            _this.flag = 0;
            return _this;
        }
        Object.defineProperty(Display3DFollowPartilce.prototype, "followdata", {
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        Display3DFollowPartilce.prototype.creatData = function () {
            this.data = new tl3d.ParticleFollowData;
        };
        Display3DFollowPartilce.prototype.onCreated = function () {
            this.initBingMatrixAry();
        };
        // public setAllByteInfo($byte: ByteArray, version: number = 0): void {
        //     super.setAllByteInfo($byte, version);
        //     this.initBingMatrixAry();
        // }
        Display3DFollowPartilce.prototype.setVc = function () {
            _super.prototype.setVc.call(this);
            this.updateBind();
            // for (var i: number = 0; i < this.followdata._totalNum; i++) {
            //     Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "bindpos[" + i + "]", this._bindMatrixAry[i]);
            // }
            tl3d.Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "bindpos", this._bindMatrixAry);
        };
        Display3DFollowPartilce.prototype.initBingMatrixAry = function () {
            this._bindMatrixAry = new Float32Array(40 * 3);
            this._bindFlagAry = new Array;
            for (var i = 0; i < this.followdata._totalNum; i++) {
                //this._bindMatrixAry.push([0, 0, 0]);
                this._bindFlagAry.push(0);
            }
        };
        Display3DFollowPartilce.prototype.updateBind = function () {
            var time = this._time / tl3d.Scene_data.frameTime;
            for (var i = this.flag; i < this.followdata._totalNum; i++) {
                var temp = (time - i * this.followdata._shootSpeed) / this.followdata._life;
                if (temp >= this._bindFlagAry[i]) {
                    //   //console.log(this.bindVecter3d);
                    var flag = i * 3;
                    this._bindMatrixAry[flag] = this.bindVecter3d.x;
                    this._bindMatrixAry[flag + 1] = this.bindVecter3d.y;
                    this._bindMatrixAry[flag + 2] = this.bindVecter3d.z;
                    this._bindFlagAry[i]++;
                }
            }
        };
        Display3DFollowPartilce.prototype.updateMatrix = function () {
            if (!this.bindMatrix) {
                return;
            }
            this.modelMatrix.identity();
            if (!this.groupMatrix.isIdentity) {
                this.posMatrix.append(this.groupMatrix);
            }
            this.modelMatrix.append(this.posMatrix);
        };
        Display3DFollowPartilce.prototype.updateAllRotationMatrix = function () {
            this.followdata._allRotationMatrix.identity();
            this.followdata._allRotationMatrix.prependScale(this.followdata.overAllScale * this._scaleX * 0.1 * this.bindScale.x, this.followdata.overAllScale * this._scaleY * 0.1 * this.bindScale.y, this.followdata.overAllScale * this._scaleZ * 0.1 * this.bindScale.z);
            if (this.isInGroup) {
                this.followdata._allRotationMatrix.appendRotation(this.groupRotation.x, tl3d.Vector3D.X_AXIS);
                this.followdata._allRotationMatrix.appendRotation(this.groupRotation.y, tl3d.Vector3D.Y_AXIS);
                this.followdata._allRotationMatrix.appendRotation(this.groupRotation.z, tl3d.Vector3D.Z_AXIS);
            }
        };
        Display3DFollowPartilce.prototype.reset = function () {
            _super.prototype.reset.call(this);
            for (var i = 0; i < this.followdata._totalNum; i++) {
                this._bindMatrixAry[i * 3] = 0;
                this._bindMatrixAry[i * 3 + 1] = 0;
                this._bindMatrixAry[i * 3 + 2] = 0;
                this._bindFlagAry[i] = 0;
            }
        };
        Display3DFollowPartilce.prototype.updateWatchCaramMatrix = function () {
            this._rotationMatrix.identity();
            if (this.followdata.facez) {
                this._rotationMatrix.prependRotation(90, tl3d.Vector3D.X_AXIS);
            }
            else if (this.followdata._watchEye) {
                this._rotationMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationY, tl3d.Vector3D.Y_AXIS);
                this._rotationMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationX, tl3d.Vector3D.X_AXIS);
            }
        };
        return Display3DFollowPartilce;
    }(tl3d.Display3DBallPartilce));
    tl3d.Display3DFollowPartilce = Display3DFollowPartilce;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DFollowShader = /** @class */ (function (_super) {
        __extends(Display3DFollowShader, _super);
        function Display3DFollowShader() {
            return _super.call(this) || this;
        }
        Display3DFollowShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "vPosition");
            $context.bindAttribLocation(this.program, 1, "texcoord");
            $context.bindAttribLocation(this.program, 2, "basePos");
            $context.bindAttribLocation(this.program, 3, "speed");
            var needRotation = this.paramAry[3];
            if (needRotation) {
                $context.bindAttribLocation(this.program, 4, "rotation");
            }
            var hasRandomClolr = this.paramAry[1];
            if (hasRandomClolr) {
                $context.bindAttribLocation(this.program, 5, "color");
            }
        };
        //static shader_vec4 = {time:[0,0],scale:[1,1],scaleCtrl:[2,2],force:[3,3],worldPos:[4,0],camPos:[5,1],animCtrl:[6,2],uvCtrl:[7,3]};
        Display3DFollowShader.prototype.getMat4Str = function (key) {
            return "vcmat[" + tl3d.Display3DBallShader.shader_mat4[key] + "]";
        };
        Display3DFollowShader.prototype.getVec4Str = function (key) {
            return "vcmat[" + tl3d.Display3DBallShader.shader_vec4[key][0] + "][" + tl3d.Display3DBallShader.shader_vec4[key][1] + "]";
            //return  "vc[" + Display3DBallShader.shader_vec4[key][0] + "]";
            //return key;
        };
        Display3DFollowShader.getVcSize = function () {
            return 7;
        };
        Display3DFollowShader.prototype.getVertexShaderString = function () {
            var baseStr;
            var scaleStr;
            var rotationStr;
            var posStr;
            var addSpeedStr;
            var mulStr;
            var resultPosStr;
            var uvStr;
            var particleColorStr;
            var randomColorStr;
            var uvDefaultStr;
            var uvAnimStr;
            var uvSpeedStr;
            var randomColorStr;
            var particleColorStr;
            var defineBaseStr;
            var defineScaleStr;
            var defineRotaionStr;
            var defineAddSpeedStr;
            var defineMulStr;
            var defineUvAnimStr;
            var defineUvSpeedStr;
            var defineRandomColor;
            var defineParticleColor;
            defineBaseStr =
                "attribute vec4 vPosition;\n" +
                    "attribute vec3 texcoord;\n" + //uv坐标xy
                    "attribute vec4 basePos;\n" + //基础位置xyz，发射起始时间w
                    "attribute vec3 speed;\n" + //速度xyz
                    "uniform mat4 vcmat[" + tl3d.Display3DBallShader.getVcSize() + "];\n" + //所有vc值
                    "uniform vec3 bindpos[30];\n" +
                    //"uniform mat4 watheye;\n" +//面向视点矩阵
                    //"uniform mat4 viewMatrix3D;\n" +//模型矩阵
                    //"uniform mat4 modelMatrix;\n" +//模型矩阵
                    //"uniform mat4 camMatrix3D;\n" +//摄像机矩阵
                    //"uniform vec4 time;\n" +//当前时间x,自身加速度y,粒子生命z,是否循环w
                    "varying vec2 v0;\n";
            defineRandomColor =
                "attribute vec4 color;\n" + //随机颜色
                    "varying vec4 v2;\n"; //随机颜色
            defineScaleStr = "";
            //"uniform vec4 scale;\n" +//缩放x，抖动周期y，抖动振幅z
            //"uniform vec4 scaleCtrl;\n"//宽度不变，高度不变，最大比例，最小比例
            defineRotaionStr =
                "attribute vec2 rotation;\n"; //基础旋转x ， 旋转速度y
            defineAddSpeedStr = "";
            //"uniform vec3 force;\n";//外力x，外力y，外力z
            defineMulStr = "";
            //"uniform mat4 rotationMatrix;\n" +//旋转矩阵
            //"uniform vec3 worldPos;\n" +//世界中的位置
            //"uniform vec3 camPos;\n"//世界中的位置
            defineUvAnimStr = "";
            //"uniform vec3 animCtrl;\n"//动画行数x，动画列数，动画间隔
            defineUvSpeedStr = "";
            //"uniform vec2 uvCtrl;\n"//u滚动速度，v滚动速度
            defineParticleColor =
                "varying vec2 v1;\n"; //粒子颜色坐标
            baseStr =
                "float ctime = " + this.getVec4Str("time") + ".x - basePos.w;\n" + //计算当前时间
                    "if (" + this.getVec4Str("time") + ".w > 0.0 && ctime >= 0.0) {\n" +
                    "    ctime = fract(ctime / " + this.getVec4Str("time") + ".z) * " + this.getVec4Str("time") + ".z;\n" +
                    "}\n" +
                    "vec4 pos = vPosition;\n"; //自身位置
            scaleStr =
                "float stime = ctime - " + this.getVec4Str("scale") + ".w;\n" +
                    "stime = max(stime,0.0);\n" +
                    "float sf = " + this.getVec4Str("scale") + ".x * stime;\n" +
                    "if (" + this.getVec4Str("scale") + ".y != 0.0 && " + this.getVec4Str("scale") + ".z != 0.0) {\n" +
                    "    sf += sin(" + this.getVec4Str("scale") + ".y * stime) * " + this.getVec4Str("scale") + ".z;\n" +
                    "}\n" +
                    "if (sf > " + this.getVec4Str("scaleCtrl") + ".z) {\n" +
                    "    sf = " + this.getVec4Str("scaleCtrl") + ".z;\n" +
                    "} else if (sf < " + this.getVec4Str("scaleCtrl") + ".w) {\n" +
                    "    sf = " + this.getVec4Str("scaleCtrl") + ".w;\n" +
                    "}\n" +
                    "vec2 sv2 = vec2(" + this.getVec4Str("scaleCtrl") + ".x * sf, " + this.getVec4Str("scaleCtrl") + ".y * sf);\n" +
                    "sv2 = sv2 + 1.0;\n" +
                    "pos.x *= sv2.x;\n" +
                    "pos.y *= sv2.y;\n";
            rotationStr =
                "float angle = rotation.x + rotation.y * ctime;\n" +
                    "vec4 np = vec4(sin(angle), cos(angle), 0, 0);\n" +
                    "np.z = np.x * pos.y + np.y * pos.x;\n" + //b.x = sin_z * a.y + cos_z * a.x;
                    "np.w = np.y * pos.y - np.x * pos.x;\n" + //b.y = cos_z * a.y - sin_z * a.x;
                    "pos.xy = np.zw;\n";
            posStr =
                "vec3 addPos = speed * ctime;\n" + //运动部分
                    "vec3 uspeed = vec3(0,0,0);\n" +
                    "if (ctime < 0.0 || ctime >= " + this.getVec4Str("time") + ".z) {\n" + //根据时间控制粒子是否显示
                    "    addPos.y = addPos.y + 100000.0;\n" +
                    "}\n";
            addSpeedStr =
                "if(" + this.getVec4Str("time") + ".y != 0.0 && length(speed) != 0.0) {\n" +
                    "    uspeed = vec3(speed.x, speed.y, speed.z);\n" +
                    "    uspeed = normalize(uspeed);\n" +
                    "    uspeed = uspeed * " + this.getVec4Str("time") + ".y;\n" +
                    "    uspeed.xyz = uspeed.xyz + " + this.getVec4Str("force") + ".xyz;\n" +
                    "} else {\n" +
                    "    uspeed = vec3(" + this.getVec4Str("force") + ".x, " + this.getVec4Str("force") + ".y, " + this.getVec4Str("force") + ".z);\n" +
                    "}\n" +
                    "addPos.xyz = addPos.xyz + uspeed.xyz * ctime * ctime;\n";
            mulStr =
                "uspeed = speed + uspeed * ctime * 2.0;\n" + //当前速度方向
                    "uspeed = normalize(uspeed);\n" +
                    "vec4 tempMul = " + this.getMat4Str("rotationMatrix") + " * vec4(uspeed,1.0);\n" +
                    "uspeed.xyz = tempMul.xyz;\n" +
                    "uspeed = normalize(uspeed);\n" +
                    "vec3 cPos = addPos;\n" + //v(视点-位置)
                    "tempMul = " + this.getMat4Str("rotationMatrix") + " * vec4(cPos,1.0);\n" +
                    "cPos.xyz = tempMul.xyz; \n" +
                    "cPos.xyz = " + this.getVec4Str("worldPos") + ".xyz + cPos.xyz;\n" +
                    "cPos.xyz = " + this.getVec4Str("camPos") + ".xyz - cPos.xyz;\n" +
                    "cPos = normalize(cPos);\n" +
                    "cPos = cross(uspeed, cPos);\n" + //法线
                    "cPos = normalize(cPos);\n" +
                    "uspeed = uspeed * pos.x;\n" +
                    "cPos = cPos * pos.y;\n" +
                    "pos.xyz = uspeed.xyz + cPos.xyz;\n";
            resultPosStr =
                "pos = " + this.getMat4Str("watheye") + " * pos;\n" + //控制是否面向视点
                    "pos.xyz = pos.xyz + basePos.xyz + addPos.xyz;\n" +
                    "pos = " + this.getMat4Str("modelMatrix") + " * pos;\n" +
                    "pos.xyz = pos.xyz + bindpos[int(texcoord.z)].xyz;\n" +
                    "gl_Position = " + this.getMat4Str("viewMatrix3D") + " * " + this.getMat4Str("camMatrix3D") + " * pos;\n";
            uvDefaultStr =
                "v0 = vec2(texcoord.x,texcoord.y);\n";
            uvAnimStr =
                "vec2 uv = vec2(texcoord.x,texcoord.y);\n" +
                    "float animframe = floor(ctime / " + this.getVec4Str("animCtrl") + ".z);\n" +
                    "animframe = animframe / " + this.getVec4Str("animCtrl") + ".x;\n" +
                    "uv.x += animframe;\n" +
                    "animframe = floor(animframe);\n" +
                    "uv.y += animframe / " + this.getVec4Str("animCtrl") + ".y;\n" +
                    "v0.xy = uv.xy;\n";
            uvSpeedStr =
                "vec2 uv = vec2(" + this.getVec4Str("uvCtrl") + ".x," + this.getVec4Str("uvCtrl") + ".y);\n" +
                    "uv.xy = uv.xy * ctime + texcoord.xy;\n" +
                    "v0.xy = uv.xy;\n";
            randomColorStr =
                "v2 = color;\n";
            particleColorStr =
                "v1 = vec2(ctime/" + this.getVec4Str("time") + ".z,1.0);\n";
            //this.paramAry
            var hasParticle = this.paramAry[0];
            var hasRandomClolr = this.paramAry[1];
            var isMul = this.paramAry[2];
            var needRotation = this.paramAry[3];
            var needScale = this.paramAry[4];
            var needAddSpeed = this.paramAry[5];
            var uvType = this.paramAry[6];
            var str = "";
            var defineStr = "";
            str += baseStr;
            defineStr += defineBaseStr;
            if (needScale) {
                str += scaleStr;
                defineStr += defineScaleStr;
            }
            if (needRotation) {
                str += rotationStr;
                defineStr += defineRotaionStr;
            }
            str += posStr;
            if (needAddSpeed) {
                str += addSpeedStr;
                defineStr += defineAddSpeedStr;
            }
            if (isMul) {
                str += mulStr;
                defineStr += defineMulStr;
            }
            str += resultPosStr;
            if (uvType == 1) {
                str += uvAnimStr;
                defineStr += defineUvAnimStr;
            }
            else if (uvType == 2) {
                str += uvSpeedStr;
                defineStr += defineUvSpeedStr;
            }
            else {
                str += uvDefaultStr;
            }
            if (hasRandomClolr) {
                str += randomColorStr;
                defineStr += defineRandomColor;
            }
            if (hasParticle) {
                str += particleColorStr;
                defineStr += defineParticleColor;
            }
            //str += uvStr
            //str += particleColorStr
            //str += randomColorStr
            var resultAllStr = defineStr + "void main(){\n" + str + "}";
            ////console.log(resultAllStr);
            return resultAllStr;
        };
        Display3DFollowShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D tex;\n" +
                "varying vec2 v0;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(tex, v0.xy);\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        Display3DFollowShader.Display3D_Follow_Shader = "Display3DFollowShader";
        Display3DFollowShader.shader_mat4 = { viewMatrix3D: 0, camMatrix3D: 1, modelMatrix: 2, watheye: 3, rotationMatrix: 4 };
        Display3DFollowShader.shader_vec4 = { time: [5, 0], scale: [5, 1], scaleCtrl: [5, 2], force: [5, 3], worldPos: [6, 0], camPos: [6, 1], animCtrl: [6, 2], uvCtrl: [6, 3] };
        return Display3DFollowShader;
    }(tl3d.Shader3D));
    tl3d.Display3DFollowShader = Display3DFollowShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleFollowData = /** @class */ (function (_super) {
        __extends(ParticleFollowData, _super);
        function ParticleFollowData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ParticleFollowData.prototype.getParticle = function () {
            return new tl3d.Display3DFollowPartilce;
        };
        ParticleFollowData.prototype.setAllByteInfo = function ($byte) {
            _super.prototype.setAllByteInfo.call(this, $byte);
            //this.initBingMatrixAry();
            this.uploadGpu();
        };
        ParticleFollowData.prototype.regShader = function () {
            if (!this.materialParam) {
                return;
            }
            var shaderParameAry = this.getShaderParam();
            //var shader: Display3DFollowShader = new Display3DFollowShader()
            this.materialParam.shader = tl3d.ProgrmaManager.getInstance().getMaterialProgram(tl3d.Display3DFollowShader.Display3D_Follow_Shader, tl3d.Display3DFollowShader, this.materialParam.material, shaderParameAry);
            this.materialParam.program = this.materialParam.shader.program;
        };
        return ParticleFollowData;
    }(tl3d.ParticleBallData));
    tl3d.ParticleFollowData = ParticleFollowData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DFollowLocusPartilce = /** @class */ (function (_super) {
        __extends(Display3DFollowLocusPartilce, _super);
        function Display3DFollowLocusPartilce() {
            var _this = _super.call(this) || this;
            _this.flag = 0;
            //this.objData = new ParticleGpuData();
            _this._caramPosVec = [0, 0, 0];
            return _this;
        }
        Object.defineProperty(Display3DFollowLocusPartilce.prototype, "followlocusdata", {
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        Display3DFollowLocusPartilce.prototype.creatData = function () {
            this.data = new tl3d.ParticleFollowLocusData;
        };
        // public setAllByteInfo($byte: ByteArray, version: number = 0): void {
        //     super.setAllByteInfo($byte, version);
        //     this.initBindMatrixAry();
        // }
        Display3DFollowLocusPartilce.prototype.onCreated = function () {
            this.initBindMatrixAry();
        };
        Display3DFollowLocusPartilce.prototype.initBindMatrixAry = function () {
            this._bindPosAry = new Array;
            this._gpuVc = new Float32Array(this.followlocusdata._fenduanshu * 6);
            for (var i = 0; i <= this.followlocusdata._fenduanshu; i++) {
                this._bindPosAry.push([0, 0, 5 * i]);
                this._bindPosAry.push([0, 0, 1]);
            }
        };
        Display3DFollowLocusPartilce.prototype.setVa = function () {
            var tf = tl3d.Scene_data.context3D.pushVa(this.data.objData.vertexBuffer);
            if (!tf) {
                tl3d.Scene_data.context3D.setVaOffset(0, 3, this.data.objData.stride, 0);
                tl3d.Scene_data.context3D.setVaOffset(1, 2, this.data.objData.stride, 12);
            }
            // Scene_data.context3D.setVa(0, 3, this.data.objData.vertexBuffer);
            // Scene_data.context3D.setVa(1, 2, this.data.objData.uvBuffer);
            this.setMaterialTexture();
            tl3d.Scene_data.context3D.drawCall(this.data.objData.indexBuffer, this.data.objData.treNum);
        };
        Display3DFollowLocusPartilce.prototype.setVc = function () {
            this.updateMatrix();
            this.updateBind();
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "viewMatrix3D", Scene_data.viewMatrx3D.m);
            this.data.vcmatData.set(tl3d.Scene_data.viewMatrx3D.m, 0);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            this.data.vcmatData.set(tl3d.Scene_data.cam3D.cameraMatrix.m, 16);
            this._caramPosVec[0] = tl3d.Scene_data.cam3D.x;
            this._caramPosVec[1] = tl3d.Scene_data.cam3D.y;
            this._caramPosVec[2] = tl3d.Scene_data.cam3D.z;
            //Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "camPos", this._caramPosVec);
            this.data.vcmatData.set(this._caramPosVec, 32);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "vcmat", this.data.vcmatData);
            this.setBindPosVc();
            this.setMaterialVc();
        };
        Display3DFollowLocusPartilce.prototype.setBindPosVc = function () {
            for (var i = 0; i < this._bindPosAry.length; i++) {
                tl3d.Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "bindpos[" + i + "]", this._bindPosAry[i]);
            }
        };
        Display3DFollowLocusPartilce.prototype.reset = function () {
            this.resetPos();
            _super.prototype.reset.call(this);
        };
        Display3DFollowLocusPartilce.prototype.updateMatrix = function () {
            this.modelMatrix.identity();
            this.modelMatrix.prepend(this.posMatrix);
        };
        Display3DFollowLocusPartilce.prototype.resetPos = function () {
            for (var i = 0; i < this._bindPosAry.length; i += 2) {
                this._bindPosAry[i][0] = this.bindVecter3d.x;
                this._bindPosAry[i][1] = this.bindVecter3d.y;
                this._bindPosAry[i][2] = this.bindVecter3d.z;
            }
            this.flag = tl3d.TimeUtil.getTimer();
        };
        Display3DFollowLocusPartilce.prototype.updateBind = function () {
            var ctime = tl3d.TimeUtil.getTimer();
            if ((ctime - this.flag) >= Display3DFollowLocusPartilce.waitCdTime) {
                var normal = this._bindPosAry.pop();
                var pos = this._bindPosAry.pop();
                pos[0] = this.bindVecter3d.x;
                pos[1] = this.bindVecter3d.y;
                pos[2] = this.bindVecter3d.z;
                var pos0 = this._bindPosAry[0];
                var normal0 = this._bindPosAry[1];
                var v3d = new tl3d.Vector3D(pos[0] - pos0[0], pos[1] - pos0[1], pos[2] - pos0[2]);
                v3d.normalize();
                normal0[0] = v3d.x;
                normal[0] = v3d.x;
                normal0[1] = v3d.y;
                normal[1] = v3d.y;
                normal0[2] = v3d.z;
                normal[2] = v3d.z;
                this._bindPosAry.unshift(normal);
                this._bindPosAry.unshift(pos);
                this.flag = ctime;
            }
        };
        Display3DFollowLocusPartilce.waitCdTime = 35;
        return Display3DFollowLocusPartilce;
    }(tl3d.Display3DParticle));
    tl3d.Display3DFollowLocusPartilce = Display3DFollowLocusPartilce;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DFollowLocusShader = /** @class */ (function (_super) {
        __extends(Display3DFollowLocusShader, _super);
        function Display3DFollowLocusShader() {
            return _super.call(this) || this;
        }
        Display3DFollowLocusShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "v2TexCoord");
        };
        Display3DFollowLocusShader.prototype.getMat4Str = function (key) {
            //return key;
            return "vcmat[" + Display3DFollowLocusShader.shader_mat4[key] + "]";
        };
        Display3DFollowLocusShader.prototype.getVec4Str = function (key) {
            //return key;
            return "vcmat[" + Display3DFollowLocusShader.shader_vec4[key][0] + "][" + Display3DFollowLocusShader.shader_vec4[key][1] + "]";
        };
        Display3DFollowLocusShader.getVcSize = function () {
            return 3;
        };
        Display3DFollowLocusShader.prototype.getVertexShaderString = function () {
            var defineBaseStr = "attribute vec3 v3Position;\n" +
                "attribute vec2 v2TexCoord;\n" +
                "uniform mat4 vcmat[" + tl3d.Display3DFacetShader.getVcSize() + "];\n" + //所有vc值
                // "uniform mat4 viewMatrix3D;\n" +
                // "uniform mat4 camMatrix3D;\n" +
                // "uniform vec3 camPos;\n" +
                "uniform vec3 bindpos[30];\n" +
                "varying vec2 v0;\n";
            var watchPosStr = "   vec3 cpos = bindpos[int(v3Position.x)];\n" +
                "   vec3 mulPos = normalize(vec3(" + this.getVec4Str("camPos") + ".xyz) - cpos);\n" +
                "   vec3 normals = bindpos[int(v3Position.y)];\n" +
                "   mulPos = cross(mulPos, normals);\n" +
                "   mulPos = normalize(mulPos);\n" +
                "   mulPos *= v3Position.z;\n" +
                "   cpos += mulPos;\n" +
                "   gl_Position = " + this.getMat4Str("viewMatrix3D") + "  * " + this.getMat4Str("camMatrix3D") + " * vec4(cpos,1.0);\n";
            var uvStr = "v0 = v2TexCoord;\n";
            var resultAllStr = defineBaseStr + "void main(){\n" + watchPosStr + uvStr + "}";
            return resultAllStr;
        };
        Display3DFollowLocusShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D tex;\n" +
                "varying vec2 v0;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(tex, v0.xy);\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        Display3DFollowLocusShader.Display3D_FollowLocus_Shader = "Display3DFollowLocusShader";
        Display3DFollowLocusShader.shader_mat4 = { viewMatrix3D: 0, camMatrix3D: 1 };
        Display3DFollowLocusShader.shader_vec4 = { camPos: [2, 0] };
        return Display3DFollowLocusShader;
    }(tl3d.Shader3D));
    tl3d.Display3DFollowLocusShader = Display3DFollowLocusShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleFollowLocusData = /** @class */ (function (_super) {
        __extends(ParticleFollowLocusData, _super);
        function ParticleFollowLocusData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ParticleFollowLocusData.prototype.getParticle = function () {
            return new tl3d.Display3DFollowLocusPartilce;
        };
        ParticleFollowLocusData.prototype.setAllByteInfo = function ($byte) {
            this._fenduanshu = $byte.readFloat();
            _super.prototype.setAllByteInfo.call(this, $byte);
            //this.initBindMatrixAry();
            this.uploadGpu();
            this.initVcData();
        };
        ParticleFollowLocusData.prototype.uploadGpu = function () {
            this.objData = new tl3d.ObjData;
            this.objData.vertices = new Array;
            this.objData.uvs = new Array;
            this.objData.indexs = new Array;
            for (var i = 0; i <= this._fenduanshu; i++) {
                var pA = new tl3d.Vector2D(i / this._fenduanshu, 0);
                var pB = new tl3d.Vector2D(i / this._fenduanshu, 1);
                pA.scaleBy(0.9);
                pB.scaleBy(0.9);
                if (this._isU) {
                    pA.x = -pA.x;
                    pB.x = -pB.x;
                }
                if (this._isV) {
                    pA.y = -pA.y;
                    pB.y = -pB.y;
                }
                var vcIndex = i * 2;
                this.objData.vertices.push(vcIndex, vcIndex + 1, -this._originWidthScale * this._width / 100);
                if (this._isUV) {
                    this.objData.vertices.push(pA.y, pA.x);
                }
                else {
                    this.objData.vertices.push(pA.x, pA.y);
                }
                this.objData.vertices.push(vcIndex, vcIndex + 1, (1 - this._originWidthScale) * this._width / 100);
                if (this._isUV) {
                    this.objData.vertices.push(pB.y, pB.x);
                }
                else {
                    this.objData.vertices.push(pB.x, pB.y);
                }
                // if (this._isUV) {
                //     this.objData.uvs.push(pA.y, pA.x);
                //     this.objData.uvs.push(pB.y, pB.x);
                // } else {
                //     this.objData.uvs.push(pA.x, pA.y);
                //     this.objData.uvs.push(pB.x, pB.y);
                // }
            }
            for (i = 0; i < this._fenduanshu; i++) {
                this.objData.indexs.push(0 + 2 * i, 1 + 2 * i, 2 + 2 * i, 1 + 2 * i, 3 + 2 * i, 2 + 2 * i);
            }
            this.pushToGpu();
        };
        ParticleFollowLocusData.prototype.pushToGpu = function () {
            this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
            //this.objData.uvBuffer = Scene_data.context3D.uploadBuff3D(this.objData.uvs);
            this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            this.objData.stride = 5 * 4;
            this.objData.treNum = this.objData.indexs.length;
        };
        ParticleFollowLocusData.prototype.initVcData = function () {
            this.vcmatData = new Float32Array(tl3d.Display3DFollowLocusShader.getVcSize() * 16);
        };
        ParticleFollowLocusData.prototype.regShader = function () {
            if (!this.materialParam) {
                return;
            }
            var shader = new tl3d.Display3DFollowLocusShader();
            this.materialParam.shader = tl3d.ProgrmaManager.getInstance().getMaterialProgram(tl3d.Display3DFollowLocusShader.Display3D_FollowLocus_Shader, tl3d.Display3DFollowLocusShader, this.materialParam.material);
            this.materialParam.program = this.materialParam.shader.program;
        };
        return ParticleFollowLocusData;
    }(tl3d.ParticleData));
    tl3d.ParticleFollowLocusData = ParticleFollowLocusData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DLocusPartilce = /** @class */ (function (_super) {
        __extends(Display3DLocusPartilce, _super);
        function Display3DLocusPartilce() {
            return _super.call(this) || this;
            //this.objData = new ParticleGpuData();
        }
        Object.defineProperty(Display3DLocusPartilce.prototype, "locusdata", {
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        Display3DLocusPartilce.prototype.creatData = function () {
            this.data = new tl3d.ParticleLocusData;
        };
        Display3DLocusPartilce.prototype.setVa = function () {
            var tf = tl3d.Scene_data.context3D.pushVa(this.data.objData.vertexBuffer);
            if (!tf) {
                tl3d.Scene_data.context3D.setVaOffset(0, 3, this.data.objData.stride, 0);
                tl3d.Scene_data.context3D.setVaOffset(1, 2, this.data.objData.stride, 28);
                if (this.data._watchEye) {
                    tl3d.Scene_data.context3D.setVaOffset(2, 4, this.data.objData.stride, 12);
                }
            }
            // Scene_data.context3D.setVa(0, 3, this.data.objData.vertexBuffer);
            // Scene_data.context3D.setVa(1, 2, this.data.objData.uvBuffer);
            // if (this.data._watchEye){
            //     Scene_data.context3D.setVa(2, 4, this.data.objData.normalsBuffer);
            // }
            this.setMaterialTexture();
            tl3d.Scene_data.context3D.drawCall(this.data.objData.indexBuffer, this.data.objData.treNum);
        };
        Display3DLocusPartilce.prototype.setVc = function () {
            this.updateUV();
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "viewMatrix3D", Scene_data.viewMatrx3D.m);
            //this.data.setFloat32Mat("viewMatrix3D", Scene_data.viewMatrx3D.m);//0
            this.data.vcmatData.set(tl3d.Scene_data.viewMatrx3D.m, 0);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            //this.data.setFloat32Mat("camMatrix3D", Scene_data.cam3D.cameraMatrix.m);//16
            this.data.vcmatData.set(tl3d.Scene_data.cam3D.cameraMatrix.m, 16);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "posMatrix3D", this.modelMatrix.m);
            //this.data.setFloat32Mat("posMatrix3D", this.modelMatrix.m);//32
            this.data.vcmatData.set(this.modelMatrix.m, 32);
            //Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "uvMove", this.locusdata._resultUvVec);
            //this.data.setFloat32Vec("uvMove", this.locusdata._resultUvVec);//48
            this.data.vcmatData.set(this.locusdata._resultUvVec, 48);
            if (this.data._watchEye) {
                this.locusdata._caramPosVec[0] = tl3d.Scene_data.cam3D.x;
                this.locusdata._caramPosVec[1] = tl3d.Scene_data.cam3D.y;
                this.locusdata._caramPosVec[2] = tl3d.Scene_data.cam3D.z;
                //Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "camPos", this.locusdata._caramPosVec);
                //this.data.setFloat32Vec("camPos", this.locusdata._caramPosVec);//52
                this.data.vcmatData.set(this.locusdata._caramPosVec, 52);
            }
            if (this.locusdata._changUv) {
                //Scene_data.context3D.setVc3fv(this.data.materialParam.shader, "isUv", this.locusdata._uvVec);
                this.data.setFloat32Vec("isUv", this.locusdata._uvVec); //56
            }
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "vcmat", this.data.vcmatData);
            this.setMaterialVc();
        };
        Display3DLocusPartilce.prototype.updateUV = function () {
            var $nowTime = this._time / tl3d.Scene_data.frameTime;
            var $lifeRoundNum = (this.data._life / 100);
            var $moveUv = this.locusdata._speed * $nowTime / this.locusdata._density / 10;
            if (this.locusdata._isEnd) {
                $moveUv = Math.min(1, $moveUv);
            }
            if (this.locusdata._isLoop) {
                if (this.locusdata._life) {
                    $moveUv = $moveUv % ($lifeRoundNum + 1);
                }
                else {
                    $moveUv = $moveUv % 1;
                }
            }
            this.locusdata._resultUvVec[0] = $moveUv;
        };
        return Display3DLocusPartilce;
    }(tl3d.Display3DParticle));
    tl3d.Display3DLocusPartilce = Display3DLocusPartilce;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DLocusShader = /** @class */ (function (_super) {
        __extends(Display3DLocusShader, _super);
        function Display3DLocusShader() {
            return _super.call(this) || this;
        }
        Display3DLocusShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "v2TexCoord");
            if (this.paramAry[0]) {
                $context.bindAttribLocation(this.program, 2, "v3Normal");
            }
        };
        Display3DLocusShader.prototype.getMat4Str = function (key) {
            //return key;
            return "vcmat[" + Display3DLocusShader.shader_mat4[key] + "]";
        };
        Display3DLocusShader.prototype.getVec4Str = function (key) {
            //return key;
            return "vcmat[" + Display3DLocusShader.shader_vec4[key][0] + "][" + Display3DLocusShader.shader_vec4[key][1] + "]";
        };
        Display3DLocusShader.getVcSize = function () {
            return 4;
        };
        Display3DLocusShader.prototype.getVertexShaderString = function () {
            var defineBaseStr = "attribute vec4 v3Position;\n" +
                "attribute vec2 v2TexCoord;\n" +
                "uniform mat4 vcmat[" + tl3d.Display3DFacetShader.getVcSize() + "];\n" + //所有vc值
                //"uniform mat4 viewMatrix3D;\n" +
                //"uniform mat4 camMatrix3D;\n" +
                //"uniform mat4 posMatrix3D;\n" +
                // "uniform vec3 uvMove;\n" +
                "varying vec2 v0;\n" +
                "varying vec4 v2;\n";
            var defineWachtStr = "attribute vec4 v3Normal;\n"; // +
            //"uniform vec3 camPos;\n";
            var defineUvStr = "";
            //"uniform vec3 isUv;\n";
            var defineParticleColor = "varying vec2 v1;\n";
            var baseStr = "   vec2 tempv0 = v2TexCoord;\n" +
                "   tempv0.x -= " + this.getVec4Str("uvMove") + ".x;\n";
            var particleColorStr = "   v1 = v2TexCoord;\n";
            var baseUvStr = "   v0 = tempv0;\n";
            var uvStr = "   tempv0.xy *= " + this.getVec4Str("isUv") + ".xy;\n" +
                "   if(" + this.getVec4Str("isUv") + ".z >= 0.0){\n" +
                "   vec2 tempv1 = tempv0;\n" +
                "   tempv0.y = tempv1.x;\n" +
                "   tempv0.x = tempv1.y;}\n" +
                "   v0 = tempv0;\n";
            var killStr = "   float alpha = tempv0.x/" + this.getVec4Str("uvMove") + ".y;\n" +
                "   alpha = 1.0 - clamp(abs(alpha),0.0,1.0);\n" +
                "   float kill = -tempv0.x;\n" +
                "   kill *= tempv0.x - " + this.getVec4Str("uvMove") + ".z;\n" +
                "   v2 = vec4(kill,0.0,0.0,alpha);\n";
            var posStr = "   gl_Position = " + this.getMat4Str("viewMatrix3D") + "  * " + this.getMat4Str("camMatrix3D") + " * " + this.getMat4Str("posMatrix3D") + " * v3Position;\n";
            var watchPosStr = "   vec4 tempPos = " + this.getMat4Str("posMatrix3D") + " * v3Position;\n" +
                "   vec3 mulPos = vec3(tempPos.x,tempPos.y,tempPos.z);\n" +
                "   vec3 normals = vec3(v3Normal.x,v3Normal.y,v3Normal.z);\n" +
                "   mulPos = normalize(vec3(" + this.getVec4Str("camPos") + ".xyz) - mulPos);\n" +
                "   mulPos = cross(mulPos, normals);\n" +
                "   mulPos = normalize(mulPos);\n" +
                "   mulPos *= v3Normal.w;\n" +
                "   tempPos.xyz = mulPos.xyz + v3Position.xyz;\n" +
                "   gl_Position = " + this.getMat4Str("viewMatrix3D") + "  * " + this.getMat4Str("camMatrix3D") + " * " + this.getMat4Str("posMatrix3D") + " * tempPos;\n";
            var isWatchEye = this.paramAry[0];
            var isUV = this.paramAry[1];
            var hasParticleColor = this.paramAry[2];
            var defineStr = defineBaseStr;
            if (isWatchEye) {
                defineStr += defineWachtStr;
            }
            if (isUV) {
                defineStr += defineUvStr;
            }
            if (hasParticleColor) {
                defineStr += defineParticleColor;
            }
            var mainStr = baseStr + killStr;
            if (hasParticleColor) {
                mainStr += particleColorStr;
            }
            if (isUV) {
                mainStr += uvStr;
            }
            else {
                mainStr += baseUvStr;
            }
            if (isWatchEye) {
                mainStr += watchPosStr;
            }
            else {
                mainStr += posStr;
            }
            var resultStr = defineStr + "void main(void){\n" + mainStr + "}";
            return resultStr;
        };
        Display3DLocusShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D tex;\n" +
                "varying vec2 v0;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(tex, v0.xy);\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        Display3DLocusShader.Display3D_Locus_Shader = "Display3DLocusShader";
        Display3DLocusShader.shader_mat4 = { viewMatrix3D: 0, camMatrix3D: 1, posMatrix3D: 2 };
        Display3DLocusShader.shader_vec4 = { uvMove: [3, 0], camPos: [3, 1], isUv: [3, 2] };
        return Display3DLocusShader;
    }(tl3d.Shader3D));
    tl3d.Display3DLocusShader = Display3DLocusShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleLocusData = /** @class */ (function (_super) {
        __extends(ParticleLocusData, _super);
        function ParticleLocusData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._speed = 1; //粒子运动数字
            _this._isLoop = false; //是否循环
            return _this;
        }
        ParticleLocusData.prototype.getParticle = function () {
            return new tl3d.Display3DLocusPartilce;
        };
        ParticleLocusData.prototype.setAllByteInfo = function ($byte) {
            this._isLoop = $byte.readBoolean(); //b
            this._speed = $byte.readFloat(); //f
            this._density = $byte.readFloat(); //f
            this._isEnd = $byte.readBoolean(); //b
            this.objData = new tl3d.ObjData;
            var vLen = $byte.getInt();
            var dataWidth = 9;
            var len = vLen * dataWidth * 4;
            var arybuff = new ArrayBuffer(len);
            var data = new DataView(arybuff);
            tl3d.BaseRes.readBytes2ArrayBuffer($byte, data, 3, 0, dataWidth, 4); //vertices
            tl3d.BaseRes.readBytes2ArrayBuffer($byte, data, 4, 3, dataWidth, 4); //normal
            tl3d.BaseRes.readBytes2ArrayBuffer($byte, data, 2, 7, dataWidth, 4); //uv
            // var vLen: number = $byte.readInt();
            // for (var i: number = 0; i < vLen; i++) {
            //     this.objData.vertices.push($byte.readFloat())
            // }
            // var nLen: number = $byte.readInt();
            // for (var i: number = 0; i < nLen; i++) {
            //     this.objData.normals.push($byte.readFloat())
            // }
            // var uLen: number = $byte.readInt();
            // for (var j: number = 0; j < uLen; j++) {
            //     this.objData.uvs.push($byte.readFloat())
            // }
            var iLen = $byte.readInt();
            for (var k = 0; k < iLen; k++) {
                this.objData.indexs.push($byte.readInt());
            }
            this.objData.stride = dataWidth * 4;
            _super.prototype.setAllByteInfo.call(this, $byte);
            this.initUV();
            if (this._watchEye) {
                this._caramPosVec = [0, 0, 0];
            }
            this._uvVec = [this._isU ? -1 : 1, this._isV ? -1 : 1, this._isUV ? 1 : -1];
            // this.uploadGpu();
            this.initVcData();
            this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3DArrayBuffer(arybuff);
            this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            this.objData.treNum = this.objData.indexs.length;
        };
        ParticleLocusData.prototype.initUV = function () {
            this._resultUvVec = new Array(3);
            var $nowTime = 0;
            var $lifeRoundNum = (this._life / 100);
            var $moveUv = this._speed * $nowTime / this._density / 10;
            if (this._isEnd) {
                $moveUv = Math.min(1, $moveUv);
            }
            var $fcVector;
            if (this._isLoop) {
                if (this._life) {
                    $moveUv = $moveUv % ($lifeRoundNum + 1);
                    $fcVector = new tl3d.Vector3D($moveUv, $lifeRoundNum, -$lifeRoundNum);
                }
                else {
                    $moveUv = $moveUv % 1;
                    $fcVector = new tl3d.Vector3D($moveUv + 1, 99, -2);
                }
            }
            else {
                if (this._life) {
                    $fcVector = new tl3d.Vector3D($moveUv, $lifeRoundNum, -1);
                }
                else {
                    $fcVector = new tl3d.Vector3D($moveUv, 99, -1);
                }
            }
            this._resultUvVec[0] = $fcVector.x;
            this._resultUvVec[1] = $fcVector.y;
            this._resultUvVec[2] = $fcVector.z;
        };
        ParticleLocusData.prototype.uploadGpu = function () {
            this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
            this.objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.uvs);
            if (this._watchEye) {
                this.objData.normalsBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.normals);
            }
            this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            this.objData.treNum = this.objData.indexs.length;
        };
        ParticleLocusData.prototype.regShader = function () {
            if (!this.materialParam) {
                return;
            }
            var isWatchEye = this._watchEye ? 1 : 0;
            var changeUv = 0;
            var hasParticleColor = this.materialParam.material.hasParticleColor;
            if (this._isU || this._isV || this._isUV) {
                changeUv = 1;
                this._changUv = true;
            }
            else {
                this._changUv = false;
            }
            var shaderParameAry;
            shaderParameAry = [isWatchEye, changeUv, hasParticleColor ? 1 : 0];
            //var shader: Display3DLocusShader = new Display3DLocusShader();
            this.materialParam.shader = tl3d.ProgrmaManager.getInstance().getMaterialProgram(tl3d.Display3DLocusShader.Display3D_Locus_Shader, tl3d.Display3DLocusShader, this.materialParam.material, shaderParameAry);
            this.materialParam.program = this.materialParam.shader.program;
        };
        ParticleLocusData.prototype.initVcData = function () {
            this.vcmatData = new Float32Array(tl3d.Display3DLocusShader.getVcSize() * 16);
        };
        ParticleLocusData.prototype.setFloat32Vec = function (key, ary) {
            var idxary = tl3d.Display3DLocusShader.shader_vec4[key];
            var idx = idxary[0] * 16 + idxary[1] * 4;
            this.vcmatData.set(ary, idx);
        };
        ParticleLocusData.prototype.setFloat32Mat = function (key, ary) {
            var idx = tl3d.Display3DLocusShader.shader_mat4[key] * 16;
            this.vcmatData.set(ary, idx);
        };
        return ParticleLocusData;
    }(tl3d.ParticleData));
    tl3d.ParticleLocusData = ParticleLocusData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DLocusBallPartilce = /** @class */ (function (_super) {
        __extends(Display3DLocusBallPartilce, _super);
        //protected _posAry: Array<number>;
        //protected _angleAry: Array<number>;
        //protected _tangentAry: Array<number>;
        //protected _tangentSpeed:number;
        function Display3DLocusBallPartilce() {
            return _super.call(this) || this;
        }
        Display3DLocusBallPartilce.prototype.creatData = function () {
            this.data = new tl3d.ParticleLocusballData;
        };
        return Display3DLocusBallPartilce;
    }(tl3d.Display3DBallPartilce));
    tl3d.Display3DLocusBallPartilce = Display3DLocusBallPartilce;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleLocusballData = /** @class */ (function (_super) {
        __extends(ParticleLocusballData, _super);
        function ParticleLocusballData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ParticleLocusballData.prototype.getParticle = function () {
            return new tl3d.Display3DLocusBallPartilce;
        };
        ParticleLocusballData.prototype.initBasePos = function () {
            var basePos = new Array;
            for (var i = 0; i < this._totalNum; i++) {
                var v3d;
                var index = i * 3;
                if (this._isRandom) {
                    var roundv3d = new tl3d.Vector3D(this._round.x * this._round.w, this._round.y * this._round.w, this._round.z * this._round.w);
                    v3d = new tl3d.Vector3D(this._posAry[index] + Math.random() * roundv3d.x, this._posAry[index + 1] + Math.random() * roundv3d.y, this._posAry[index + 2] + Math.random() * roundv3d.z);
                }
                else {
                    v3d = new tl3d.Vector3D(this._posAry[index], this._posAry[index + 1], this._posAry[index + 2]);
                }
                v3d = v3d.add(this._basePositon);
                for (var j = 0; j < 4; j++) {
                    basePos.push(v3d.x, v3d.y, v3d.z, i * this._shootSpeed);
                }
            }
            this.objBallData.basePos = basePos;
        };
        ParticleLocusballData.prototype.initSpeed = function () {
            var beMove = new Array;
            for (var i = 0; i < this._totalNum; i++) {
                var resultv3d = new tl3d.Vector3D;
                if (this._tangentSpeed == 0) {
                    resultv3d.addByNum(this._angleAry[i * 3], this._angleAry[i * 3 + 1], this._angleAry[i * 3 + 2]);
                }
                else if (this._tangentSpeed == 2) {
                    resultv3d.setTo(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
                }
                else {
                    var v3d = new tl3d.Vector3D(this._tangentAry[i * 3], this._tangentAry[i * 3 + 1], this._tangentAry[i * 3 + 2]);
                    v3d.scaleBy(this._tangentSpeed);
                    resultv3d = resultv3d.add(v3d);
                }
                resultv3d.normalize();
                if (this._isSendRandom) {
                    resultv3d.scaleBy(this._speed * Math.random());
                }
                else {
                    resultv3d.scaleBy(this._speed);
                }
                //var ranAngle: Number = this._baseRandomAngle * Math.random() * Math.PI / 180;
                for (var j = 0; j < 4; j++) {
                    beMove.push(resultv3d.x, resultv3d.y, resultv3d.z);
                }
            }
            this.objBallData.beMove = beMove;
        };
        ParticleLocusballData.prototype.setAllByteInfo = function ($byte) {
            this._tangentSpeed = $byte.readFloat();
            this._posAry = JSON.parse($byte.readUTF());
            this._angleAry = JSON.parse($byte.readUTF());
            this._tangentAry = JSON.parse($byte.readUTF());
            _super.prototype.setAllByteInfo.call(this, $byte);
            this.uploadGpu();
        };
        return ParticleLocusballData;
    }(tl3d.ParticleBallData));
    tl3d.ParticleLocusballData = ParticleLocusballData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DModelPartilce = /** @class */ (function (_super) {
        __extends(Display3DModelPartilce, _super);
        function Display3DModelPartilce() {
            var _this = _super.call(this) || this;
            //this.objData = new ParticleGpuData();
            _this._resultUvVec = new Array(2);
            return _this;
        }
        Object.defineProperty(Display3DModelPartilce.prototype, "modeldata", {
            get: function () {
                return this.data;
            },
            enumerable: true,
            configurable: true
        });
        Display3DModelPartilce.prototype.creatData = function () {
            this.data = new tl3d.ParticleModelData;
        };
        Display3DModelPartilce.prototype.setVc = function () {
            this.updateWatchCaramMatrix();
            this.updateUV();
            // Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "viewMatrix3D", Scene_data.viewMatrx3D.m);
            // Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            // Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "posMatrix3D", this.modelMatrix.m);
            // Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "rotationMatrix3D", this._rotationMatrix.m);
            // Scene_data.context3D.setVc2fv(this.data.materialParam.shader, "uvMove", this._resultUvVec);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "viewMatrix3D", Scene_data.viewMatrx3D.m);
            //this.data.setFloat32Mat("viewMatrix3D", Scene_data.viewMatrx3D.m);//0
            this.data.vcmatData.set(tl3d.Scene_data.viewMatrx3D.m, 0);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "camMatrix3D", Scene_data.cam3D.cameraMatrix.m);
            //this.data.setFloat32Mat("camMatrix3D", Scene_data.cam3D.cameraMatrix.m);//16
            this.data.vcmatData.set(tl3d.Scene_data.cam3D.cameraMatrix.m, 16);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "posMatrix3D", this.modelMatrix.m);
            //this.data.setFloat32Mat("posMatrix3D", this.modelMatrix.m);//48
            this.data.vcmatData.set(this.modelMatrix.m, 48);
            //Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "rotationMatrix3D", this._rotationMatrix.m);
            //this.data.setFloat32Mat("rotationMatrix3D", this._rotationMatrix.m);//32
            this.data.vcmatData.set(this._rotationMatrix.m, 32);
            //Scene_data.context3D.setVc2fv(this.data.materialParam.shader, "uvMove", this._resultUvVec);
            //this.data.setFloat32Vec("uvMove",this._resultUvVec);//64
            this.data.vcmatData.set(this._resultUvVec, 64);
            tl3d.Scene_data.context3D.setVcMatrix4fv(this.data.materialParam.shader, "vcmat", this.data.vcmatData);
            this.setMaterialVc();
        };
        Display3DModelPartilce.prototype.setVa = function () {
            //Scene_data.context3D.setVa(0, 3, this.data.objData.vertexBuffer);
            //Scene_data.context3D.setVa(1, 2, this.data.objData.uvBuffer);
            tl3d.Scene_data.context3D.setWriteDepth(this.data._depthMode == 1);
            var tf = tl3d.Scene_data.context3D.pushVa(this.data.objData.vertexBuffer);
            if (!tf) {
                tl3d.Scene_data.context3D.setVaOffset(0, 3, this.data.objData.stride, 0);
                tl3d.Scene_data.context3D.setVaOffset(1, 2, this.data.objData.stride, 12);
            }
            this.setMaterialTexture();
            tl3d.Scene_data.context3D.drawCall(this.data.objData.indexBuffer, this.data.objData.treNum);
            tl3d.Scene_data.context3D.setWriteDepth(false);
        };
        Display3DModelPartilce.prototype.updateWatchCaramMatrix = function () {
            this._rotationMatrix.identity();
            if (this.data._watchEye) {
                this.timeline.inverAxisRotation(this._rotationMatrix);
                this._rotationMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationY, tl3d.Vector3D.Y_AXIS);
                this._rotationMatrix.prependRotation(-tl3d.Scene_data.cam3D.rotationX, tl3d.Vector3D.X_AXIS);
            }
            if (this.data._isZiZhuan) {
                this.timeline.applySelfRotation(this._rotationMatrix, this.data._ziZhuanAngly);
            }
            //if (_axisRotaion) {
            //    _rotationMatrix.prependRotation(-_axisRotaion.num, _axisRotaion.axis);
            //}
        };
        Display3DModelPartilce.prototype.updateUV = function () {
            var currentFrame = Math.floor((this._time / tl3d.Scene_data.frameTime) / this.data._animInterval);
            var _maxAnimTime = this.data._animLine * this.data._animRow;
            this._resultUvVec[0] = Math.floor(currentFrame % this.data._animLine) / this.data._animLine;
            this._resultUvVec[1] = Math.floor(currentFrame / this.data._animLine) / this.data._animRow;
            this._resultUvVec[0] += this._time / tl3d.Scene_data.frameTime * this.data._uSpeed;
            this._resultUvVec[1] += this._time / tl3d.Scene_data.frameTime * this.data._vSpeed;
            this._resultUvVec[0] = this._resultUvVec[0] % 1;
            this._resultUvVec[1] = this._resultUvVec[1] % 1;
        };
        return Display3DModelPartilce;
    }(tl3d.Display3DParticle));
    tl3d.Display3DModelPartilce = Display3DModelPartilce;
})(tl3d || (tl3d = {}));
/// <reference path="Display3DModelPartilce.ts" />

(function (tl3d) {
    var Display3DModelObjParticle = /** @class */ (function (_super) {
        __extends(Display3DModelObjParticle, _super);
        function Display3DModelObjParticle() {
            return _super.call(this) || this;
        }
        Display3DModelObjParticle.prototype.update = function () {
            if (this._depthMode) {
                tl3d.Scene_data.context3D.setDepthTest(true);
            }
            _super.prototype.update.call(this);
            if (this._depthMode) {
                tl3d.Scene_data.context3D.setDepthTest(false);
            }
        };
        return Display3DModelObjParticle;
    }(tl3d.Display3DModelPartilce));
    tl3d.Display3DModelObjParticle = Display3DModelObjParticle;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3dModelAnimParticle = /** @class */ (function (_super) {
        __extends(Display3dModelAnimParticle, _super);
        function Display3dModelAnimParticle() {
            return _super.call(this) || this;
        }
        Display3dModelAnimParticle.prototype.updateUV = function () {
            var currentFrame = this._time / tl3d.Scene_data.frameTime;
            currentFrame = currentFrame > this.modeldata._maxAnimTime ? this.modeldata._maxAnimTime : currentFrame;
            currentFrame = (currentFrame / this.data._animInterval) % (this.data._animLine * this.data._animRow);
            this._resultUvVec[0] = tl3d.Util.float2int(currentFrame % this.data._animLine) / this.data._animLine + this._time / tl3d.Scene_data.frameTime * this.data._uSpeed;
            this._resultUvVec[1] = tl3d.Util.float2int(currentFrame / this.data._animLine) / this.data._animRow + this._time / tl3d.Scene_data.frameTime * this.data._vSpeed;
        };
        return Display3dModelAnimParticle;
    }(tl3d.Display3DModelPartilce));
    tl3d.Display3dModelAnimParticle = Display3dModelAnimParticle;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ParticleModelData = /** @class */ (function (_super) {
        __extends(ParticleModelData, _super);
        function ParticleModelData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ParticleModelData.prototype.getParticle = function () {
            return new tl3d.Display3DModelPartilce();
        };
        ParticleModelData.prototype.setAllByteInfo = function ($byte) {
            this.objData = new tl3d.ObjData;
            this._maxAnimTime = $byte.readFloat();
            // var vLen: number = $byte.readInt();
            // for (var i: number = 0; i < vLen; i++) {
            //     this.objData.vertices.push($byte.readFloat())
            // }
            // var uLen: number = $byte.readInt();
            // for (var j: number = 0; j < uLen; j++) {
            //     this.objData.uvs.push($byte.readFloat())
            // }
            var vLen = $byte.getInt();
            var dataWidth = 5;
            var len = vLen * dataWidth * 4;
            var arybuff = new ArrayBuffer(len);
            var data = new DataView(arybuff);
            tl3d.BaseRes.readBytes2ArrayBuffer($byte, data, 3, 0, dataWidth, 4); //vertices
            tl3d.BaseRes.readBytes2ArrayBuffer($byte, data, 2, 3, dataWidth, 4); //uv
            var iLen = $byte.readInt();
            for (var k = 0; k < iLen; k++) {
                this.objData.indexs.push($byte.readInt());
            }
            this.objData.stride = dataWidth * 4;
            if (this.version >= 36) {
                this._depthMode = $byte.readInt(); //新加模型特效深度信息
            }
            _super.prototype.setAllByteInfo.call(this, $byte);
            //this.uploadGpu();
            this.initVcData();
            this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3DArrayBuffer(arybuff);
            this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            this.objData.treNum = this.objData.indexs.length;
        };
        ParticleModelData.prototype.initVcData = function () {
            this.vcmatData = new Float32Array(tl3d.Display3DFacetShader.getVcSize() * 16);
        };
        ParticleModelData.prototype.uploadGpu = function () {
            this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
            this.objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.uvs);
            this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            this.objData.treNum = this.objData.indexs.length;
        };
        ParticleModelData.prototype.regShader = function () {
            //var shader: Display3DFacetShader = new Display3DFacetShader()
            this.materialParam.shader = tl3d.ProgrmaManager.getInstance().getMaterialProgram(tl3d.Display3DFacetShader.Display3D_Facet_Shader, tl3d.Display3DFacetShader, this.materialParam.material);
            this.materialParam.program = this.materialParam.shader.program;
        };
        ParticleModelData.prototype.setFloat32Vec = function (key, ary) {
            var idxary = tl3d.Display3DFacetShader.shader_vec4[key];
            var idx = idxary[0] * 16 + idxary[1] * 4;
            this.vcmatData.set(ary, idx);
        };
        ParticleModelData.prototype.setFloat32Mat = function (key, ary) {
            var idx = tl3d.Display3DFacetShader.shader_mat4[key] * 16;
            this.vcmatData.set(ary, idx);
        };
        return ParticleModelData;
    }(tl3d.ParticleData));
    tl3d.ParticleModelData = ParticleModelData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var BuildShader = /** @class */ (function (_super) {
        __extends(BuildShader, _super);
        function BuildShader() {
            return _super.call(this) || this;
        }
        BuildShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "v2CubeTexST");
        };
        BuildShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Position;" +
                "attribute vec2 v2CubeTexST;" +
                //"attribute vec2 v2LightBuff;" +
                "uniform mat4 viewMatrix3D;" +
                "uniform mat4 camMatrix3D;" +
                "uniform mat4 posMatrix3D;" +
                "varying vec2 v_texCoord;" +
                //"varying vec2 v_texLight;" +
                "void main(void)" +
                "{" +
                "   v_texCoord = vec2(v2CubeTexST.x, v2CubeTexST.y);" +
                //"   v_texLight = vec2(v2LightBuff.x, v2LightBuff.y);" +
                "   vec4 vt0= vec4(v3Position, 1.0);" +
                "   vt0 = posMatrix3D * vt0;" +
                "   vt0 = camMatrix3D * vt0;" +
                "   vt0 = viewMatrix3D * vt0;" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        BuildShader.prototype.getFragmentShaderString = function () {
            var $str = 
            //"#ifdef GL_FRAGMENT_PRECISION_HIGH\n" +
            //"precision highp float;\n" +
            //" #else\n" +
            " precision mediump float;\n" +
                //" #endif\n" +
                "uniform sampler2D s_texture;\n" +
                //"uniform sampler2D light_texture;\n" +
                "uniform vec4 testconst;" +
                "uniform vec4 testconst2;" +
                "varying vec2 v_texCoord;\n" +
                //"varying vec2 v_texLight;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                //"if (infoUv.a <= 0.9) {\n" +
                //"     discard;\n" +
                //"}\n" +
                //"vec4 infoLight = texture2D(light_texture, v_texLight);\n" +
                //"vec4 test = vec4(0.5,0,0,1);\n" +
                "vec4 test = vec4(0,0,0,1);\n" +
                "test.xyz = mix(vec3(1,1,1)*0.5,testconst.xyz,0.5);\n" +
                //"test = test * testconst2;\n" +
                "infoUv.xyz = test.xyz * infoUv.xyz;\n" +
                //"info.rgb = info.rgb / 0.15;\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        BuildShader.buildShader = "BuildShader";
        return BuildShader;
    }(tl3d.Shader3D));
    tl3d.BuildShader = BuildShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Display3DShadowShader = /** @class */ (function (_super) {
        __extends(Display3DShadowShader, _super);
        function Display3DShadowShader() {
            return _super.call(this) || this;
        }
        Display3DShadowShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Pos");
            $context.bindAttribLocation(this.program, 1, "v2uv");
        };
        Display3DShadowShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Pos;" +
                "attribute vec3 v2uv;" +
                "uniform mat4 viewMatrix3D;" +
                "uniform mat4 camMatrix3D;" +
                "uniform vec4 pos[30];" +
                "varying vec2 v_texCoord;" +
                "void main(void)" +
                "{" +
                "   v_texCoord = vec2(v2uv.x, v2uv.y);" +
                "   vec3 vt1= vec3(v3Pos.xyz * pos[int(v2uv.z)].w + pos[int(v2uv.z)].xyz);" +
                "   vec4 vt0= vec4(vt1, 1.0);" +
                "   vt0 = camMatrix3D * vt0;" +
                "   vt0 = viewMatrix3D * vt0;" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        Display3DShadowShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D s_texture;\n" +
                "varying vec2 v_texCoord;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                "infoUv.xyz *= infoUv.w;\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        Display3DShadowShader.Display3DShadowShader = "Display3DShadowShader";
        return Display3DShadowShader;
    }(tl3d.Shader3D));
    tl3d.Display3DShadowShader = Display3DShadowShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MaterialAnimShader = /** @class */ (function (_super) {
        __extends(MaterialAnimShader, _super);
        function MaterialAnimShader() {
            var _this = _super.call(this) || this;
            _this.name = "Material_Anim_shader";
            return _this;
        }
        MaterialAnimShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "pos");
            $context.bindAttribLocation(this.program, 1, "v2Uv");
            $context.bindAttribLocation(this.program, 2, "boneID");
            $context.bindAttribLocation(this.program, 3, "boneWeight");
            var usePbr = this.paramAry[0];
            var useNormal = this.paramAry[1];
            var lightProbe = this.paramAry[4];
            var directLight = this.paramAry[5];
            if (usePbr) {
                $context.bindAttribLocation(this.program, 4, "normal");
                if (useNormal) {
                    $context.bindAttribLocation(this.program, 5, "tangent");
                    $context.bindAttribLocation(this.program, 6, "bitangent");
                }
            }
            else if (lightProbe || directLight) {
                $context.bindAttribLocation(this.program, 4, "normal");
            }
        };
        MaterialAnimShader.getMd5M44Str = function () {
            var str = "vec4 qdv(vec4 q,vec3 d, vec3 v ){\n" +
                "vec3 t = 2.0 * cross(q.xyz, v);\n" +
                "vec3 f = v + q.w * t + cross(q.xyz, t);\n" +
                "return  vec4(f.x+d.x,f.y+d.y,f.z+d.z,1.0);\n" +
                " }\n" +
                "vec4 getQDdata(vec3 vdata){\n" +
                "vec4 tempnum = qdv(boneQ[int(boneID.x)],boneD[int(boneID.x)],vdata) * boneWeight.x;\n" +
                "tempnum += qdv(boneQ[int(boneID.y)],boneD[int(boneID.y)],vdata) * boneWeight.y;\n" +
                "tempnum += qdv(boneQ[int(boneID.z)],boneD[int(boneID.z)],vdata)* boneWeight.z;\n" +
                "tempnum += qdv(boneQ[int(boneID.w)],boneD[int(boneID.w)],vdata) * boneWeight.w;\n" +
                "tempnum.x = tempnum.x*-1.0;\n" +
                "return  tempnum;\n" +
                " }\n";
            return str;
        };
        MaterialAnimShader.getMd5M44NrmStr = function () {
            var str = "vec4 qdvNrm(vec4 q, vec3 v ){\n" +
                "vec3 t = 2.0 * cross(q.xyz, v);\n" +
                "vec3 f = v + q.w * t + cross(q.xyz, t);\n" +
                "return  vec4(f.x,f.y,f.z,1.0);\n" +
                " }\n" +
                "vec4 getQDdataNrm(vec3 vdata){\n" +
                "vec4 tempnum = qdvNrm(boneQ[int(boneID.x)],vdata) * boneWeight.x;\n" +
                "tempnum += qdvNrm(boneQ[int(boneID.y)],vdata) * boneWeight.y;\n" +
                "tempnum += qdvNrm(boneQ[int(boneID.z)],vdata)* boneWeight.z;\n" +
                "tempnum += qdvNrm(boneQ[int(boneID.w)],vdata) * boneWeight.w;\n" +
                "tempnum.x = tempnum.x*-1.0;\n" +
                "tempnum.xyz = normalize(tempnum.xyz);\n" +
                "return  tempnum;\n" +
                " }\n";
            return str;
        };
        MaterialAnimShader.prototype.getVertexShaderString = function () {
            var usePbr = this.paramAry[0];
            var useNormal = this.paramAry[1];
            var hasFresnel = this.paramAry[2];
            var useDynamicIBL = this.paramAry[3];
            var lightProbe = this.paramAry[4];
            var directLight = this.paramAry[5];
            var noLight = this.paramAry[6];
            var $str = "attribute vec4 pos;\n" +
                "attribute vec2 v2Uv;\n" +
                "attribute vec4 boneID;\n" +
                "attribute vec4 boneWeight;\n" +
                "varying vec2 v0;\n" +
                "uniform vec4 boneQ[54];\n" +
                "uniform vec3 boneD[54];\n" +
                //"uniform mat4 viewMatrix3D;\n" +
                // "uniform mat4 camMatrix3D;\n" +
                "uniform mat4 vpMatrix3D;\n" +
                "uniform mat4 posMatrix3D;\n";
            if (lightProbe) {
                $str +=
                    "uniform vec3 sh[9];\n" +
                        "varying vec3 v2;\n";
            }
            else if (directLight) {
                $str +=
                    "uniform vec3 sunDirect;\n" +
                        "uniform vec3 sunColor;\n" +
                        "uniform vec3 ambientColor;\n" +
                        "varying vec3 v2;\n";
            }
            else if (noLight) {
            }
            else {
                $str +=
                    "varying vec2 v2;\n";
            }
            if (usePbr) {
                $str +=
                    "attribute vec4 normal;\n" +
                        "uniform mat4 rotationMatrix3D;\n" +
                        "varying vec3 v1;\n";
                if (!useNormal) {
                    $str += "varying vec3 v4;\n";
                }
                else {
                    $str += "varying mat3 v4;\n";
                }
                if (useNormal) {
                    $str +=
                        "attribute vec4 tangent;\n" +
                            "attribute vec4 bitangent;\n";
                }
            }
            else if (lightProbe || directLight) {
                $str +=
                    "attribute vec4 normal;\n" +
                        "uniform mat4 rotationMatrix3D;\n";
            }
            $str +=
                MaterialAnimShader.getMd5M44Str() +
                    MaterialAnimShader.getMd5M44NrmStr() +
                    "void main(void){\n" +
                    "v0 = v2Uv;\n" +
                    "vec4 vt0 = getQDdata(vec3(pos.x,pos.y,pos.z));\n" +
                    "vt0.xyz = vt0.xyz*1.0;\n" +
                    "vt0 = posMatrix3D * vt0;\n";
            if (usePbr) {
                $str +=
                    "v1 = vec3(vt0.x,vt0.y,vt0.z);\n";
            }
            $str +=
                //"vt0 = camMatrix3D * vt0;\n" +
                //"vt0 = viewMatrix3D * vt0;\n" +
                "vt0 = vpMatrix3D * vt0;\n" +
                    "gl_Position = vt0;\n";
            if (usePbr) {
                if (!useNormal) {
                    $str +=
                        //"vt0 = bone[int(boneID.x)] * normal * boneWeight.x;\n" +
                        //"vt0 += bone[int(boneID.y)] * normal * boneWeight.y;\n" +
                        //"vt0 += bone[int(boneID.z)] * normal * boneWeight.z;\n" +
                        //"vt0 += bone[int(boneID.w)] * normal * boneWeight.w;\n" +
                        "vt0 = getQDdataNrm(vec3(normal.x,normal.y,normal.z));\n" +
                            "vt0 = rotationMatrix3D * vt0;\n" +
                            "vt0.xyz = normalize(vt0.xyz);\n" +
                            "v4 = vec3(vt0.x,vt0.y,vt0.z);\n";
                }
                else {
                    $str +=
                        //"vec4 vt2 = bone[int(boneID.x)] * tangent * boneWeight.x;\n" +
                        //"vt2 += bone[int(boneID.y)] * tangent * boneWeight.y;\n" +
                        //"vt2 += bone[int(boneID.z)] * tangent * boneWeight.z;\n" +
                        //"vt2 += bone[int(boneID.w)] * tangent * boneWeight.w;\n" +
                        "vec4 vt2 = getQDdataNrm(vec3(tangent.x,tangent.y,tangent.z));\n" +
                            "vt2 = rotationMatrix3D * vt2;\n" +
                            "vt2.xyz = normalize(vt2.xyz);\n" +
                            //"vec4 vt1 = bone[int(boneID.x)] * bitangent * boneWeight.x;\n" +
                            //"vt1 += bone[int(boneID.y)] * bitangent * boneWeight.y;\n" +
                            //"vt1 += bone[int(boneID.z)] * bitangent * boneWeight.z;\n" +
                            //"vt1 += bone[int(boneID.w)] * bitangent * boneWeight.w;\n" +
                            "vec4 vt1 = getQDdataNrm(vec3(bitangent.x,bitangent.y,bitangent.z));\n" +
                            "vt1 = rotationMatrix3D * vt1;\n" +
                            "vt1.xyz = normalize(vt1.xyz);\n" +
                            //"vt0 = bone[int(boneID.x)] * normal * boneWeight.x;\n" +
                            //"vt0 += bone[int(boneID.y)] * normal * boneWeight.y;\n" +
                            //"vt0 += bone[int(boneID.z)] * normal * boneWeight.z;\n" +
                            //"vt0 += bone[int(boneID.w)] * normal * boneWeight.w;\n" +
                            "vt0 = getQDdataNrm(vec3(normal.x,normal.y,normal.z));\n" +
                            "vt0 = rotationMatrix3D * vt0;\n" +
                            "vt0.xyz = normalize(vt0.xyz);\n" +
                            "v4 = mat3(vec3(vt2.x,vt2.y,vt2.z),vec3(vt1.x,vt1.y,vt1.z),vec3(vt0.x,vt0.y,vt0.z));\n";
                }
            }
            else if (lightProbe || directLight) {
                $str +=
                    //"vt0 = bone[int(boneID.x)] * normal * boneWeight.x;\n" +
                    //"vt0 += bone[int(boneID.y)] * normal * boneWeight.y;\n" +
                    //"vt0 += bone[int(boneID.z)] * normal * boneWeight.z;\n" +
                    //"vt0 += bone[int(boneID.w)] * normal * boneWeight.w;\n" +
                    "vt0 = getQDdataNrm(vec3(normal.x,normal.y,normal.z));\n" +
                        "vt0 = rotationMatrix3D * vt0;\n" +
                        "vt0.xyz = normalize(vt0.xyz);\n";
                //"vt0 = vec4(0,1,0,1);\n";
            }
            if (lightProbe) {
                $str +=
                    "vec3 lpb = sh[0] * 0.28209479177387814;\n" +
                        "lpb += sh[1] * (vt0.y * -0.4886025119029199);\n" +
                        "lpb += sh[2] * (vt0.z * 0.4886025119029199);\n" +
                        "lpb += sh[3] * (vt0.x * -0.4886025119029199);\n" +
                        "lpb += sh[4] * (vt0.x * vt0.y * 1.0925484305920792);\n" +
                        "lpb += sh[5] * (vt0.z * vt0.y * -1.0925484305920792);\n" +
                        "lpb += sh[6] * ((3.0 * vt0.z * vt0.z - 1.0) * 0.31539156525252005);\n" +
                        "lpb += sh[7] * (vt0.z * vt0.x * -1.0925484305920792);\n" +
                        "lpb += sh[8] * ((vt0.x * vt0.x - vt0.y * vt0.y) * 0.5462742152960396);\n" +
                        "v2 = lpb;\n";
            }
            else if (directLight) {
                $str +=
                    "float suncos = dot(vt0.xyz,sunDirect.xyz);\n" +
                        "suncos = clamp(suncos,0.0,1.0);\n" +
                        "v2 = sunColor * suncos + ambientColor;";
                // "v2 += vec3(1.0,1.0,1.0);" 
            }
            else if (noLight) {
            }
            else {
                $str +=
                    "v2 = v2Uv;\n";
            }
            $str += "}";
            //if (usePbr) {
            //    if (!useNormal) {
            //        $str += "v4 = vec3(v3Normal.x,v3Normal.y,v3Normal.z);\n";
            //    } else {
            //        $str += 
            //        "v4 = mat3(v3Tangent,v3Bitangent,v3Normal);\n"
            //    }
            //}
            return $str;
        };
        MaterialAnimShader.prototype.getFragmentShaderString = function () {
            var $str = 
            //"#ifdef GL_FRAGMENT_PRECISION_HIGH\n" +
            //"precision highp float;\n" +
            //" #else\n" +
            //" precision mediump float;\n" +
            //" #endif\n" +
            "uniform sampler2D s_texture1;\n" +
                //"uniform sampler2D light_texture;\n" +
                "uniform vec4 testconst;" +
                "varying vec2 v_texCoord;\n" +
                //"varying vec2 v_texLight;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                //"if (infoUv.a <= 0.9) {\n" +
                //"     discard;\n" +
                //"}\n" +
                //"vec4 infoLight = texture2D(light_texture, v_texLight);\n" +
                //"vec4 test = vec4(0.5,0,0,1);\n" +
                "infoUv.xyz = testconst.xyz * infoUv.xyz;\n" +
                //"info.rgb = info.rgb / 0.15;\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        MaterialAnimShader.MATERIAL_ANIM_SHADER = "Material_Anim_shader";
        return MaterialAnimShader;
    }(tl3d.Shader3D));
    tl3d.MaterialAnimShader = MaterialAnimShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MaterialBatchAnimShader = /** @class */ (function (_super) {
        __extends(MaterialBatchAnimShader, _super);
        function MaterialBatchAnimShader() {
            var _this = _super.call(this) || this;
            _this.name = "Material_Batch_Anim_Shader";
            return _this;
        }
        MaterialBatchAnimShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "pos");
            $context.bindAttribLocation(this.program, 1, "v2Uv");
            $context.bindAttribLocation(this.program, 2, "boneID");
            $context.bindAttribLocation(this.program, 3, "boneWeight");
            var usePbr = this.paramAry[0];
            var useNormal = this.paramAry[1];
            var lightProbe = this.paramAry[4];
            var directLight = this.paramAry[5];
            if (usePbr) {
                $context.bindAttribLocation(this.program, 4, "normal");
                if (useNormal) {
                    $context.bindAttribLocation(this.program, 5, "tangent");
                    $context.bindAttribLocation(this.program, 6, "bitangent");
                }
            }
            else if (lightProbe || directLight) {
                $context.bindAttribLocation(this.program, 4, "normal");
            }
        };
        MaterialBatchAnimShader.prototype.getVertexShaderString = function () {
            var usePbr = this.paramAry[0];
            var useNormal = this.paramAry[1];
            var hasFresnel = this.paramAry[2];
            var useDynamicIBL = this.paramAry[3];
            var lightProbe = this.paramAry[4];
            var directLight = this.paramAry[5];
            var noLight = this.paramAry[6];
            var $str = "precision mediump float;\n" +
                "attribute vec4 pos;\n" +
                "attribute vec3 v2Uv;\n" +
                "attribute vec4 boneID;\n" +
                "attribute vec4 boneWeight;\n" +
                "varying vec2 v0;\n" +
                "uniform mat4 bone[19];\n" +
                "uniform mat4 viewMatrix3D;\n" +
                "uniform mat4 camMatrix3D;\n" +
                "uniform mat4 posMatrixAry[6];\n";
            if (lightProbe) {
                $str +=
                    "varying vec3 v2;\n";
            }
            else if (directLight) {
                $str +=
                    "uniform vec3 sunDirect;\n" +
                        "uniform vec3 sunColor;\n" +
                        "uniform vec3 ambientColor;\n" +
                        "varying vec3 v2;\n";
            }
            else if (noLight) {
            }
            else {
                $str +=
                    "varying vec2 v2;\n";
            }
            if (usePbr) {
                $str +=
                    "attribute vec4 normal;\n" +
                        "uniform mat4 rotationMatrix3D;\n" +
                        "varying vec3 v1;\n";
                if (!useNormal) {
                    $str += "varying vec3 v4;\n";
                }
                else {
                    $str += "varying mat3 v4;\n";
                }
                if (useNormal) {
                    $str +=
                        "attribute vec4 tangent;\n" +
                            "attribute vec4 bitangent;\n";
                }
            }
            else if (lightProbe || directLight) {
                $str +=
                    "attribute vec4 normal;\n" +
                        "uniform mat4 rotationMatrix3D;\n";
            }
            $str +=
                "void main(void){\n" +
                    "v0 = vec2(v2Uv.xy);\n" +
                    "vec4 vt0 = bone[int(boneID.x)] * pos * boneWeight.x;\n" +
                    "vt0 += bone[int(boneID.y)] * pos * boneWeight.y;\n" +
                    "vt0 += bone[int(boneID.z)] * pos * boneWeight.z;\n" +
                    "vt0 += bone[int(boneID.w)] * pos * boneWeight.w;\n" +
                    "vt0 = posMatrixAry[int(v2Uv.z)] * vt0;\n";
            if (usePbr) {
                $str +=
                    "v1 = vec3(vt0.x,vt0.y,vt0.z);\n";
            }
            $str +=
                "vt0 = camMatrix3D * vt0;\n" +
                    "vt0 = viewMatrix3D * vt0;\n" +
                    "gl_Position = vt0;\n";
            if (usePbr) {
                if (!useNormal) {
                    $str +=
                        "vt0 = bone[int(boneID.x)] * normal * boneWeight.x;\n" +
                            "vt0 += bone[int(boneID.y)] * normal * boneWeight.y;\n" +
                            "vt0 += bone[int(boneID.z)] * normal * boneWeight.z;\n" +
                            "vt0 += bone[int(boneID.w)] * normal * boneWeight.w;\n" +
                            "vt0 = rotationMatrix3D * vt0;\n" +
                            "vt0.xyz = normalize(vt0.xyz);\n" +
                            "v4 = vec3(vt0.x,vt0.y,vt0.z);\n";
                }
                else {
                    $str +=
                        "vec4 vt2 = bone[int(boneID.x)] * tangent * boneWeight.x;\n" +
                            "vt2 += bone[int(boneID.y)] * tangent * boneWeight.y;\n" +
                            "vt2 += bone[int(boneID.z)] * tangent * boneWeight.z;\n" +
                            "vt2 += bone[int(boneID.w)] * tangent * boneWeight.w;\n" +
                            "vt2 = rotationMatrix3D * vt2;\n" +
                            "vt2.xyz = normalize(vt2.xyz);\n" +
                            "vec4 vt1 = bone[int(boneID.x)] * bitangent * boneWeight.x;\n" +
                            "vt1 += bone[int(boneID.y)] * bitangent * boneWeight.y;\n" +
                            "vt1 += bone[int(boneID.z)] * bitangent * boneWeight.z;\n" +
                            "vt1 += bone[int(boneID.w)] * bitangent * boneWeight.w;\n" +
                            "vt1 = rotationMatrix3D * vt1;\n" +
                            "vt1.xyz = normalize(vt1.xyz);\n" +
                            "vt0 = bone[int(boneID.x)] * normal * boneWeight.x;\n" +
                            "vt0 += bone[int(boneID.y)] * normal * boneWeight.y;\n" +
                            "vt0 += bone[int(boneID.z)] * normal * boneWeight.z;\n" +
                            "vt0 += bone[int(boneID.w)] * normal * boneWeight.w;\n" +
                            "vt0 = rotationMatrix3D * vt0;\n" +
                            "vt0.xyz = normalize(vt0.xyz);\n" +
                            "v4 = mat3(vec3(vt2.x,vt2.y,vt2.z),vec3(vt1.x,vt1.y,vt1.z),vec3(vt0.x,vt0.y,vt0.z));\n";
                }
            }
            else if (lightProbe || directLight) {
                $str +=
                    "vt0 = bone[int(boneID.x)] * normal * boneWeight.x;\n" +
                        "vt0 += bone[int(boneID.y)] * normal * boneWeight.y;\n" +
                        "vt0 += bone[int(boneID.z)] * normal * boneWeight.z;\n" +
                        "vt0 += bone[int(boneID.w)] * normal * boneWeight.w;\n" +
                        "vt0 = rotationMatrix3D * vt0;\n" +
                        "vt0.xyz = normalize(vt0.xyz);\n";
                //"vt0 = vec4(0,1,0,1);\n";
            }
            if (lightProbe) {
                $str +=
                    "vec3 lpb = normalize(vec3(1.0,1.0,-1.0));\n" +
                        "float lp = min(0.0,dot(lpb,vec3(vt0.xyz)));\n" +
                        "lp = lp * 2.0 + 0.7;\n" +
                        "v2 = vec3(lp,lp,lp);\n";
            }
            else if (directLight) {
                $str +=
                    "float suncos = dot(vt0.xyz,sunDirect.xyz);\n" +
                        "suncos = clamp(suncos,0.0,1.0);\n" +
                        "v2 = sunColor * suncos + ambientColor;";
                //"v2 = sunColor * suncos;"
            }
            else if (noLight) {
            }
            else {
                $str +=
                    "v2 = v2Uv;\n";
            }
            $str += "}";
            //if (usePbr) {
            //    if (!useNormal) {
            //        $str += "v4 = vec3(v3Normal.x,v3Normal.y,v3Normal.z);\n";
            //    } else {
            //        $str += 
            //        "v4 = mat3(v3Tangent,v3Bitangent,v3Normal);\n"
            //    }
            //}
            return $str;
        };
        MaterialBatchAnimShader.prototype.getFragmentShaderString = function () {
            var $str = 
            //"#ifdef GL_FRAGMENT_PRECISION_HIGH\n" +
            //"precision highp float;\n" +
            //" #else\n" +
            //" precision mediump float;\n" +
            //" #endif\n" +
            "uniform sampler2D s_texture1;\n" +
                //"uniform sampler2D light_texture;\n" +
                "uniform vec4 testconst;" +
                "varying vec2 v_texCoord;\n" +
                //"varying vec2 v_texLight;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                //"if (infoUv.a <= 0.9) {\n" +
                //"     discard;\n" +
                //"}\n" +
                //"vec4 infoLight = texture2D(light_texture, v_texLight);\n" +
                //"vec4 test = vec4(0.5,0,0,1);\n" +
                "infoUv.xyz = testconst.xyz * infoUv.xyz;\n" +
                //"info.rgb = info.rgb / 0.15;\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        return MaterialBatchAnimShader;
    }(tl3d.Shader3D));
    tl3d.MaterialBatchAnimShader = MaterialBatchAnimShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MaterialShader = /** @class */ (function (_super) {
        __extends(MaterialShader, _super);
        function MaterialShader() {
            var _this = _super.call(this) || this;
            _this.name = "Material_shader";
            return _this;
        }
        MaterialShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "v2CubeTexST");
            //if (this.paramAry[0]){
            //    $context.bindAttribLocation(this.program, 3, "v3Normal");
            //}
            //if (this.paramAry[1]){
            //    $context.bindAttribLocation(this.program, 4, "v3Tangent");
            //    $context.bindAttribLocation(this.program, 5, "v3Bitangent");
            //}
            var usePbr = this.paramAry[0];
            var useNormal = this.paramAry[1];
            var lightProbe = this.paramAry[4];
            var directLight = this.paramAry[5];
            var noLight = this.paramAry[6];
            if (!(directLight || noLight)) {
                $context.bindAttribLocation(this.program, 2, "v2lightuv");
            }
            if (usePbr) {
                $context.bindAttribLocation(this.program, 3, "v3Normal");
                if (useNormal) {
                    $context.bindAttribLocation(this.program, 4, "v3Tangent");
                    $context.bindAttribLocation(this.program, 5, "v3Bitangent");
                }
            }
            else if (directLight) {
                $context.bindAttribLocation(this.program, 3, "v3Normal");
            }
        };
        MaterialShader.prototype.getVertexShaderString = function () {
            var usePbr = this.paramAry[0];
            var useNormal = this.paramAry[1];
            var hasFresnel = this.paramAry[2];
            var useDynamicIBL = this.paramAry[3];
            var lightProbe = this.paramAry[4];
            var directLight = this.paramAry[5];
            var noLight = this.paramAry[6];
            var fogMode = this.paramAry[7];
            var $str = "attribute vec3 v3Position;\n" +
                "attribute vec2 v2CubeTexST;\n" +
                "varying vec2 v0;\n";
            if (directLight) {
                $str += "varying vec3 v2;\n";
            }
            else if (noLight) {
            }
            else {
                $str +=
                    "attribute vec2 v2lightuv;\n" +
                        "varying vec2 v2;\n";
            }
            if (usePbr) {
                $str +=
                    "attribute vec3 v3Normal;\n" +
                        "varying vec3 v1;\n";
                if (!useNormal) {
                    $str += "varying vec3 v4;\n";
                }
                else {
                    $str += "varying mat3 v4;\n";
                }
            }
            else if (fogMode != 0) {
                $str +=
                    "varying vec3 v1;\n";
            }
            if (useNormal) {
                $str +=
                    "attribute vec3 v3Tangent;\n" +
                        "attribute vec3 v3Bitangent;\n";
            }
            if (directLight) {
                if (!usePbr) {
                    $str +=
                        "attribute vec3 v3Normal;\n";
                }
                $str +=
                    "uniform vec3 sunDirect;\n" +
                        "uniform vec3 sunColor;\n" +
                        "uniform vec3 ambientColor;\n";
            }
            $str +=
                // "uniform mat4 viewMatrix3D;\n" +
                // "uniform mat4 camMatrix3D;\n" +
                "uniform mat4 vpMatrix3D;\n" +
                    "uniform mat4 posMatrix3D;\n" +
                    "uniform mat3 rotationMatrix3D;\n";
            $str +=
                "void main(void){\n" +
                    "v0 = vec2(v2CubeTexST.x, v2CubeTexST.y);\n" +
                    "vec4 vt0= vec4(v3Position, 1.0);\n" +
                    "vt0 = posMatrix3D * vt0;\n";
            if (!(directLight || noLight)) {
                $str += "v2 = vec2(v2lightuv.x, v2lightuv.y);\n";
            }
            if (usePbr || fogMode != 0) {
                $str +=
                    "v1 = vec3(vt0.x,vt0.y,vt0.z);\n";
            }
            $str +=
                //"vt0 = camMatrix3D * vt0;\n" +
                "vt0 = vpMatrix3D * vt0;\n";
            if (usePbr) {
                if (!useNormal) {
                    $str += "v4 = rotationMatrix3D * v3Normal;\n";
                }
                else {
                    $str +=
                        "v4 = mat3(rotationMatrix3D * v3Tangent,rotationMatrix3D * v3Bitangent, rotationMatrix3D * v3Normal);\n";
                }
            }
            if (directLight) {
                if (!usePbr) {
                    $str +=
                        //    "vec4 n = rotationMatrix3D * vec4(v3Normal, 1.0);\n" +
                        "vec3 n = rotationMatrix3D * v3Normal;\n" +
                            "float suncos = dot(n.xyz,sunDirect.xyz);\n";
                }
                else {
                    $str +=
                        "float suncos = dot(v4.xyz,sunDirect.xyz);\n";
                }
                $str +=
                    "suncos = clamp(suncos,0.0,1.0);\n" +
                        "v2 = sunColor * suncos + ambientColor;";
                //"v2 = vec3(1.0,0.0,0.0);\n";
            }
            $str += "gl_Position = vt0;" + "}";
            //   this.outstr($str);
            return $str;
        };
        MaterialShader.prototype.outstr = function (str) {
            var arr = str.split(";");
            for (var i = 0; i < arr.length; i++) {
                var $ddd = String(tl3d.Util.trim(arr[i]));
                //console.log("\"" + $ddd + "\;" + "\"" + "\+")
            }
            //   //console.log(arr)
        };
        MaterialShader.prototype.getFragmentShaderString = function () {
            var $str = 
            //"#ifdef GL_FRAGMENT_PRECISION_HIGH\n" +
            //"precision highp float;\n" +
            //" #else\n" +
            //" precision mediump float;\n" +
            //" #endif\n" +
            "uniform sampler2D s_texture1;\n" +
                //"uniform sampler2D light_texture;\n" +
                "uniform vec4 testconst;" +
                "varying vec2 v_texCoord;\n" +
                //"varying vec2 v_texLight;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                //"if (infoUv.a <= 0.9) {\n" +
                //"     discard;\n" +
                //"}\n" +
                //"vec4 infoLight = texture2D(light_texture, v_texLight);\n" +
                //"vec4 test = vec4(0.5,0,0,1);\n" +
                "infoUv.xyz = testconst.xyz * infoUv.xyz;\n" +
                //"info.rgb = info.rgb / 0.15;\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        MaterialShader.MATERIAL_SHADER = "Material_shader";
        return MaterialShader;
    }(tl3d.Shader3D));
    tl3d.MaterialShader = MaterialShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Movie2DShader = /** @class */ (function (_super) {
        __extends(Movie2DShader, _super);
        function Movie2DShader() {
            return _super.call(this) || this;
        }
        Movie2DShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Pos");
            $context.bindAttribLocation(this.program, 1, "v2uv");
        };
        Movie2DShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Pos;" +
                "attribute vec3 v2uv;" +
                "uniform mat4 viewMatrix3D;\n" +
                "uniform mat4 camMatrix3D;\n" +
                "uniform mat4 watchCamMatrix3D;\n" +
                "uniform vec4 posdata[24];" +
                "uniform vec2 outuv;" +
                //"uniform vec4 ui[6];" +
                //"uniform vec4 ui2[6];" +
                "varying vec2 v_texCoord;" +
                "void main(void)" +
                "{" +
                "   vec4 data = posdata[int(v2uv.z)];" +
                //"   v_texCoord = vec2(v2uv.x * data.x + data.z, v2uv.y * data.y + data.w);" +
                //"   data = ui[int(v2uv.z)];" +
                "   vec4 vt0= vec4(v3Pos * data.w,1.0);" +
                "   vt0= watchCamMatrix3D * vt0;" +
                "   vt0.xyz += data.xyz;" +
                //"   pos.xy = v3Pos.xy * data.zw * 2.0;" +
                //"   pos.x += data.x * 2.0 - 1.0;" +
                //"   pos.y += -data.y * 2.0 + 1.0;" +
                "   v_texCoord = vec2(v2uv.x,v2uv.y) + outuv;" +
                //"   vec4 vt0= vec4(v3Pos, 1.0);" +
                "   gl_Position = viewMatrix3D * camMatrix3D * vt0;" +
                "}";
            return $str;
        };
        Movie2DShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D s_texture;\n" +
                "varying vec2 v_texCoord;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                "infoUv.xyz *= infoUv.w;\n" +
                "if(infoUv.w < 0.1){discard;}\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        Movie2DShader.MOVIE2D_SHADER = "Movie2DShader";
        return Movie2DShader;
    }(tl3d.Shader3D));
    tl3d.Movie2DShader = Movie2DShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ProgrmaManager = /** @class */ (function (_super) {
        __extends(ProgrmaManager, _super);
        function ProgrmaManager() {
            //this._dic = new Object();
            return _super.call(this) || this;
        }
        ProgrmaManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new ProgrmaManager();
            }
            return this._instance;
        };
        ProgrmaManager.prototype.getProgram = function ($str) {
            if (this._dic[$str]) {
                return this._dic[$str];
            }
            else {
                alert("please registe Program=>" + $str);
                return null;
            }
        };
        ProgrmaManager.prototype.registe = function ($str, $shader3D) {
            if (!this._dic[$str]) {
                $shader3D.encode();
                $shader3D.useNum = 1;
                $shader3D.name = $str;
                this._dic[$str] = $shader3D;
            }
        };
        ProgrmaManager.prototype.getMaterialProgram = function (key, shaderCls, $material, paramAry, parmaByFragmet) {
            if (paramAry === void 0) { paramAry = null; }
            if (parmaByFragmet === void 0) { parmaByFragmet = false; }
            var keyStr = key + "_" + $material.url;
            //if (keyStr.search("/standard_byte1111") != -1 &&true) { //FIXME
            //    //console.log(keyStr)
            //    this.outShader($material.shaderStr)
            //    $material.shaderStr =
            //    "precision mediump float;\n" +
            //    "uniform sampler2D fs0;\n" +
            //    "uniform sampler2D fs1;\n" +
            //    "uniform vec4 fc2;\n" +
            //    "uniform vec2 fogdata;\n" +
            //    "uniform vec3 fogcolor;\n" +
            //    "varying vec2 v0;\n" +
            //    "varying vec2 v2;\n" +
            //    "varying vec3 v1;\n" +
            //    "void main(void){\n" +
            //    "\n" +
            //    "vec4 ft0 = texture2D(fs0,v0);\n" +
            //    "vec4 ft1 = texture2D(fs1,v2);\n" +
            //    "ft1.xyz = ft1.xyz * 2.0;\n" +
            //    "ft1.xyz = ft1.xyz * ft0.xyz;\n" +
            //    "vec4 ft2 = vec4(0,0,0,1);\n" +
            //    "ft2.xyz = ft1.xyz;\n" +
            //    "ft2.w = 1.0;\n" +
            //   "ft1.x = distance(v1.xyz*0.01, fc2.xyz)*100.0;\n" +
            //   "ft1.x = ft1.x - fogdata.x;\n"+
            //   "ft1.x = fogdata.y * ft1.x;\n" +
            //   "ft1.x = clamp(ft1.x,0.0,1.0);\n"+
            //   "ft2.xyz = mix(ft2.xyz,fogcolor.xyz,ft1.x);\n" +
            //    "gl_FragColor = ft2;\n"+
            //     "}"
            //}
            if (paramAry) {
                for (var i = 0; i < paramAry.length; i++) {
                    keyStr += "_" + paramAry[i];
                }
                if (parmaByFragmet) {
                    keyStr += "true_";
                }
                else {
                    keyStr += "false_";
                }
            }
            if (this._dic[keyStr]) {
                this._dic[keyStr].useNum++;
                return this._dic[keyStr];
            }
            if (parmaByFragmet) {
                paramAry = [$material.usePbr, $material.useNormal, $material.hasFresnel,
                    $material.useDynamicIBL, $material.lightProbe, $material.directLight,
                    $material.noLight, $material.fogMode];
            }
            var shader = new shaderCls();
            shader.paramAry = paramAry;
            shader.fragment = $material.shaderStr;
            var encodetf = shader.encode();
            shader.useNum++;
            if (!encodetf) {
                //console.log("**********错误" + keyStr);
                //console.log(shader.vertex);
                //console.log(shader.fragment);
            }
            //if (keyStr.search("staticstandtrans") != -1 && true) {
            //this.outShader(shader.vertex)
            ////console.log(shader.vertex);
            ////console.log(shader.fragment);
            //}
            this._dic[keyStr] = shader;
            return shader;
        };
        ProgrmaManager.prototype.outShader = function ($str) {
            var $item = $str.split("\n");
            //console.log("----")
            for (var i = 0; i < $item.length; i++) {
                var str = "\"";
                str += $item[i];
                if (i < ($item.length - 1)) {
                    str += "\\n";
                    str += "\"";
                    str += "\+";
                }
                else {
                    str += "\"";
                }
                //console.log(str)
            }
            //console.log("----")
        };
        return ProgrmaManager;
    }(tl3d.ResGC));
    tl3d.ProgrmaManager = ProgrmaManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkyShader = /** @class */ (function (_super) {
        __extends(SkyShader, _super);
        function SkyShader() {
            return _super.call(this) || this;
        }
        SkyShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "v3Normal");
        };
        SkyShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Position;" +
                "attribute vec3 v3Normal;" +
                //"attribute vec2 v2LightBuff;" +
                "uniform mat4 viewMatrix3D;" +
                "uniform mat4 camMatrix3D;" +
                "uniform mat4 posMatrix3D;" +
                "varying vec3 vNormal;" +
                //"varying vec2 v_texLight;" +
                "void main(void)" +
                "{" +
                "   vNormal = vec3(v3Normal.x, v3Normal.y,v3Normal.z);" +
                "   vec4 vt0= vec4(v3Position, 1.0);" +
                "   vt0 = posMatrix3D * vt0;" +
                "   vt0 = camMatrix3D * vt0;" +
                "   vt0 = viewMatrix3D * vt0;" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        SkyShader.prototype.getFragmentShaderString = function () {
            var $str = 
            //"#ifdef GL_FRAGMENT_PRECISION_HIGH\n" +
            //"precision highp float;\n" +
            //" #else\n" +
            //" precision mediump float;\n" +
            //" #endif\n" +
            "precision mediump float;\n" +
                "uniform samplerCube s_texture;\n" +
                //"uniform sampler2D light_texture;\n" +
                "varying vec3 vNormal;\n" +
                //"varying vec2 v_texLight;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = textureCube(s_texture, vNormal);\n" +
                //"if (infoUv.a <= 0.9) {\n" +
                //"     discard;\n" +
                //"}\n" +
                //"vec4 infoLight = texture2D(light_texture, v_texLight);\n" +
                //"vec4 test = vec4(0.5,0,0,1);\n" +
                //"vec4 test = testconst * testconst2;\n" +
                //"test = test * testconst2;\n" +
                //"infoUv.xyz = test.xyz * infoUv.xyz;\n" +
                //"info.rgb = info.rgb / 0.15;\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        SkyShader.Sky_Shader = "SkyShader";
        return SkyShader;
    }(tl3d.Shader3D));
    tl3d.SkyShader = SkyShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Sprite2DShader = /** @class */ (function (_super) {
        __extends(Sprite2DShader, _super);
        function Sprite2DShader() {
            return _super.call(this) || this;
        }
        Sprite2DShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Pos");
            $context.bindAttribLocation(this.program, 1, "v2uv");
        };
        Sprite2DShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Pos;" +
                "attribute vec3 v2uv;" +
                "uniform mat4 viewMatrix3D;\n" +
                "uniform mat4 camMatrix3D;\n" +
                "uniform mat4 watchCamMatrix3D;\n" +
                "uniform vec4 posdata[12];" +
                "varying vec2 v_texCoord;" +
                "void main(void)" +
                "{" +
                "   vec4 data = posdata[int(v2uv.z)];" +
                "   vec4 vt0= vec4(v3Pos * data.w,1.0);" +
                "   vt0= watchCamMatrix3D * vt0;" +
                "   vt0.xyz += data.xyz;" +
                "   v_texCoord = vec2(v2uv.x,v2uv.y);" +
                "   gl_Position = viewMatrix3D * camMatrix3D * vt0;" +
                "}";
            return $str;
        };
        Sprite2DShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D s_texture;\n" +
                "varying vec2 v_texCoord;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                "infoUv.xyz *= infoUv.w;\n" +
                "if(infoUv.w < 0.1){discard;}\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        Sprite2DShader.SPRITE2D_SHADER = "Sprite2DShader";
        return Sprite2DShader;
    }(tl3d.Shader3D));
    tl3d.Sprite2DShader = Sprite2DShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TerrainDisplay3DShader = /** @class */ (function (_super) {
        __extends(TerrainDisplay3DShader, _super);
        function TerrainDisplay3DShader() {
            return _super.call(this) || this;
        }
        TerrainDisplay3DShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "v2TexCoord");
        };
        TerrainDisplay3DShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Position;" +
                "attribute vec2 v2TexCoord;\n" +
                "uniform mat4 viewMatrix3D;" +
                "uniform mat4 camMatrix3D;" +
                "uniform mat4 posMatrix3D;" +
                "varying vec2 v0;\n" +
                "void main(void)" +
                "{" +
                " v0 = v2TexCoord;" +
                "   vec4 vt0= vec4(v3Position, 1.0);" +
                "   vt0 = posMatrix3D * vt0;" +
                "   vt0 = camMatrix3D * vt0;" +
                "   vt0 = viewMatrix3D * vt0;" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        TerrainDisplay3DShader.prototype.getFragmentShaderString = function () {
            var $str = "precision mediump float;" +
                "uniform sampler2D idmaptexture;" +
                "uniform sampler2D infotexture;" +
                "uniform sampler2D sixtexture;" +
                "uniform sampler2D lightexture;" +
                "vec4 qdvNrm(float indx ,vec2 uvpos){" +
                "vec2 sixuvTx=uvpos; " +
                "float ccavid= floor(indx*255.0);" +
                "if (ccavid==0.0) {\n" +
                "} else  if (ccavid==1.0){\n" +
                "sixuvTx.x=sixuvTx.x+0.5;" +
                "} else  if (ccavid==2.0){" +
                "sixuvTx.y=sixuvTx.y+0.5;" +
                "}else{" +
                "sixuvTx.x=sixuvTx.x+0.5;" +
                "sixuvTx.y=sixuvTx.y+0.5;" +
                "}; " +
                "sixuvTx.x=sixuvTx.x+0.001;" +
                "sixuvTx.y=sixuvTx.y+0.001;" +
                "vec4 sixUvColor = texture2D(sixtexture, sixuvTx.xy);\n" +
                "return  sixUvColor;\n" +
                " }\n" +
                "varying vec2 v0;" +
                "void main(void)" +
                "{" +
                "vec4 idUv = texture2D(idmaptexture, v0.xy);\n" +
                "vec4 infoUv = texture2D(infotexture, v0.xy);\n" +
                "vec4 sixUv = texture2D(sixtexture, v0.xy);\n" +
                "vec4 lightUv = texture2D(lightexture, v0*0.995+0.0025);\n" +
                "vec2 sixuv=fract(v0*10.0); " +
                " sixuv=sixuv*0.498; " +
                "vec4 tempnumA = qdvNrm(idUv.x,sixuv) * infoUv.x;\n" +
                "vec4 tempnumB = qdvNrm(idUv.y,sixuv) * infoUv.y;\n" +
                "vec4 tempnumC = qdvNrm(idUv.z,sixuv) * infoUv.z;\n" +
                "vec4 tempnumD = tempnumA+tempnumB+tempnumC;\n" +
                " tempnumD.xyz=tempnumD.xyz*lightUv.xyz*2.0; " +
                "gl_FragColor = tempnumD;" +
                "}";
            return $str;
        };
        TerrainDisplay3DShader.TerrainDisplay3DShader = "TerrainDisplay3DShader";
        return TerrainDisplay3DShader;
    }(tl3d.Shader3D));
    tl3d.TerrainDisplay3DShader = TerrainDisplay3DShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UIImageShader = /** @class */ (function (_super) {
        __extends(UIImageShader, _super);
        function UIImageShader() {
            return _super.call(this) || this;
        }
        UIImageShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Pos");
            $context.bindAttribLocation(this.program, 1, "v2uv");
        };
        UIImageShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Pos;" +
                "attribute vec2 v2uv;" +
                "uniform vec2 scale;" +
                "varying vec2 v_texCoord;" +
                "void main(void)" +
                "{" +
                "   v_texCoord = vec2(v2uv.x, v2uv.y);" +
                "   vec4 vt0= vec4(v3Pos.x*scale.x,v3Pos.y*scale.y,v3Pos.z,1.0);" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        UIImageShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D s_texture;\n" +
                "uniform float alpha;" +
                "varying vec2 v_texCoord;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                "infoUv.w = alpha;\n" +
                "infoUv.xyz *= infoUv.w;\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        UIImageShader.UI_IMG_SHADER = "UI_img_Shader";
        return UIImageShader;
    }(tl3d.Shader3D));
    tl3d.UIImageShader = UIImageShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UIMaskShader = /** @class */ (function (_super) {
        __extends(UIMaskShader, _super);
        function UIMaskShader() {
            return _super.call(this) || this;
        }
        UIMaskShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Pos");
        };
        UIMaskShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Pos;" +
                "uniform vec4 ui;" +
                "void main(void)" +
                "{" +
                "   vec3 pos = vec3(0.0,0.0,0.0);" +
                "   pos.xy = v3Pos.xy * ui.zw * 2.0;" +
                "   pos.x += ui.x * 2.0 - 1.0;" +
                "   pos.y += -ui.y * 2.0 + 1.0;" +
                "   vec4 vt0= vec4(pos, 1.0);" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        UIMaskShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "void main(void)\n" +
                "{\n" +
                "gl_FragColor = vec4(0.5,0.5,0.5,1.0);\n" +
                "}";
            return $str;
        };
        UIMaskShader.UI_MASK_SHADER = "UImaskShader";
        return UIMaskShader;
    }(tl3d.Shader3D));
    tl3d.UIMaskShader = UIMaskShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UIShader = /** @class */ (function (_super) {
        __extends(UIShader, _super);
        function UIShader() {
            return _super.call(this) || this;
        }
        UIShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Pos");
            $context.bindAttribLocation(this.program, 1, "v2uv");
        };
        UIShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Pos;" +
                "attribute vec3 v2uv;" +
                "uniform vec4 ui[50];" +
                "uniform vec4 ui2[50];" +
                "varying vec2 v_texCoord;" +
                "void main(void)" +
                "{" +
                "   vec4 data = ui2[int(v2uv.z)];" +
                "   v_texCoord = vec2(v2uv.x * data.x + data.z, v2uv.y * data.y + data.w);" +
                "   data = ui[int(v2uv.z)];" +
                "   vec3 pos = vec3(0.0,0.0,0.0);" +
                "   pos.xy = v3Pos.xy * data.zw * 2.0;" +
                "   pos.x += data.x * 2.0 - 1.0;" +
                "   pos.y += -data.y * 2.0 + 1.0;" +
                "   vec4 vt0= vec4(pos, 1.0);" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        UIShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D s_texture;\n" +
                "varying vec2 v_texCoord;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                "infoUv.xyz *= infoUv.w;\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        UIShader.UI_SHADER = "UIShader";
        return UIShader;
    }(tl3d.Shader3D));
    tl3d.UIShader = UIShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SceneManager = /** @class */ (function () {
        function SceneManager() {
            this._ready = false;
            this.render = true;
            this._particletime = 0;
            this.renderDic = new Object;
            this._displayList = new Array;
            this._displaySpriteList = new Array;
            this._displayRoleList = new Array;
            this._display2DList = new Array;
            this.startTime = tl3d.TimeUtil.START_TIME;
            this._time = tl3d.TimeUtil.getTimer(this.startTime);
            this._sceneDic = new Object;
            this.initScene();
            this._particleList = new Array;
            //
            this.shadowMgr = new tl3d.ShadowManager();
            this.skillMgr = new tl3d.SkillManager(this);
            this.groupDataMgr = new tl3d.GroupDataManager(this);
        }
        Object.defineProperty(SceneManager.prototype, "displayList", {
            get: function () {
                return this._displayList;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "displayRoleList", {
            get: function () {
                return this._displayRoleList;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "displaySpriteList", {
            get: function () {
                return this._displaySpriteList;
            },
            enumerable: true,
            configurable: true
        });
        SceneManager.prototype.testUrl = function ($url) {
            return this._currentUrl == $url;
        };
        SceneManager.prototype.loadScene = function ($url, $completeFun, $progressFun, $analysisCompleteFun) {
            var _this = this;
            if (this._currentUrl == $url) { //原场景不加载
                this._ready = true;
                $completeFun();
                var sceneRes = tl3d.SceneResManager.getInstance().getRes($url);
                sceneRes && this.setFogData(sceneRes.sceneData);
                $analysisCompleteFun();
                return;
            }
            this.clearStaticScene();
            this._ready = false;
            tl3d.SceneResManager.getInstance().loadSceneRes($url, $completeFun, $progressFun, function ($str) {
                _this.loadSceneConfigCom($str);
                $analysisCompleteFun();
            });
            this._currentUrl = $url;
        };
        SceneManager.prototype.addSceneImgBg = function (info) {
            var displayimg = new tl3d.Display3dBg();
            displayimg.setImgInfo(info.url, info.width, info.height);
            this.addDisplay(displayimg);
        };
        SceneManager.prototype.getDisplayByID = function ($type, $id) {
            if ($type == 0) {
                return this._sceneDic["build" + $id];
            }
            else if ($type == 1) {
                return this._sceneDic["particle" + $id];
            }
        };
        SceneManager.prototype.fixAstart = function (pos) {
            for (var i = 0; i < this._displayRoleList.length; i++) {
                this._displayRoleList[i].fixAstartData(pos);
            }
        };
        //设置雾效数据
        SceneManager.prototype.setFogData = function (obj) {
            tl3d.Scene_data.fogColor = [obj.fogColor.x / 255.0, obj.fogColor.y / 255.0, obj.fogColor.z / 255.0];
            var d = obj.fogDistance + 1000; //2000 参考
            var s = obj.fogAttenuation; //0.2 参考
            tl3d.Scene_data.gameAngle = isNaN(obj.gameAngle) ? 0 : obj.gameAngle;
            tl3d.Scene_data.focus3D.rotationY = tl3d.Scene_data.gameAngle;
            tl3d.Scene_data.fogData = [d * s, 1 / ((1 - s) * d)];
        };
        //场景数据加载完毕
        SceneManager.prototype.loadSceneConfigCom = function (obj) {
            this.mapData = obj;
            this._sceneDic = new Object();
            var groundAry = obj.groundItem;
            var buildAry = obj.buildItem;
            this.setFogData(obj);
            tl3d.Scene_data.sceneNumId++;
            for (var j = 0; groundAry && j < groundAry.length; j++) {
                var groundDisplay = this.getGroundSprite(groundAry[j], obj.terrain);
                this.addDisplay(groundDisplay);
            }
            for (var i = 0; i < buildAry.length; i++) {
                var itemObj = buildAry[i];
                if (itemObj.type == tl3d.BaseRes.PREFAB_TYPE) {
                    var itemDisplay = this.getBuildSprite(itemObj);
                    this.addDisplay(itemDisplay);
                }
                else if (itemObj.type == tl3d.BaseRes.SCENE_PARTICLE_TYPE) {
                    var particle = this.getParticleSprite(itemObj);
                    this.addParticle(particle);
                }
            }
            tl3d.Scene_data.light.setData(obj.SunNrm, obj.SunLigth, obj.AmbientLight);
            tl3d.LightProbeManager.getInstance().setLightProbeData(obj.lightProbeItem);
            this._ready = true;
            if (obj.quadTreeData) {
                this._sceneQuadTree = new tl3d.SceneQuadTree();
                this._sceneQuadTree.init(obj.quadTreeData, this._sceneDic);
            }
            else {
                this._sceneQuadTree = null;
            }
        };
        SceneManager.prototype.getGroundSprite = function (itemObj, terrain) {
            var itemDisplay = new tl3d.TerrainDisplay3DSprite();
            itemDisplay.setObjUrl(itemObj.objsurl);
            itemDisplay.setMaterialUrl(itemObj.materialurl, itemObj.materialInfoArr);
            itemDisplay.materialInfoArr = itemObj.materialInfoArr;
            itemDisplay.setLightMapUrl(itemObj.lighturl);
            itemDisplay.scaleX = itemObj.scaleX;
            itemDisplay.scaleY = itemObj.scaleY;
            itemDisplay.scaleZ = itemObj.scaleZ;
            itemDisplay.x = itemObj.x;
            itemDisplay.y = itemObj.y;
            itemDisplay.z = itemObj.z;
            itemDisplay.rotationX = itemObj.rotationX;
            itemDisplay.rotationY = itemObj.rotationY;
            itemDisplay.rotationZ = itemObj.rotationZ;
            itemDisplay.objData.lightuvsOffsets = itemDisplay.objData.uvsOffsets;
            if (terrain) {
                itemDisplay.setGrounDataMesh(terrain[itemObj.id]);
            }
            this._sceneDic["ground" + itemObj.id] = itemDisplay;
            return itemDisplay;
        };
        SceneManager.prototype.makeCollisioin = function (arr) {
        };
        Object.defineProperty(SceneManager.prototype, "ready", {
            get: function () {
                return this._ready;
            },
            set: function ($value) {
                //console.log("--setready--", $value);
                this._ready = $value;
            },
            enumerable: true,
            configurable: true
        });
        SceneManager.prototype.getBuildSprite = function (itemObj) {
            var itemDisplay = new tl3d.Display3DSprite();
            itemDisplay.setObjUrl(itemObj.objsurl);
            itemDisplay.setMaterialUrl(itemObj.materialurl, itemObj.materialInfoArr);
            itemDisplay.materialInfoArr = itemObj.materialInfoArr;
            itemDisplay.setLightMapUrl(itemObj.lighturl);
            itemDisplay.scaleX = itemObj.scaleX;
            itemDisplay.scaleY = itemObj.scaleY;
            itemDisplay.scaleZ = itemObj.scaleZ;
            itemDisplay.x = itemObj.x;
            itemDisplay.y = itemObj.y;
            itemDisplay.z = itemObj.z;
            itemDisplay.rotationX = itemObj.rotationX;
            itemDisplay.rotationY = itemObj.rotationY;
            itemDisplay.rotationZ = itemObj.rotationZ;
            itemDisplay.isPerspective = itemObj.isPerspective;
            itemDisplay.type = 0;
            itemDisplay.id = itemObj.id;
            this._sceneDic["build" + itemObj.id] = itemDisplay;
            return itemDisplay;
        };
        SceneManager.prototype.getParticleSprite = function (itemObj) {
            var particle;
            particle = tl3d.ParticleManager.getInstance().getParticleByte(tl3d.Scene_data.fileRoot + itemObj.url);
            particle.scaleX = itemObj.scaleX;
            particle.scaleY = itemObj.scaleY;
            particle.scaleZ = itemObj.scaleZ;
            particle.x = itemObj.x;
            particle.y = itemObj.y;
            particle.z = itemObj.z;
            particle.rotationX = itemObj.rotationX;
            particle.rotationY = itemObj.rotationY;
            particle.rotationZ = itemObj.rotationZ;
            particle.type = 0;
            this._sceneDic["particle" + itemObj.id] = particle;
            return particle;
        };
        SceneManager.prototype.initScene = function () {
            //this._displayList.push(new GridLineSprite());
        };
        SceneManager.prototype.addDisplay = function ($display) {
            if (this._displayList.indexOf($display) != -1) {
                return;
            }
            this._displayList.push($display);
            $display.addStage();
        };
        SceneManager.prototype.removeDisplay = function ($display) {
            var index = this._displayList.indexOf($display);
            if (index != -1) {
                this._displayList.splice(index, 1);
            }
            $display.removeStage();
        };
        /**
         * 动态添加的staticMesh 物件例如武器等
        */
        SceneManager.prototype.addSpriteDisplay = function ($display) {
            if (this._displaySpriteList.indexOf($display) != -1) {
                return;
            }
            $display.addStage();
            for (var i = 0; i < this._displaySpriteList.length; i++) {
                if (this._displaySpriteList[i].materialUrl == $display.materialUrl) {
                    this._displaySpriteList.splice(i, 0, $display);
                    return;
                }
            }
            this._displaySpriteList.push($display);
        };
        SceneManager.prototype.removeSpriteDisplay = function ($display) {
            var index = this._displaySpriteList.indexOf($display);
            if (index != -1) {
                this._displaySpriteList.splice(index, 1);
            }
            $display.removeStage();
        };
        SceneManager.prototype.addMovieDisplayTop = function ($display) {
            this._displayRoleList.unshift($display);
            $display.addStage();
        };
        SceneManager.prototype.setParticleVisible = function () {
            var $arr = this._particleList;
            for (var i = 0; $arr && i < $arr.length; i++) {
                if (!$arr[i].dynamic && $arr[i].bindVecter3d) {
                    var dis = tl3d.Vector3D.distance(new tl3d.Vector3D(tl3d.Scene_data.focus3D.x, tl3d.Scene_data.focus3D.y, tl3d.Scene_data.focus3D.z), new tl3d.Vector3D($arr[i].x, $arr[i].y, $arr[i].z));
                    $arr[i].sceneVisible = (dis < 1000);
                }
            }
        };
        SceneManager.prototype.upFrame = function () {
            if (this._sceneQuadTree) {
                this._sceneQuadTree.setCircle(tl3d.Scene_data.focus3D.x, tl3d.Scene_data.focus3D.z, SceneManager.mapQudaTreeDistance);
                if (this._sceneQuadTree.needUpdata) {
                    for (var i = 0; i < this._displayList.length; i++) {
                        this._displayList[i].sceneVisible = false;
                        this._displayList[i].sceneVisible = true;
                    }
                    this.setParticleVisible();
                    this._sceneQuadTree.update();
                    this.mathCamFar();
                }
            }
            tl3d.Scene_data.context3D._contextSetTest.clear();
            if (isNaN(this._time)) {
                this._time = tl3d.TimeUtil.getTimer(this.startTime);
            }
            this.updateMovieFrame();
            if (this._ready) {
                this.updateParticleTime();
                this.skillMgr.update();
                if (this.render) {
                    tl3d.Scene_data.context3D.setWriteDepth(true);
                    tl3d.Scene_data.context3D.setDepthTest(true);
                    this.updateStaticDiplay();
                    this.updateSpriteDisplay();
                    this.updateMovieDisplay();
                    this.shadowMgr.update();
                    tl3d.Scene_data.context3D.setWriteDepth(false);
                    this.updateParticles();
                    if (this.bloodMgr)
                        this.bloodMgr.update();
                    tl3d.Scene_data.context3D.setBlendParticleFactors(0);
                    tl3d.Scene_data.context3D.setWriteDepth(true);
                    tl3d.Scene_data.context3D.setWriteDepth(false);
                }
                tl3d.Scene_data.context3D.setDepthTest(false);
                tl3d.UIManager.getInstance().update();
                this.cameraMatrix = tl3d.Scene_data.cam3D.cameraMatrix.clone();
                this.viewMatrx3D = tl3d.Scene_data.viewMatrx3D.clone();
            }
        };
        SceneManager.prototype.updateFBO = function () {
            if (!tl3d.Scene_data.fbo) {
                tl3d.Scene_data.fbo = tl3d.Scene_data.context3D.getFBO();
            }
            if (this._displayList.length == 0) {
                return;
            }
            tl3d.Scene_data.context3D.updateFBO(tl3d.Scene_data.fbo);
            tl3d.Scene_data.viewMatrx3D.identity();
            tl3d.Scene_data.context3D.renderContext.viewport(0, 0, tl3d.FBO.fw, tl3d.FBO.fh);
            tl3d.Scene_data.viewMatrx3D.perspectiveFieldOfViewLH(2, 1, 50, tl3d.Scene_data.camFar);
            tl3d.Scene_data.viewMatrx3D.appendScale(2, 2 * (tl3d.Scene_data.stageWidth / tl3d.Scene_data.stageHeight), 1);
            tl3d.MathClass.updateVp();
            this.updateStaticDiplay();
            tl3d.Engine.resetSize();
            tl3d.Scene_data.context3D.renderContext.bindFramebuffer(tl3d.Scene_data.context3D.renderContext.FRAMEBUFFER, null);
        };
        SceneManager.prototype.addDisplay2DList = function ($dis) {
            this._display2DList.push($dis);
        };
        SceneManager.prototype.mathCamFar = function () {
            var $p = new tl3d.Vector3D;
            var $far = 0;
            for (var i = 0; i < this._displayList.length; i++) {
                var $dis = this._displayList[i];
                if ($dis.sceneVisible && $dis.aabb) {
                    var $m = $dis.posMatrix.clone();
                    $m.append(tl3d.Scene_data.cam3D.cameraMatrix);
                    var $aabbVect = $dis.aabbVect;
                    for (var k = 0; k < $aabbVect.length; k++) {
                        $p = tl3d.Scene_data.cam3D.cameraMatrix.transformVector($aabbVect[k]);
                        if ($p.z > $far) {
                            $far = $p.z;
                        }
                    }
                    /*
                    if (this._displayList[i].objData) {
                    
                        for (var j: number = 0; j < $dis.objData.vertices.length/3; j++) {
                            $p.x = $dis.objData.vertices[j * 3 + 0]
                            $p.y = $dis.objData.vertices[j * 3 + 1]
                            $p.z = $dis.objData.vertices[j * 3 + 2]
                            $p = $dis.posMatrix.transformVector($p);
                            $p=Scene_data.cam3D.cameraMatrix.transformVector($p)
                            if ($p.z > $far) {
                                $far = $p.z
                            }
                        }
                    }
                    */
                }
            }
            tl3d.Scene_data.camFar = Math.max(500, $far + 100);
            tl3d.Engine.resetViewMatrx3D();
        };
        SceneManager.prototype.updateStaticDiplay = function () {
            var num = 0;
            for (var i = 0; i < this._displayList.length; i++) {
                this._displayList[i].update();
                // if (this._displayList[i].sceneVisible) {
                //     num++;
                // }
            }
            // FpsMc.tipStr = "drawNum:" + (num + this._displayRoleList.length) + "/" + this._displayList.length; 
        };
        SceneManager.prototype.updateStaticBind = function () {
            // for (var i: number = 0; i < this._displayList.length; i++) {
            //     this._displayList[i].updateBind();
            // }
        };
        SceneManager.prototype.updateSpriteDisplay = function () {
            for (var i = 0; i < this._displaySpriteList.length; i++) {
                this._displaySpriteList[i].update();
            }
        };
        SceneManager.prototype.updateMovieDisplay = function () {
            for (var i = 0; i < this._displayRoleList.length; i++) {
                this._displayRoleList[i].update();
            }
            // if (this._displayRoleList.length) {
            //    Scene_data.context3D.setVa(0, 2, null); //如果有角色,在这里要将顶点置空  ->$$$ 需要优化。这里临时处理
            //    Scene_data.context3D.setVa(1, 2, null); //如果有角色,在这里要将顶点置空  ->$$$ 需要优化。这里临时处理
            //    Scene_data.context3D.setVa(2, 2, null); //如果有角色,在这里要将顶点置空  ->$$$ 需要优化。这里临时处理
            // }
        };
        SceneManager.prototype.updateMovieFrame = function () {
            var t = tl3d.TimeUtil.getTimer(this.startTime);
            var delay = t - this._time;
            this._time = t;
            for (var i = 0; i < this._displayRoleList.length; i++) {
                this._displayRoleList[i].updateFrame(delay);
            }
            //  FpsMc.tipStr = "人数:" + (this._displayRoleList.length) 
        };
        SceneManager.prototype.changeBloodManager = function ($bloodManager) {
            this.bloodMgr = $bloodManager;
        };
        SceneManager.prototype.addMovieDisplay = function ($display) {
            $display._scene = this;
            this._displayRoleList.push($display);
            $display.addStage();
        };
        SceneManager.prototype.clearStaticScene = function () {
            //清理角色
            for (var key in this._sceneDic) {
                var obj = this._sceneDic[key];
                if (obj instanceof tl3d.CombineParticle) {
                    this.removeParticle(obj);
                }
                if (obj instanceof tl3d.Display3DSprite) {
                    obj.removeStage();
                    obj.destory();
                }
            }
            this._ready = false;
            this._sceneDic = null;
            this._sceneQuadTree = null;
            this._displayList.length = 0;
            this.removeAllMovieDisplay();
            this._displayRoleList.length = 0;
            //清除所有特效（包含遗漏的）
            this.clearAllParticle();
            this._currentUrl = "";
            this.mapData = null;
        };
        SceneManager.prototype.playLyf = function ($url, $pos, $r, $scale) {
            var _this = this;
            if ($r === void 0) { $r = 20; }
            if ($scale === void 0) { $scale = 1; }
            this.groupDataMgr.getGroupData(tl3d.Scene_data.fileRoot + $url, function (groupRes) {
                for (var i = 0; i < groupRes.dataAry.length; i++) {
                    var item = groupRes.dataAry[i];
                    if (item.types == tl3d.BaseRes.SCENE_PARTICLE_TYPE) {
                        var $particle = tl3d.ParticleManager.getInstance().getParticleByte(tl3d.Scene_data.fileRoot + item.particleUrl);
                        $particle.x = $pos.x;
                        $particle.y = $pos.y;
                        $particle.z = $pos.z;
                        $particle.rotationX = $r;
                        $particle.scaleX = $scale;
                        $particle.scaleY = $scale;
                        $particle.scaleZ = $scale;
                        _this.addParticle($particle);
                        $particle.addEventListener(tl3d.BaseEvent.COMPLETE, _this.onPlayCom, _this);
                    }
                    else {
                        console.log("播放的不是单纯特效");
                    }
                }
            });
        };
        SceneManager.prototype.charPlaySkill = function ($char, $skillfile, $skilleff, $cb) {
            if ($skilleff === void 0) { $skilleff = "skill_01"; }
            if ($cb === void 0) { $cb = null; }
            if (!$char._scene.ready) {
                return;
            }
            var $skill = this.skillMgr.getSkill(tl3d.UnitFunction.getSkillUrl($skillfile), $skilleff);
            if (!$skill.keyAry) {
                return;
            }
            if ($skill) {
                $skill.reset();
                $skill.isDeath = false;
            }
            $skill.configFixEffect($char, $cb);
            this.skillMgr.playSkill($skill);
            return $skill;
        };
        SceneManager.prototype.removeCharSkill = function ($skill) {
            $skill.removeSkillForce();
        };
        //清除场景中所有的对象模型
        SceneManager.prototype.removeAllMovieDisplay = function () {
            while (this._displayRoleList.length > 0) {
                var display = this._displayRoleList.splice(0, 1);
                display[0].removeStage();
                display[0].destory();
            }
        };
        //移除场景对象
        SceneManager.prototype.removeMovieDisplay = function ($display) {
            if (!$display)
                return;
            var index = this._displayRoleList.indexOf($display);
            if (index != -1) {
                this._displayRoleList.splice(index, 1);
            }
            $display.removeStage();
            // $display.destory();
        };
        SceneManager.prototype.onPlayCom = function (value) {
            this.removeParticle((value.target));
        };
        SceneManager.prototype.updateParticles = function () {
            // for (var i: number = 0; i < this._particleList.length; i++) {
            //     this._particleList[i].update();
            // }
            this.updateRenderDic();
            this.clearPaticleVa();
        };
        SceneManager.prototype.clearPaticleVa = function () {
            tl3d.Scene_data.context3D.clearVa(2);
            tl3d.Scene_data.context3D.clearVa(3);
            tl3d.Scene_data.context3D.clearVa(4);
            tl3d.Scene_data.context3D.clearVa(5);
        };
        SceneManager.prototype.setParticleHide = function () {
            for (var i = 0; i < this._particleList.length; i++) {
                if (!this._particleList[i].dynamic) {
                    //  this._particleList[i].sceneVisible = false;
                }
            }
        };
        Object.defineProperty(SceneManager.prototype, "particleList", {
            get: function () {
                return this._particleList;
            },
            enumerable: true,
            configurable: true
        });
        SceneManager.prototype.updateParticleTime = function () {
            var _tempTime = tl3d.TimeUtil.getTimer(this.startTime);
            if (this._particletime == 0) { //开始
                this._particletime = _tempTime;
            }
            var t = _tempTime - this._particletime;
            this._particletime = _tempTime;
            for (var i = 0; i < this._particleList.length; i++) {
                if (!this._particleList[i].sceneVisible) {
                    continue;
                }
                this._particleList[i].updateTime(t);
            }
        };
        SceneManager.prototype.addRenderDic = function ($particle) {
            var url = $particle.url;
            if (!this.renderDic[url]) {
                this.renderDic[url] = new Array;
            }
            this.renderDic[url].push($particle);
        };
        SceneManager.prototype.removeRenderDic = function ($particle) {
            var url = $particle.url;
            var indexs = this.renderDic[url].indexOf($particle);
            if (indexs == -1) {
                return;
            }
            this.renderDic[url].splice(indexs, 1);
            if (this.renderDic[url].length == 0) {
                delete this.renderDic[url];
            }
        };
        SceneManager.prototype.updateRenderDic = function () {
            for (var key in this.renderDic) {
                var list = this.renderDic[key];
                if (list.length == 1) {
                    list[0].update();
                }
                else {
                    var size = list[0].size;
                    for (var j = 0; j < size; j++) {
                        for (var i = 0; i < list.length; i++) {
                            list[i].updateItem(j);
                        }
                    }
                }
            }
        };
        SceneManager.prototype.addParticle = function ($particle) {
            if (this._particleList.lastIndexOf($particle) != -1) {
                return;
            }
            this._particleList.push($particle);
            this.addRenderDic($particle);
        };
        SceneManager.prototype.removeParticle = function ($particle) {
            var indexs = this._particleList.indexOf($particle);
            if (indexs == -1) {
                return;
            }
            this._particleList.splice(indexs, 1);
            this.removeRenderDic($particle);
            $particle.reset();
        };
        SceneManager.prototype.clearAllParticle = function () {
            this._particletime = 0;
            while (this._particleList && this._particleList.length > 0) {
                var particle = this._particleList.pop();
                this.removeRenderDic(particle);
                particle.reset();
            }
        };
        SceneManager.mapQudaTreeDistance = 200;
        return SceneManager;
    }());
    tl3d.SceneManager = SceneManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var BaseRes = /** @class */ (function (_super) {
        __extends(BaseRes, _super);
        function BaseRes() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.allImgBytes = 10000000;
            _this.urlCache = {};
            return _this;
        }
        BaseRes.prototype.read = function ($imgFun) {
            if ($imgFun === void 0) { $imgFun = null; }
            this._imgFun = $imgFun;
            var fileType = this._byte.readInt();
            if (fileType == BaseRes.IMG_TYPE) {
                if (tl3d.Scene_data.supportBlob) {
                    this.readImg();
                }
                else {
                    this.readImgLow();
                }
            }
            else if (fileType == BaseRes.OBJS_TYPE) {
                this.readObj(this._byte);
            }
            else if (fileType == BaseRes.MATERIAL_TYPE) {
                this.readMaterial();
            }
            else if (fileType == BaseRes.PARTICLE_TYPE) {
                this.readParticle();
            }
            else if (fileType == BaseRes.ZIP_OBJS_TYPE) {
                this.readZipObj();
            }
        };
        BaseRes.prototype.readZipObj = function () {
            var zipLen = this._byte.readInt();
            var aryBuf = this._byte.buffer.slice(this._byte.position, this._byte.position + zipLen);
            this._byte.position += zipLen;
            var zipedBuf = tl3d.Util.unZip(aryBuf);
            var newByte = new tl3d.TLByteArray(zipedBuf);
            this.readObj(newByte);
        };
        /**
         * h5微端解析效率很高
         */
        BaseRes.prototype.readImg = function () {
            var _this = this;
            this.imgNum = this._byte.readInt();
            this.imgLoadNum = 0;
            // var time: number = TimeUtil.getTimer();
            var ary = new Array;
            var urlAry = new Array;
            for (var i = 0; i < this.imgNum; i++) {
                var url = tl3d.Scene_data.fileRoot + this._byte.readUTF();
                var imgSize = this._byte.readInt();
                if (url.search(".jpng") != -1) {
                    this.readJpngImg(url);
                    continue;
                }
                var imgAryBuffer = this._byte.buffer.slice(this._byte.position, this._byte.position + imgSize);
                this._byte.position += imgSize;
                var blob = new Blob([imgAryBuffer], { type: "application/octet-binary" });
                ary.push(blob);
                urlAry.push(url);
            }
            for (var i = 0; i < ary.length; i++) {
                var img = new Image();
                img.url = urlAry[i];
                img.onload = function (evt) {
                    _this.addImg(evt.target["url"], evt.target);
                    var etimg = evt.target;
                    URL.revokeObjectURL(etimg.src);
                };
                img.src = URL.createObjectURL(ary[i]);
            }
        };
        BaseRes.prototype.readJpngImg = function ($url) {
            var _this = this;
            var rgbSize = this._byte.readInt();
            var imgAryBuffer = this._byte.buffer.slice(this._byte.position, this._byte.position + rgbSize);
            this._byte.position += rgbSize;
            var alphaSize = this._byte.readInt();
            var alphaImgAryBuffer = this._byte.buffer.slice(this._byte.position, this._byte.position + alphaSize);
            this._byte.position += alphaSize;
            var img = new Image();
            var alphaImg = new Image();
            var loadNum = 0;
            var comFun = function (evt) {
                loadNum++;
                if (loadNum < 2) {
                    return;
                }
                var ctx = tl3d.UIManager.getInstance().getContext2D(img.width, img.height);
                ctx.drawImage(img, 0, 0);
                var imgData = ctx.getImageData(0, 0, img.width, img.height);
                ctx.clearRect(0, 0, img.width, img.height);
                ctx.drawImage(alphaImg, 0, 0);
                var alphaImgdata = ctx.getImageData(0, 0, img.width, img.height);
                for (var i = 0; i < imgData.data.length; i += 4) {
                    var per = alphaImgdata.data[i] / 255;
                    // imgData.data[i] *= per;
                    // imgData.data[i + 1] *= per;
                    // imgData.data[i + 2] *= per;
                    imgData.data[i + 3] = alphaImgdata.data[i];
                }
                _this.addImg($url.replace(".jpng", ".png"), imgData);
            };
            img.onload = comFun;
            alphaImg.onload = comFun;
            img.src = 'data:image/png;base64,' + tl3d.Base64.encode(imgAryBuffer);
            alphaImg.src = 'data:image/png;base64,' + tl3d.Base64.encode(alphaImgAryBuffer);
        };
        BaseRes.prototype.readImgLow = function () {
            var _this = this;
            this.imgNum = this._byte.readInt();
            this.imgLoadNum = 0;
            // var time: number = TimeUtil.getTimer();
            var bytes = 0;
            for (var i = 0; i < this.imgNum; i++) {
                var _url = this._byte.readUTF();
                var url = tl3d.Scene_data.fileRoot + tl3d.LoadManager.getInstance().getVersion(_url);
                var imgSize = this._byte.readInt();
                bytes += imgSize;
                var img = new Image();
                img.url = url;
                this.urlCache[url] = tl3d.Scene_data.fileRoot + _url;
                img.onload = function (evt) {
                    _this.loadImg(evt.target);
                };
                img.src = url;
            }
            this.allImgBytes = bytes;
        };
        BaseRes.prototype.loadImg = function (img) {
            var url = this.urlCache[img.url] || img.url;
            tl3d.TextureManager.getInstance().addRes(url, img);
            this.countImg();
        };
        BaseRes.prototype.addImg = function ($url, img) {
            tl3d.TextureManager.getInstance().addRes($url, img);
            this.countImg();
        };
        BaseRes.prototype.countImg = function () {
            this.imgLoadNum++;
            if (this.imgLoadNum == this.imgNum) {
                this._imgComplete = true;
                this.allResCom();
            }
        };
        BaseRes.prototype.readObj = function ($srcByte) {
            var objNum = $srcByte.readInt();
            for (var i = 0; i < objNum; i++) {
                var url = tl3d.Scene_data.fileRoot + $srcByte.readUTF();
                var size = $srcByte.readInt();
                var newByte = new tl3d.TLByteArray();
                newByte.length = size;
                $srcByte.readBytes(newByte, 0, size);
                var objData = tl3d.ObjDataManager.getInstance().loadObjCom(newByte.buffer, url);
            }
            if (this._imgFun) {
                this._imgFun();
            }
        };
        BaseRes.prototype.readMaterial = function () {
            var objNum = this._byte.readInt();
            // var time: number = TimeUtil.getTimer();
            for (var i = 0; i < objNum; i++) {
                var url = tl3d.Scene_data.fileRoot + this._byte.readUTF();
                var size = this._byte.readInt();
                var dataByte = new tl3d.TLByteArray;
                dataByte.length = size;
                this._byte.readBytes(dataByte, 0, size);
                tl3d.MaterialManager.getInstance().addResByte(url, dataByte);
            }
        };
        BaseRes.prototype.readParticle = function () {
            var objNum = this._byte.readInt();
            // var time: number = TimeUtil.getTimer();
            for (var i = 0; i < objNum; i++) {
                var url = tl3d.Scene_data.fileRoot + this._byte.readUTF();
                var size = this._byte.readInt();
                var dataByte = new tl3d.TLByteArray;
                dataByte.length = size;
                this._byte.readBytes(dataByte, 0, size);
                tl3d.ParticleManager.getInstance().addResByte(url, dataByte);
            }
        };
        //读材质参数
        BaseRes.prototype.readMaterialInfo = function () {
            var len = this._byte.readInt();
            if (len > 0) {
                var $arr = new Array;
                for (var i = 0; i < len; i++) {
                    var $temp = new Object();
                    $temp.type = this._byte.readInt();
                    $temp.name = this._byte.readUTF();
                    if ($temp.type == 0) {
                        $temp.url = this._byte.readUTF();
                    }
                    if ($temp.type == 1) {
                        $temp.x = this._byte.readFloat();
                    }
                    if ($temp.type == 2) {
                        $temp.x = this._byte.readFloat();
                        $temp.y = this._byte.readFloat();
                    }
                    if ($temp.type == 3) {
                        $temp.x = this._byte.readFloat();
                        $temp.y = this._byte.readFloat();
                        $temp.z = this._byte.readFloat();
                    }
                    $arr.push($temp);
                }
                return $arr;
            }
            else {
                return null;
            }
        };
        //读取浮点数据，两个字节
        BaseRes.readFloatTwoByte = function (byte, vertices) {
            var verLength = byte.readInt();
            if (verLength > 0) {
                var $scaleNum = byte.readFloat();
                vertices.length = 0;
                for (var i = 0; i < verLength; i++) {
                    vertices.push(byte.readFloatTwoByte($scaleNum));
                }
            }
        };
        //读取一个字节的LightMap
        BaseRes.readFloatOneByte = function (byte, vertices) {
            var verLength = byte.readInt();
            if (verLength > 0) {
                for (var i = 0; i < verLength; i++) {
                    vertices.push((byte.readByte() + 128) / 256);
                }
            }
        };
        BaseRes.readIntForTwoByte = function (byte, indexs) {
            var iLen = byte.readInt();
            for (var i = 0; i < iLen; i++) {
                indexs.push(byte.readShort());
            }
        };
        BaseRes.readIntForOneByte = function (byte, indexs) {
            var iLen = byte.readInt();
            for (var i = 0; i < iLen; i++) {
                indexs.push(byte.readByte());
            }
        };
        /**
         * $readType
         * 0 readFloatTwoByte
         * 1 readFloatOneByte
         * 2 readIntForOneByte
         *  */
        BaseRes.readBytes2ArrayBuffer = function ($byte, $data, $dataWidth, $offset, $stride, $readType) {
            if ($readType === void 0) { $readType = 0; }
            var verLength = $byte.readInt();
            if (verLength <= 0) {
                return;
            }
            var scaleNum;
            if ($readType == 0) {
                scaleNum = $byte.readFloat();
            }
            var readNum = verLength / $dataWidth;
            for (var i = 0; i < readNum; i++) {
                var pos = $stride * i + $offset;
                for (var j = 0; j < $dataWidth; j++) {
                    if ($readType == 0) {
                        $data.setFloat32((pos + j) * 4, $byte.readFloatTwoByte(scaleNum), true);
                    }
                    else if ($readType == 1) {
                        $data.setFloat32((pos + j) * 4, $byte.readFloatOneByte(), true);
                    }
                    else if ($readType == 2) {
                        $data.setFloat32((pos + j) * 4, $byte.readByte(), true);
                    }
                    else if ($readType == 3) {
                        $data.setFloat32((pos + j) * 4, ($byte.readByte() + 128) / 255, true);
                    }
                    else if ($readType == 4) {
                        $data.setFloat32((pos + j) * 4, $byte.readFloat(), true);
                    }
                }
            }
        };
        //读取材质参数
        BaseRes.readMaterialParamData = function (byte) {
            var mpNum = byte.readInt();
            if (mpNum > 0) {
                var mpAry = new Array;
                for (var j = 0; j < mpNum; j++) {
                    var obj = new Object;
                    obj.name = byte.readUTF();
                    obj.type = byte.readByte();
                    if (obj.type == 0) {
                        obj.url = byte.readUTF();
                    }
                    else if (obj.type == 1) {
                        obj.x = byte.readFloat();
                    }
                    else if (obj.type == 2) {
                        obj.x = byte.readFloat();
                        obj.y = byte.readFloat();
                    }
                    else if (obj.type == 3) {
                        obj.x = byte.readFloat();
                        obj.y = byte.readFloat();
                        obj.z = byte.readFloat();
                    }
                    mpAry.push(obj);
                }
                return mpAry;
            }
            return null;
        };
        BaseRes.prototype.allResCom = function () {
            if (this._imgFun) {
                this._imgFun();
            }
        };
        BaseRes.IMG_TYPE = 1;
        BaseRes.OBJS_TYPE = 2;
        BaseRes.MATERIAL_TYPE = 3;
        BaseRes.PARTICLE_TYPE = 4;
        BaseRes.SCENE_TYPE = 5;
        BaseRes.ZIP_OBJS_TYPE = 6;
        BaseRes.PREFAB_TYPE = 1;
        BaseRes.SCENE_PARTICLE_TYPE = 11;
        return BaseRes;
    }(tl3d.ResCount));
    tl3d.BaseRes = BaseRes;
})(tl3d || (tl3d = {}));
/// <reference path="../utils/res/BaseRes.ts" />

(function (tl3d) {
    var SceneRes = /** @class */ (function (_super) {
        __extends(SceneRes, _super);
        function SceneRes() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SceneRes.prototype.load = function ($url, $completeFun, $progressFun, $readDataFun) {
            var _this = this;
            this._completeFun = $completeFun;
            this._readDataFun = $readDataFun;
            this._progressFun = $progressFun;
            if (this.sceneData) {
                if (this.isNeedReload()) {
                    $completeFun();
                    $progressFun(1);
                    this.applyByteArray();
                }
                else {
                    $completeFun();
                    $progressFun(1);
                    $readDataFun(this.sceneData);
                }
                return;
            }
            var config = SceneRes.sceneConfigData;
            //config[$url] = null;
            if (config && config[$url]) {
                ////console.log($url)
                this.loadZipMap($url, config[$url].len);
            }
            else {
                $url = tl3d.Scene_data.fileRoot + tl3d.UnitFunction.getMapUrl($url);
                tl3d.LoadManager.getInstance().load($url, tl3d.LoadManager.BYTE_TYPE, function ($byte) {
                    _this.loadComplete($byte);
                    //this.unZip($byte);
                }, null);
            }
        };
        SceneRes.prototype.loadZipMap = function (name, size) {
            var _this = this;
            var xhrList = new Array;
            var aryBufList = new Array;
            var comNum = 0;
            var proList = new Array;
            for (var i = 0; i < size; i++) {
                proList[i] = 0;
            }
            var comFun = function ($curxhr) {
                var arybuf = $curxhr.response;
                var idx = xhrList.indexOf($curxhr);
                aryBufList[idx] = arybuf;
                comNum++;
                if (comNum == xhrList.length) { //加载完成
                    var bufSize = 0;
                    for (var i = 0; i < aryBufList.length; i++) {
                        bufSize += aryBufList[i].byteLength;
                    }
                    var newBuf = new Uint8Array(bufSize);
                    var flag = 0;
                    for (var i = 0; i < aryBufList.length; i++) {
                        newBuf.set(new Uint8Array(aryBufList[i]), flag);
                        flag += aryBufList[i].byteLength;
                    }
                    _this.loadComplete(newBuf.buffer);
                    //this.unZip(newBuf.buffer);
                }
            };
            var proFun = function ($curxhr, num) {
                var idx = xhrList.indexOf($curxhr);
                proList[idx] = num;
                var allPre = 0;
                for (var i = 0; i < size; i++) {
                    allPre += proList[i];
                }
                allPre = allPre / size;
                ////console.log("--------地图加载@：",idx,num,allPre);
                _this._progressFun(allPre);
            };
            for (var i = 0; i < size; i++) {
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function (e) {
                    var curXhr = e.target;
                    if (curXhr.status == 200 && curXhr.readyState == 4) {
                        comFun(curXhr);
                    }
                };
                xhr.onprogress = function (e) {
                    var curXhr = e.target;
                    ////console.log("++++++++地图加载@：",e,e.loaded,e.total);
                    proFun(curXhr, e.loaded / e.total);
                };
                var url = tl3d.Scene_data.fileRoot + tl3d.UnitFunction.getZipMapUrl(name) + i + ".txt";
                xhrList.push(xhr);
                xhr.open("GET", url, true);
                xhr.responseType = "arraybuffer";
                xhr.send();
            }
        };
        //private curTime:number = 0;
        SceneRes.prototype.isNeedReload = function () {
            var ary = this.sceneData.buildItem;
            for (var i = 0; i < ary.length; i++) {
                if (ary[i].type == tl3d.BaseRes.PREFAB_TYPE && ary[i].lighturl) {
                    var url = tl3d.Scene_data.fileRoot + ary[i].lighturl;
                    if (tl3d.TextureManager.getInstance().hasTexture(url)) {
                        return false;
                    }
                    else {
                        return true;
                    }
                }
            }
            return ((tl3d.ResCount.GCTime - this.idleTime) < 10);
        };
        SceneRes.prototype.loadComplete = function ($byte) {
            //alert(TimeUtil.getTimer()-this.curTime);
            this._byte = new tl3d.TLByteArray($byte);
            this.applyByteArray();
        };
        SceneRes.prototype.applyByteArray = function () {
            var _this = this;
            this._byte.position = 0;
            this.version = this._byte.readInt();
            this.read(function () { _this.readNext(); }); //img
        };
        // public readZipNext():void{
        //     this.read(() => { this.readNext() });//zipobj
        // }
        SceneRes.prototype.readNext = function () {
            this.read(); //obj
            this.read(); //material
            this.read(); //particle;
            this.readScene();
            this._readDataFun(this.sceneData);
        };
        SceneRes.prototype.readScene = function () {
            var types = this._byte.readInt();
            this.readAstat();
            if (this.version >= 28) {
                this.readTerrainIdInfoBitmapData(this._byte);
            }
            var size = this._byte.readInt();
            this.sceneData = JSON.parse(this._byte.readUTFBytes(size));
            this.sceneData.astar = this._astarDataMesh;
            this.sceneData.terrain = this._terrainDataItem;
        };
        SceneRes.prototype.readTerrainIdInfoBitmapData = function ($byte) {
            var $len = $byte.readInt();
            if ($len) {
                //var newByte: ByteArray = new ByteArray();
                //newByte.length = $len;
                //$byte.readBytes(newByte, 0, $len);
                var zipLen = $len;
                var aryBuf = $byte.buffer.slice($byte.position, $byte.position + zipLen);
                $byte.position += zipLen;
                var zipedBuf = tl3d.Util.unZip(aryBuf);
                var newByte = new tl3d.TLByteArray(zipedBuf);
                this._terrainDataItem = tl3d.GroundDataMesh.meshAllgroundData(newByte);
            }
        };
        SceneRes.prototype.readAstat = function () {
            var hasAstat = this._byte.readBoolean();
            if (hasAstat) {
                this._astarDataMesh = new AstarDataMesh;
                this._astarDataMesh.aPos = new tl3d.Vector3D;
                this._astarDataMesh.astarItem = new Array;
                this._astarDataMesh.heightItem = new Array;
                this._astarDataMesh.jumpItem = new Array;
                this._astarDataMesh.midu = this._byte.readFloat();
                this._astarDataMesh.aPos.x = this._byte.readFloat();
                this._astarDataMesh.aPos.y = this._byte.readFloat();
                this._astarDataMesh.aPos.z = this._byte.readFloat();
                var i;
                var j;
                var tw = this._byte.readInt();
                var th = this._byte.readInt();
                this._astarDataMesh.width = tw;
                this._astarDataMesh.height = th;
                if (this.version < 25) {
                    for (i = 0; i < th; i++) {
                        var tempAstar = new Array;
                        for (j = 0; j < tw; j++) {
                            tempAstar.push(this._byte.readFloat());
                        }
                        this._astarDataMesh.astarItem.push(tempAstar);
                    }
                    for (i = 0; i < th; i++) {
                        var tempHeightArr = new Array;
                        for (j = 0; j < tw; j++) {
                            tempHeightArr.push(this._byte.readFloat());
                        }
                        this._astarDataMesh.heightItem.push(tempHeightArr);
                    }
                }
                else {
                    var $heightScaleNum = this._byte.readFloat();
                    var $astrBase = this.readAstarFromByte(this._byte);
                    var $jumpBase = this.readAstarFromByte(this._byte);
                    var $astrBaseId = 0;
                    var $jumpBaseId = 0;
                    for (i = 0; i < th; i++) {
                        var tempAstar = new Array;
                        var tempJump = new Array;
                        for (j = 0; j < tw; j++) {
                            var astarNum = $astrBase[$astrBaseId++];
                            tempAstar.push(astarNum);
                            if (astarNum == 1) {
                                var ssss = $jumpBase[$jumpBaseId++];
                                tempJump.push(ssss);
                            }
                            else {
                                tempJump.push(0);
                            }
                        }
                        this._astarDataMesh.astarItem.push(tempAstar);
                        this._astarDataMesh.jumpItem.push(tempJump);
                    }
                    this._astarDataMesh.jumpItem;
                    for (i = 0; i < th; i++) {
                        var tempHeightArr = new Array;
                        for (j = 0; j < tw; j++) {
                            tempHeightArr.push(this._byte.readShort() / $heightScaleNum);
                        }
                        this._astarDataMesh.heightItem.push(tempHeightArr);
                    }
                }
            }
        };
        SceneRes.prototype.readAstarFromByte = function ($byte) {
            var $len = $byte.readUnsignedInt();
            var $intLen = Math.ceil($len / 32);
            var $astrBase = new Array;
            for (var i = 0; i < $intLen; i++) {
                var $num = $byte.readUnsignedInt();
                for (var j = 0; j < 32; j++) {
                    var $ast = $num & 1;
                    if ($astrBase.length < $len) {
                        $astrBase.push($ast);
                    }
                    $num >>= 1;
                }
            }
            return $astrBase;
        };
        //统计下载图片数量
        SceneRes.prototype.countImg = function () {
            if (this._progressFun) {
                this._progressFun(this.imgLoadNum / this.imgNum);
            }
            _super.prototype.countImg.call(this);
        };
        //数据数据解析完毕
        SceneRes.prototype.allResCom = function () {
            _super.prototype.allResCom.call(this);
            if (this._completeFun) {
                this._completeFun();
            }
        };
        /*
        private smoothHeight($base: number = null): void
        {
            for (var i: number = 0; i < this._astarDataMesh.heightItem.length; i++) {
                for (var j: number = 0; j < this._astarDataMesh.heightItem[i].length; j++) {
                    if (this._astarDataMesh.heightItem[i][j]==null) {
                        this._astarDataMesh.heightItem[i][j] = this.getRoundHeight(i, j, $base)
                    }
                }
            }
    
        }
        private getRoundHeight($tx: number, $ty: number,$base:number): number
        {
            var $item:Array<Vector2D>=new Array
            $item.push(new Vector2D($tx - 1, $ty - 1));
            $item.push(new Vector2D($tx, $ty - 1));
            $item.push(new Vector2D($tx + 1, $ty - 1));
    
            $item.push(new Vector2D($tx - 1, $ty));
            $item.push(new Vector2D($tx + 1, $ty));
    
            $item.push(new Vector2D($tx - 1, $ty + 1));
            $item.push(new Vector2D($tx, $ty + 1));
            $item.push(new Vector2D($tx + 1, $ty + 1));
    
            var totalNum: number = 0
            var addNum: number = 0;
            for (var i: number = 0; i < $item.length; i++) {
                var pos: Vector2D = $item[i]
                if (this._astarDataMesh.heightItem[pos.x] && this._astarDataMesh.heightItem[pos.x][pos.y]) {
                    if (this._astarDataMesh.heightItem[pos.x][pos.y]!=null) {
                        totalNum += this._astarDataMesh.heightItem[pos.x][pos.y];
                        addNum++;
                    }
                }
            }
            if (addNum > 0) {
                return totalNum / addNum;
            } else {
                return $base;
            }
      
        }
        */
        SceneRes.prototype.destory = function () {
            _super.prototype.destory.call(this);
        };
        return SceneRes;
    }(tl3d.BaseRes));
    tl3d.SceneRes = SceneRes;
    var AstarDataMesh = /** @class */ (function () {
        function AstarDataMesh() {
        }
        return AstarDataMesh;
    }());
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var LineDisplayShader = /** @class */ (function (_super) {
        __extends(LineDisplayShader, _super);
        function LineDisplayShader() {
            return _super.call(this) || this;
        }
        LineDisplayShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "v3Color");
        };
        LineDisplayShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Position;" +
                "attribute vec3 v3Color;" +
                "uniform mat4 viewMatrix3D;" +
                "uniform mat4 camMatrix3D;" +
                "uniform mat4 posMatrix3D;" +
                "varying vec4 colorData;" +
                "void main(void)" +
                "{" +
                "   vec4 vt0= vec4(v3Position, 1.0);" +
                "   colorData =vec4(v3Color,1) ;" +
                "   vt0 = posMatrix3D * vt0;" +
                "   vt0 = camMatrix3D * vt0;" +
                "   vt0 = viewMatrix3D * vt0;" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        LineDisplayShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "varying vec4 colorData;\n" +
                "void main(void)\n" +
                "{\n" +
                "gl_FragColor =colorData;\n" +
                "}";
            return $str;
        };
        LineDisplayShader.LineShader = "LineShader";
        return LineDisplayShader;
    }(tl3d.Shader3D));
    tl3d.LineDisplayShader = LineDisplayShader;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var LineDisplaySprite = /** @class */ (function (_super) {
        __extends(LineDisplaySprite, _super);
        function LineDisplaySprite() {
            var _this = _super.call(this) || this;
            _this.baseColor = new tl3d.Vector3D(1, 0, 0);
            _this.objData = new tl3d.ObjData;
            _this.shader = tl3d.ProgrmaManager.getInstance().getProgram(tl3d.LineDisplayShader.LineShader);
            _this.program = _this.shader.program;
            _this.makeLineMode(new tl3d.Vector3D(0, 0, 0), new tl3d.Vector3D(100, 0, 0), new tl3d.Vector3D());
            _this.makeLineMode(new tl3d.Vector3D(0, 0, 0), new tl3d.Vector3D(100, 0, 100), new tl3d.Vector3D());
            _this.makeLineMode(new tl3d.Vector3D(100, 0, 0), new tl3d.Vector3D(100, 0, 100), new tl3d.Vector3D());
            _this.upToGpu();
            return _this;
        }
        LineDisplaySprite.prototype.makeLineMode = function (a, b, $color) {
            if ($color === void 0) { $color = null; }
            if (!this.lineVecPos || !this.lineIndex) {
                this.clear();
            }
            if ($color) {
                this.baseColor = $color;
            }
            this.lineVecPos.push(a.x, a.y, a.z);
            this.lineVecPos.push(b.x, b.y, b.z);
            this.lineColor.push(this.baseColor.x, this.baseColor.y, this.baseColor.z);
            this.lineColor.push(this.baseColor.x, this.baseColor.y, this.baseColor.z);
            this.lineIndex.push(this.lineIndex.length + 0, this.lineIndex.length + 1);
        };
        LineDisplaySprite.prototype.clear = function () {
            this.lineVecPos = new Array;
            this.lineIndex = new Array;
            this.lineColor = new Array;
            if (this.objData.indexBuffer) {
                this.objData.indexBuffer = null;
            }
        };
        LineDisplaySprite.prototype.upToGpu = function () {
            if (this.lineIndex.length) {
                //console.log("A星长度", this.lineIndex.length)
                this.objData.treNum = this.lineIndex.length;
                this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.lineVecPos);
                this.objData.normalsBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.lineColor);
                this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.lineIndex);
            }
        };
        LineDisplaySprite.prototype.update = function () {
            if (this.objData && this.objData.indexBuffer) {
                tl3d.Scene_data.context3D.setProgram(this.program);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "viewMatrix3D", tl3d.Scene_data.viewMatrx3D.m);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "camMatrix3D", tl3d.Scene_data.cam3D.cameraMatrix.m);
                tl3d.Scene_data.context3D.setVcMatrix4fv(this.shader, "posMatrix3D", this.posMatrix.m);
                tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
                tl3d.Scene_data.context3D.setVa(1, 3, this.objData.normalsBuffer);
                tl3d.Scene_data.context3D.drawLine(this.objData.indexBuffer, this.objData.treNum);
            }
        };
        return LineDisplaySprite;
    }(tl3d.Display3D));
    tl3d.LineDisplaySprite = LineDisplaySprite;
    var MulLineSprite = /** @class */ (function (_super) {
        __extends(MulLineSprite, _super);
        function MulLineSprite() {
            var _this = _super.call(this) || this;
            if (!_this.itemSprite) {
                _this.itemSprite = new Array;
            }
            return _this;
        }
        MulLineSprite.prototype.makeLineMode = function (a, b, $color) {
            if ($color === void 0) { $color = null; }
            _super.prototype.makeLineMode.call(this, a, b, $color);
            var $dic = this.getSprite();
            $dic.makeLineMode(a, b, $color);
        };
        MulLineSprite.prototype.getSprite = function () {
            var $id = Math.floor(this.lineIndex.length / 10000);
            if (!this.itemSprite[$id]) {
                var $temp = new LineDisplaySprite;
                $temp.clear();
                $temp.baseColor = this.baseColor;
                this.itemSprite.push($temp);
            }
            return this.itemSprite[$id];
        };
        MulLineSprite.prototype.update = function () {
            for (var i = 0; i < this.itemSprite.length; i++) {
                this.itemSprite[i].posMatrix = this.posMatrix;
                this.itemSprite[i].update();
            }
        };
        MulLineSprite.prototype.upToGpu = function () {
            for (var i = 0; i < this.itemSprite.length; i++) {
                this.itemSprite[i].upToGpu();
            }
        };
        MulLineSprite.prototype.clear = function () {
            _super.prototype.clear.call(this);
            if (!this.itemSprite) {
                this.itemSprite = new Array;
            }
            for (var i = 0; this.itemSprite && i < this.itemSprite.length; i++) {
                this.itemSprite[i].clear();
            }
        };
        return MulLineSprite;
    }(LineDisplaySprite));
    tl3d.MulLineSprite = MulLineSprite;
    var GridLineSprite = /** @class */ (function (_super) {
        __extends(GridLineSprite, _super);
        function GridLineSprite() {
            var _this = _super.call(this) || this;
            _this.makeGridData();
            return _this;
        }
        GridLineSprite.prototype.makeGridData = function () {
            var w = 100;
            var n = 10;
            var skeep = w / n;
            this.clear();
            var a;
            var b;
            a = new tl3d.Vector3D(0, 0, +w);
            b = new tl3d.Vector3D(0, 0, -w);
            this.makeLineMode(a, b, new tl3d.Vector3D(0, 0, 1, 1));
            a = new tl3d.Vector3D(+w, 0, 0);
            b = new tl3d.Vector3D(-w, 0, 0);
            this.makeLineMode(a, b, new tl3d.Vector3D(1, 0, 0, 1));
            this.baseColor = new tl3d.Vector3D(128 / 255, 128 / 255, 128 / 255, 1);
            for (var i = 1; i <= n; i++) {
                a = new tl3d.Vector3D(+i * skeep, 0, +w);
                b = new tl3d.Vector3D(+i * skeep, 0, -w);
                this.makeLineMode(a, b);
                a = new tl3d.Vector3D(-i * skeep, 0, +w);
                b = new tl3d.Vector3D(-i * skeep, 0, -w);
                this.makeLineMode(a, b);
                a = new tl3d.Vector3D(+w, 0, +i * skeep);
                b = new tl3d.Vector3D(-w, 0, +i * skeep);
                this.makeLineMode(a, b);
                a = new tl3d.Vector3D(+w, 0, -i * skeep);
                b = new tl3d.Vector3D(-w, 0, -i * skeep);
                this.makeLineMode(a, b);
            }
            this.upToGpu();
        };
        return GridLineSprite;
    }(LineDisplaySprite));
    tl3d.GridLineSprite = GridLineSprite;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var QuadTreeNode = /** @class */ (function () {
        //public pointList: Array<Vector2D>;
        function QuadTreeNode($x, $y, $z, $width, $height, $depth) {
            this.x = $x;
            this.y = $y;
            this.z = $z;
            this.width = $width;
            this.height = $height;
            this.depth = $depth;
            //this.pointList = new Array;
            //this.pointList.push(new Vector2D(this.x, this.y));
            //this.pointList.push(new Vector2D(this.x + this.width, this.y));
            //this.pointList.push(new Vector2D(this.x + this.width, this.y + this.height));
            //this.pointList.push(new Vector2D(this.x, this.y + this.height));
        }
        QuadTreeNode.prototype.testViewFrustum = function (face, ray) {
            if (this.sun && this.sun.length == 1) {
                this.sun[0].testViewFrustum(face, ray);
                return;
            }
            if (this.testViewFrustumResult(face)) {
                if (this.target) {
                    if (this.target.isPerspective) {
                        if (!this.testRay(ray)) {
                            this.target.sceneVisible = true;
                        }
                    }
                    else {
                        this.target.sceneVisible = true;
                    }
                }
                if (this.sun) {
                    for (var i = 0; i < this.sun.length; i++) {
                        this.sun[i].testViewFrustum(face, ray);
                    }
                }
            }
        };
        QuadTreeNode.prototype.testViewFrustumResult = function (face) {
            var pos = new tl3d.Vector3D(this.x, this.y, this.z);
            var whd = new tl3d.Vector3D(this.width, this.height, this.depth);
            var bInSide = true;
            for (var j = 0; j < face.length; j++) {
                var vcMin = pos;
                var vcMax = pos.add(whd);
                var _vcMax = new tl3d.Vector3D();
                // var _vcMin: Vector3D = new Vector3D();
                if (face[j].x > 0) {
                    _vcMax.x = vcMax.x;
                    //_vcMin.x = vcMin.x;
                }
                else {
                    //_vcMin.x = vcMax.x;
                    _vcMax.x = vcMin.x;
                }
                if (face[j].y > 0) {
                    _vcMax.y = vcMax.y;
                    //_vcMin.y = vcMin.y;
                }
                else {
                    //_vcMin.y = vcMax.y;
                    _vcMax.y = vcMin.y;
                }
                if (face[j].z > 0) {
                    _vcMax.z = vcMax.z;
                    //_vcMin.z = vcMin.z;
                }
                else {
                    //_vcMin.z = vcMax.z;
                    _vcMax.z = vcMin.z;
                }
                var num = face[j].dot(_vcMax) + face[j].w;
                if (num < 0) {
                    bInSide = false;
                    break;
                }
            }
            return bInSide;
        };
        QuadTreeNode.prototype.testRay = function (ray) {
            var ox = ray.o.x;
            var oy = ray.o.y;
            var oz = ray.o.z;
            var dx = ray.d.x;
            var dy = ray.d.y;
            var dz = ray.d.z;
            var tx_min, ty_min, tz_min;
            var tx_max, ty_max, tz_max;
            var x0 = this.x;
            var y0 = this.y;
            var z0 = this.z;
            var x1 = this.x + this.width;
            var y1 = this.y + this.height;
            var z1 = this.z + this.depth;
            var a = 1.0 / dx;
            if (a >= 0) {
                tx_min = (x0 - ox) * a;
                tx_max = (x1 - ox) * a;
            }
            else {
                tx_min = (x1 - ox) * a;
                tx_max = (x0 - ox) * a;
            }
            var b = 1.0 / dy;
            if (b >= 0) {
                ty_min = (y0 - oy) * b;
                ty_max = (y1 - oy) * b;
            }
            else {
                ty_min = (y1 - oy) * b;
                ty_max = (y0 - oy) * b;
            }
            var c = 1.0 / dz;
            if (c >= 0) {
                tz_min = (z0 - oz) * c;
                tz_max = (z1 - oz) * c;
            }
            else {
                tz_min = (z1 - oz) * c;
                tz_max = (z0 - oz) * c;
            }
            var t0, t1;
            // find largest entering t value
            if (tx_min > ty_min)
                t0 = tx_min;
            else
                t0 = ty_min;
            if (tz_min > t0)
                t0 = tz_min;
            // find smallest exiting t value
            if (tx_max < ty_max)
                t1 = tx_max;
            else
                t1 = ty_max;
            if (tz_max < t1)
                t1 = tz_max;
            var kEpsilon = 0.0001;
            var tmin = 0;
            if (t0 < t1 && t1 > kEpsilon) { // condition for a hit
                if (t0 > kEpsilon) {
                    tmin = t0; // ray hits outside surface
                }
                else {
                    tmin = t1; // ray hits inside surface
                }
                if (tmin < ray.baseT) {
                    return true;
                }
            }
            else
                return false;
        };
        return QuadTreeNode;
    }());
    tl3d.QuadTreeNode = QuadTreeNode;
    var Ray = /** @class */ (function () {
        function Ray() {
            this.o = new tl3d.Vector3D;
            this.d = new tl3d.Vector3D;
            this.baseT = 500;
        }
        Ray.prototype.setPos = function (x, y, z) {
            this.o.x = x;
            this.o.y = y;
            this.o.z = z;
        };
        Ray.prototype.setTarget = function (x, y, z) {
            this.d.x = x - this.o.x;
            this.d.y = y - this.o.y;
            this.d.z = z - this.o.z;
            this.d.normalize();
        };
        return Ray;
    }());
    tl3d.Ray = Ray;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SceneQuadTree = /** @class */ (function () {
        function SceneQuadTree() {
            this.needUpdata = false;
            this.panleAry = new Array;
        }
        SceneQuadTree.prototype.init = function (obj, $dic) {
            this._circle = new tl3d.Circle(10000, 10000);
            this._sceneDic = $dic;
            this._rootNode = this.getNode(obj);
            this._ray = new tl3d.Ray;
        };
        SceneQuadTree.prototype.getNode = function (obj) {
            var quadNode = new tl3d.QuadTreeNode(obj.x, obj.y, obj.z, obj.width, obj.height, obj.depth);
            if (obj.data) {
                if (!quadNode.sun) {
                    quadNode.sun = new Array;
                }
                for (var i = 0; i < obj.data.length; i++) {
                    var dataNode = new tl3d.QuadTreeNode(obj.data[i].x, obj.data[i].y, obj.data[i].z, obj.data[i].width, obj.data[i].height, obj.data[i].depth);
                    var key;
                    if (obj.data[i].type == 1) {
                        key = "build" + obj.data[i].id;
                    }
                    else if (obj.data[i].type == 11) {
                        key = "particle" + obj.data[i].id;
                    }
                    else if (obj.data[i].type == 14) {
                        key = "ground" + obj.data[i].id;
                    }
                    dataNode.target = this._sceneDic[key];
                    dataNode.target.aabb = dataNode;
                    quadNode.sun.push(dataNode);
                }
            }
            if (obj.sun) {
                if (!quadNode.sun) {
                    quadNode.sun = new Array;
                }
                for (var i = 0; i < obj.sun.length; i++) {
                    quadNode.sun.push(this.getNode(obj.sun[i]));
                }
            }
            return quadNode;
        };
        SceneQuadTree.prototype.setCircle = function ($x, $z, $radius) {
            var xx = $x - this._circle.x;
            var yy = $z - this._circle.y;
            if (Math.sqrt(xx * xx + yy * yy) < 10) {
                this.needUpdata = false;
            }
            else {
                this._circle.setData($x, $z, $radius);
                this.needUpdata = true;
            }
        };
        SceneQuadTree.prototype.update = function () {
            tl3d.MathClass.GetViewHitBoxDataCopy(tl3d.Scene_data.cam3D.distance);
            var cam = new tl3d.Vector3D(tl3d.Scene_data.cam3D.x, tl3d.Scene_data.cam3D.y, tl3d.Scene_data.cam3D.z);
            var vc = tl3d.MathClass.viewBoxVecItem;
            this.panleAry.length = 0;
            this.panleAry.push(this.getPanelByVec(cam, vc[0], vc[1]));
            this.panleAry.push(this.getPanelByVec(cam, vc[1], vc[2]));
            this.panleAry.push(this.getPanelByVec(cam, vc[2], vc[3]));
            this.panleAry.push(this.getPanelByVec(cam, vc[3], vc[0]));
            //this.panleAry.push(this.getPanelByVec(vc[0], vc[1], vc[2]));
            //this._rootNode.testCircle(this._circle);
            //this._rootNode.testCam();
            this._ray.setPos(tl3d.Scene_data.cam3D.x, tl3d.Scene_data.cam3D.y, tl3d.Scene_data.cam3D.z);
            this._ray.setTarget(tl3d.Scene_data.focus3D.x, tl3d.Scene_data.focus3D.y, tl3d.Scene_data.focus3D.z);
            this._ray.baseT = tl3d.Scene_data.cam3D.distance;
            this._rootNode.testViewFrustum(this.panleAry, this._ray);
        };
        SceneQuadTree.prototype.getPanelByVec = function (v1, v2, v3) {
            var a1 = v2.subtract(v1);
            var a2 = v3.subtract(v1);
            a1 = a1.cross(a2);
            a1.normalize();
            a1.w = -a1.dot(v1);
            return a1;
        };
        SceneQuadTree.prototype.updateDraw = function () {
            if (this.capsuleLineSprite) {
                this.capsuleLineSprite.x = tl3d.Scene_data.focus3D.x;
                this.capsuleLineSprite.y = tl3d.Scene_data.focus3D.y + 50;
                this.capsuleLineSprite.z = tl3d.Scene_data.focus3D.z;
                this.capsuleLineSprite.update();
            }
            else {
                this.capsuleLineSprite = new tl3d.LineDisplaySprite();
                this.capsuleLineSprite.clear();
                this.capsuleLineSprite.baseColor = new tl3d.Vector3D(1, 0, 0, 1);
                this.drawCylinder(this._circle.radius, 10);
                this.capsuleLineSprite.upToGpu();
            }
        };
        SceneQuadTree.prototype.drawCylinder = function ($w, $h) {
            var w = $w;
            var h = $h;
            var jindu = 12;
            var lastA;
            var lastB;
            var i;
            for (i = 0; i < jindu; i++) {
                var a = new tl3d.Vector3D(w, 0, 0);
                var b = new tl3d.Vector3D(w, +h, 0);
                var m = new tl3d.Matrix3D;
                m.appendRotation(i * (360 / jindu), tl3d.Vector3D.Y_AXIS);
                var A = m.transformVector(a);
                var B = m.transformVector(b);
                this.capsuleLineSprite.makeLineMode(A, B);
                //this.capsuleLineSprite.makeLineMode(A, new Vector3D(0, 0, 0))
                this.capsuleLineSprite.makeLineMode(B, new tl3d.Vector3D(0, +h, 0));
                if (i == (jindu - 1)) {
                    this.capsuleLineSprite.makeLineMode(A, a);
                    this.capsuleLineSprite.makeLineMode(B, b);
                }
                if (lastA || lastB) {
                    this.capsuleLineSprite.makeLineMode(A, lastA);
                    this.capsuleLineSprite.makeLineMode(B, lastB);
                }
                lastA = A.clone();
                lastB = B.clone();
            }
        };
        return SceneQuadTree;
    }());
    tl3d.SceneQuadTree = SceneQuadTree;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Skill = /** @class */ (function (_super) {
        __extends(Skill, _super);
        function Skill(skillMgr) {
            var _this = _super.call(this) || this;
            _this.isDeath = true;
            _this.src = false;
            _this.time = 0;
            _this.targetFlag = 0;
            _this.targetShockFlag = 0;
            _this.needSound = false;
            _this.needShock = false;
            _this.hasDestory = false;
            _this.actionEnd = false;
            _this.skillMgr = skillMgr;
            return _this;
        }
        Skill.prototype.setData = function ($data, $skillData) {
            if (this.hasDestory) {
                return;
            }
            this.skillVo = new tl3d.SkillVo();
            this.skillVo.setData($data);
            this.setKeyAry();
            this.trajectoryAry = new Array;
            this._skillData = $skillData;
        };
        Skill.prototype.getBloodTime = function () {
            if (this.skillVo) {
                return this.skillVo.bloodTime;
            }
            else {
                return tl3d.SkillVo.defaultBloodTime;
            }
        };
        Skill.prototype.play = function () {
            var _this = this;
            if (!this.skillVo) {
                this.skillComplete();
                return;
            }
            if (this.active && this.active instanceof tl3d.Display3dMovie) {
                var $movie3d = this.active;
                $movie3d.play(this.skillVo.action, this.actionEnd ? 1 : 2, false, null, function () {
                    if (_this.actionCompleteFun) {
                        _this.actionCompleteFun();
                    }
                });
            }
        };
        Skill.prototype.setKeyAry = function () {
            var _this = this;
            this.keyAry = new Array;
            if (this.skillVo.types == tl3d.SkillType.FixEffect) {
                for (var i = 0; i < this.skillVo.keyAry.length; i++) {
                    var keySkill = new tl3d.SkillFixEffect(this);
                    keySkill.setInfo(this.skillVo.keyAry[i]);
                    keySkill.removeCallFun = function ($key) { _this.removeKey($key); };
                    keySkill.active = this.active;
                    this.keyAry.push(keySkill);
                }
            }
            else if (this.skillVo.types == tl3d.SkillType.TrajectoryDynamicTarget || this.skillVo.types == tl3d.SkillType.TrajectoryDynamicPoint) {
                for (var i = 0; i < this.skillVo.keyAry.length; i++) {
                    var trajectory;
                    var tkv = (this.skillVo.keyAry[i]);
                    if (tkv.multype == 1) {
                        trajectory = new tl3d.SkillMulTrajectory(this.skillMgr);
                    }
                    else {
                        trajectory = new tl3d.SkillTrajectory(this.skillMgr);
                    }
                    trajectory.setInfo(this.skillVo.keyAry[i]);
                    this.keyAry.push(trajectory);
                }
            }
        };
        Skill.prototype.removeKey = function ($key) {
            this.completeNum++;
            if (this.completeNum == this.keyAry.length) {
                //    console.log("播放结束1");
                //    showToast("播放结束");
                this.skillComplete();
            }
        };
        /**强制移除技能 */
        Skill.prototype.removeSkillForce = function () {
            // if(this.key == "skill/jichu_1_byte.txtm_skill_04"){
            //     SkillManager.getInstance().fengbaonum--;
            //     console.log("移除技能风暴 " + SkillManager.getInstance().fengbaonum);
            // }        
            if (this.keyAry) {
                for (var i = 0; i < this.keyAry.length; i++) {
                    this.keyAry[i].reset();
                }
            }
            this.skillComplete();
            this.reset();
        };
        Skill.prototype.skillComplete = function () {
            this.skillMgr.removeSkill(this);
            this.isDeath = true;
            if (this.completeFun) {
                this.completeFun();
            }
            this.idleTime = 0;
        };
        Skill.prototype.reset = function () {
            this.time = 0;
            this.completeNum = 0;
            this.active = null;
            this.completeFun = null;
            this.targetFlag = 0;
            this.targetShockFlag = 0;
            this.soundPlay = false;
            this.needSound = true;
            this.needShock = true;
        };
        Skill.prototype.update = function (t) {
            this.time += t;
            if (this.time > Skill.MaxTime) {
                // console.log("超时结束");
                // showToast("超时结束");
                this.skillComplete();
                return;
            }
            this.getKeyTarget();
            this.getShockTarget();
            this.updateTrajector(t);
        };
        Skill.prototype.updateTrajector = function (t) {
            for (var i = 0; i < this.trajectoryAry.length; i++) {
                this.trajectoryAry[i].update(t);
            }
        };
        Skill.prototype.getKeyTarget = function () {
            if (!this.keyAry) {
                return;
            }
            for (var i = this.targetFlag; i < this.keyAry.length;) {
                if (this.keyAry[i].time < this.time) {
                    this.keyAry[i].addToRender();
                    if (this.skillVo.types == tl3d.SkillType.TrajectoryDynamicTarget || this.skillVo.types == tl3d.SkillType.TrajectoryDynamicPoint) {
                        var ss = this.keyAry[i];
                        this.trajectoryAry.push(ss);
                    }
                    i++;
                    this.targetFlag = i;
                }
                else {
                    break;
                }
            }
            this.getSound();
        };
        Skill.prototype.getShockTarget = function () {
            if (!this.skillVo.shockAry || !this.needShock) {
                return;
            }
            for (var i = this.targetShockFlag; i < this.skillVo.shockAry.length; i++) {
                if (this.skillVo.shockAry[i].time < this.time) {
                    //震动
                    this.skillMgr.shock.shock(this.skillVo.shockAry[i].lasttime, this.skillVo.shockAry[i].amp);
                    this.targetShockFlag = i + 1;
                }
                else {
                    break;
                }
            }
            //this.getSound();
        };
        Skill.prototype.getSound = function () {
            if (!this.skillVo.sound || this.soundPlay || !this.needSound) {
                return;
            }
            if (this.skillVo.sound.frame < this.time) {
                tl3d.AudioMgr.playSound(tl3d.Scene_data.soundPath + this.skillVo.sound.url);
                this.soundPlay = true;
            }
        };
        Skill.prototype.configFixEffect = function ($active, $actionCompleteFun, $completeFun, $posObj) {
            if ($actionCompleteFun === void 0) { $actionCompleteFun = null; }
            if ($completeFun === void 0) { $completeFun = null; }
            if ($posObj === void 0) { $posObj = null; }
            this.active = $active;
            this.completeFun = $completeFun;
            this.actionCompleteFun = $actionCompleteFun;
            if (!this.keyAry) {
                return;
            }
            for (var i = 0; i < this.keyAry.length; i++) {
                if (this.skillVo.types != tl3d.SkillType.FixEffect) {
                    continue;
                }
                var skillFixEffect = this.keyAry[i];
                skillFixEffect.active = $active;
                if ($posObj && $posObj.length) {
                    if (i > ($posObj.length - 1)) {
                        skillFixEffect.outPos = $posObj[$posObj.length - 1];
                    }
                    else {
                        skillFixEffect.outPos = $posObj[i];
                    }
                }
                else {
                    skillFixEffect.outPos = null;
                }
            }
        };
        Skill.prototype.configTrajectory = function ($active, $target, $completeFun, types, $bloodFun) {
            var _this = this;
            if ($completeFun === void 0) { $completeFun = null; }
            if (types === void 0) { types = 0; }
            if ($bloodFun === void 0) { $bloodFun = null; }
            this.active = $active;
            this.completeFun = $completeFun;
            this.completeNum = 0;
            if (!this.keyAry) {
                return;
            }
            for (var i = 0; i < this.keyAry.length; i++) {
                if (!(this.skillVo.types == tl3d.SkillType.TrajectoryDynamicTarget || this.skillVo.types == tl3d.SkillType.TrajectoryDynamicPoint)) {
                    continue;
                }
                var skillTrajector = this.keyAry[i];
                skillTrajector.setPlayData($active, $target, function ($skilltra) { _this.removeTrajectory($skilltra); }, types, (i == 0 ? $bloodFun : null));
            }
        };
        Skill.prototype.configMulTrajectory = function ($activeList, $active, $target, $completeFun) {
            var _this = this;
            if ($completeFun === void 0) { $completeFun = null; }
            this.active = $active;
            this.completeFun = $completeFun;
            this.completeNum = 0;
            if (!this.keyAry) {
                return;
            }
            for (var i = 0; i < this.keyAry.length; i++) {
                if (this.skillVo.types != tl3d.SkillType.TrajectoryDynamicTarget) {
                    continue;
                }
                var skillTrajector = this.keyAry[i];
                skillTrajector.setMulPlayData($activeList, $target, function ($skilltra) { _this.removeTrajectory($skilltra); }, 2);
            }
        };
        Skill.prototype.removeTrajectory = function ($skilltra) {
            var index = this.trajectoryAry.indexOf($skilltra);
            if (index != -1) {
                this.trajectoryAry.splice(index, 1);
            }
            this.completeNum++;
            if (this.completeNum == this.keyAry.length) {
                // console.log("播放结束2");
                // showToast("播放结束");
                this.skillComplete();
            }
        };
        Skill.prototype.destory = function () {
            this.skillVo = null;
            this.name = null;
            if (this.keyAry) {
                for (var i = 0; i < this.keyAry.length; i++) {
                    this.keyAry[i].destory();
                }
                this.keyAry.length = 0;
                this.keyAry = null;
            }
            this.active = null;
            this.completeFun = null;
            if (this.trajectoryAry) {
                for (var i = 0; i < this.trajectoryAry.length; i++) {
                    this.trajectoryAry[i].destory();
                }
                this.trajectoryAry.length = 0;
                this.trajectoryAry = null;
            }
            if (this._skillData) {
                this._skillData.useNum--;
            }
            this._skillData = null;
            this.hasDestory = true;
        };
        Skill.MaxTime = 1000 * 5;
        return Skill;
    }(tl3d.ResCount));
    tl3d.Skill = Skill;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkillData = /** @class */ (function (_super) {
        __extends(SkillData, _super);
        function SkillData(skillMgr) {
            var _this = _super.call(this) || this;
            //一个角色的一组技能
            _this.srcList = new Array();
            _this.skillMgr = skillMgr;
            return _this;
        }
        SkillData.prototype.addSrcSkill = function ($skill) {
            this.srcList.push($skill);
        };
        SkillData.prototype.destory = function () {
            for (var i = 0; i < this.srcList.length; i++) {
                var skill = this.srcList[i];
                skill.destory();
                this.skillMgr.gcSkill(skill);
            }
        };
        //列表中的对象全部播放完并且都没有使用才可以释放
        SkillData.prototype.testDestory = function () {
            for (var i = 0; i < this.srcList.length; i++) {
                var skill = this.srcList[i];
                if (!(skill.isDeath && skill.idleTime >= tl3d.ResCount.GCTime)) {
                    return false;
                }
            }
            return true;
        };
        return SkillData;
    }(tl3d.ResCount));
    tl3d.SkillData = SkillData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkillManager = /** @class */ (function (_super) {
        __extends(SkillManager, _super);
        function SkillManager(scene) {
            var _this = _super.call(this) || this;
            _this._time = 0;
            _this.scene = scene;
            _this._skillDic = new Object;
            _this._loadDic = new Object;
            _this._skillAry = new Array;
            _this._preLoadDic = new Object;
            return _this;
        }
        SkillManager.prototype.update = function () {
            var _tempTime = tl3d.TimeUtil.getTimer(this.scene ? this.scene.startTime : tl3d.TimeUtil.START_TIME);
            var t = _tempTime - this._time;
            for (var i = 0; i < this._skillAry.length; i++) {
                this._skillAry[i].update(t);
            }
            this._time = _tempTime;
        };
        SkillManager.prototype.preLoadSkill = function ($url, callBack) {
            var _this = this;
            if (callBack === void 0) { callBack = null; }
            this._callBack = callBack;
            if (this._dic[$url] || this._preLoadDic[$url]) {
                if (this._callBack) {
                    this._callBack.call(null);
                    this._callBack = null;
                }
                return;
            }
            this.loadSkillRes(tl3d.Scene_data.fileRoot + $url, function ($skillRes) {
                var skillData = new tl3d.SkillData(_this);
                skillData.data = $skillRes.data;
                skillData.useNum++;
                _this._dic[$url] = skillData;
                _this.addSrc($url, skillData);
                if (_this._callBack) {
                    _this._callBack.call(null);
                    _this._callBack = null;
                }
            });
            this._preLoadDic[$url] = true;
        };
        //加载技能
        SkillManager.prototype.loadSkillRes = function (url, $fun) {
            var skillRes = new tl3d.SkillRes();
            skillRes.load(url, function () {
                $fun(skillRes);
            });
        };
        SkillManager.prototype.getSkill = function ($url, $name, $callback) {
            var _this = this;
            if ($callback === void 0) { $callback = null; }
            var skill;
            var key = $url + $name;
            var ary = this._skillDic[key];
            if (ary) {
                for (var i = 0; i < ary.length; i++) {
                    skill = ary[i];
                    if (skill.isDeath && skill.useNum == 0) {
                        skill.reset();
                        skill.isDeath = false;
                        return skill;
                    }
                }
            }
            skill = new tl3d.Skill(this);
            skill.name = $name;
            skill.isDeath = false;
            if (!this._skillDic[key]) {
                this._skillDic[key] = new Array;
            }
            this._skillDic[key].push(skill);
            if (this._dic[$url]) {
                skill.setData(this._dic[$url].data[skill.name], this._dic[$url]);
                skill.key = key;
                this._dic[$url].useNum++;
                return skill;
            }
            if (this._loadDic[$url]) {
                var obj = new Object;
                obj.name = $name;
                obj.skill = skill;
                obj.callback = $callback;
                this._loadDic[$url].push(obj);
                return skill;
            }
            this._loadDic[$url] = new Array;
            var obj = new Object;
            obj.name = $name;
            obj.skill = skill;
            obj.callback = $callback;
            this._loadDic[$url].push(obj);
            this.loadSkillRes(tl3d.Scene_data.fileRoot + $url, function ($skillRes) {
                _this.loadSkillCom($url, $skillRes);
            });
            return skill;
        };
        SkillManager.prototype.loadSkillCom = function ($url, $skillRes) {
            var skillData = new tl3d.SkillData(this);
            skillData.data = $skillRes.data;
            for (var i = 0; i < this._loadDic[$url].length; i++) {
                var obj = this._loadDic[$url][i];
                if (!obj.skill.hasDestory) {
                    obj.skill.setData(skillData.data[obj.name], skillData);
                    obj.skill.key = $url + obj.name;
                    skillData.useNum++;
                }
            }
            this._dic[$url] = skillData;
            this.addSrc($url, skillData);
            for (var i = 0; i < this._loadDic[$url].length; i++) {
                var obj = this._loadDic[$url][i];
                if (obj.callback) {
                    obj.callback();
                }
            }
            this._loadDic[$url].length = 0;
            this._loadDic[$url] = null;
        };
        SkillManager.prototype.addSrc = function ($url, skillData) {
            for (var key in skillData.data) {
                var skill = new tl3d.Skill(this);
                skill.name = key;
                skill.isDeath = true;
                skill.src = true;
                skill.setData(skillData.data[key], skillData);
                skillData.addSrcSkill(skill);
                //skillData.useNum++;
                var dkey = $url + key;
                if (!this._skillDic[dkey]) {
                    this._skillDic[dkey] = new Array;
                }
                this._skillDic[dkey].push(skill);
            }
        };
        SkillManager.prototype.playSkill = function ($skill) {
            this._skillAry.push($skill);
            $skill.play();
        };
        SkillManager.prototype.removeSkill = function ($skill) {
            var index = this._skillAry.indexOf($skill);
            if (index != -1) {
                this._skillAry.splice(index, 1);
            }
        };
        SkillManager.prototype.removeAllSkill = function () {
            this._skillAry = [];
        };
        SkillManager.prototype.gcSkill = function (skill) {
            for (var key in this._skillDic) {
                var ary = this._skillDic[key];
                var idx = ary.indexOf(skill);
                if (idx != -1) {
                    ary.splice(idx, 1);
                }
            }
        };
        SkillManager.prototype.gc = function () {
            var keys = [];
            for (var key in this._dic) {
                var rc = this._dic[key];
                keys.push(key);
                if (rc.useNum <= 0) {
                    rc.idleTime++;
                    if (rc.idleTime >= tl3d.ResCount.GCTime && rc.testDestory()) {
                        // console.log("清理skilldata -" + key);
                        rc.destory();
                        delete this._dic[key];
                    }
                }
            }
            // console.log("keys:", keys);
            for (var key in this._skillDic) {
                var ary = this._skillDic[key];
                for (var i = ary.length - 1; i >= 0; i--) {
                    if (ary[i].isDeath && ary[i].useNum <= 0) {
                        ary[i].idleTime++;
                        if (ary[i].idleTime >= tl3d.ResCount.GCTime) {
                            if (!ary[i].src) {
                                ary[i].destory();
                                ary.splice(i, 1);
                            }
                        }
                    }
                }
                if (ary.length == 0) {
                    // console.log("清理skill" + key);
                    delete this._skillDic[key];
                }
            }
        };
        Object.defineProperty(SkillManager.prototype, "shock", {
            get: function () {
                if (!this._shock) {
                    this._shock = new ShockUtil();
                }
                return this._shock;
            },
            enumerable: true,
            configurable: true
        });
        return SkillManager;
    }(tl3d.ResGC));
    tl3d.SkillManager = SkillManager;
    var ShockUtil = /** @class */ (function () {
        function ShockUtil() {
            var _this = this;
            this.upFun = function ($d) {
                _this.update($d);
            };
        }
        ShockUtil.prototype.update = function ($dtime) {
            this.ctime += $dtime;
            if (this.ctime > this.time) {
                tl3d.TimeUtil.removeFrameTick(this.upFun);
                tl3d.Scene_data.cam3D.offset.setTo(0, 0, 0);
                return;
            }
            var ranX = (Math.random() - 0.5) * this.amp;
            var ranY = (Math.random() - 0.5) * this.amp;
            var ranZ = (Math.random() - 0.5) * this.amp;
            tl3d.Scene_data.cam3D.offset.setTo(ranX, ranY, ranZ);
        };
        ShockUtil.prototype.shock = function (time, amp) {
            this.time = time;
            this.ctime = 0;
            this.amp = amp;
            tl3d.TimeUtil.addFrameTick(this.upFun);
        };
        ShockUtil.prototype.clearShock = function () {
            tl3d.TimeUtil.removeFrameTick(this.upFun);
        };
        return ShockUtil;
    }());
    tl3d.ShockUtil = ShockUtil;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkillKey = /** @class */ (function () {
        function SkillKey(skillMgr) {
            this.time = 0;
            this.skillMgr = skillMgr;
        }
        SkillKey.prototype.addToRender = function () {
            if (!this.particle) {
                return;
            }
            this.particle.reset();
            this.particle.sceneVisible = true;
            this.skillMgr.scene.addParticle(this.particle);
        };
        SkillKey.prototype.setInfo = function (obj) {
            this.time = obj.frame * tl3d.Scene_data.frameTime;
            this.particle = tl3d.ParticleManager.getInstance().getParticleByte(tl3d.Scene_data.fileRoot + obj.url);
        };
        SkillKey.prototype.onPlayCom = function () {
        };
        SkillKey.prototype.reset = function () {
            //this.time = 0;
            this.skillMgr.scene.removeParticle(this.particle);
        };
        SkillKey.prototype.destory = function () {
            if (this.particle) {
                this.particle.destory();
                this.particle = null;
            }
            this.removeCallFun = null;
        };
        return SkillKey;
    }());
    tl3d.SkillKey = SkillKey;
})(tl3d || (tl3d = {}));
/// <reference path="SkillKey.ts" />

(function (tl3d) {
    var SkillEffect = /** @class */ (function (_super) {
        __extends(SkillEffect, _super);
        // public active: Object3D;
        function SkillEffect(skillMgr) {
            return _super.call(this, skillMgr) || this;
        }
        Object.defineProperty(SkillEffect.prototype, "active", {
            get: function () {
                return this._active;
            },
            set: function ($val) {
                this._active = $val;
            },
            enumerable: true,
            configurable: true
        });
        SkillEffect.prototype.addToRender = function () {
            var _this = this;
            _super.prototype.addToRender.call(this);
            // this.particle.addEventListener(BaseEvent.COMPLETE, this.onPlayCom, this);
            if (!this.particle)
                return;
            this.particle.onComplete = function (particle) {
                _this.onPlayCom();
            };
        };
        SkillEffect.prototype.onPlayCom = function (event) {
            if (event === void 0) { event = null; }
            // this.particle.removeEventListener(BaseEvent.COMPLETE, this.onPlayCom, this);
            this.skillMgr.scene.removeParticle(this.particle);
            this.removeCallFun(this);
        };
        return SkillEffect;
    }(tl3d.SkillKey));
    tl3d.SkillEffect = SkillEffect;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkillBugBind = /** @class */ (function () {
        function SkillBugBind() {
        }
        SkillBugBind.prototype.getSocket = function (socketName, resultMatrix) {
            this.bindMatrix.clone(resultMatrix);
        };
        SkillBugBind.prototype.getSunType = function () {
            return 1;
        };
        return SkillBugBind;
    }());
    tl3d.SkillBugBind = SkillBugBind;
    var SkillFixEffect = /** @class */ (function (_super) {
        __extends(SkillFixEffect, _super);
        function SkillFixEffect(skill) {
            var _this = _super.call(this, skill.skillMgr) || this;
            _this.skill = skill;
            return _this;
        }
        SkillFixEffect.prototype.setInfo = function (obj) {
            _super.prototype.setInfo.call(this, obj);
            var data = obj;
            this.pos = data.pos;
            this.rotation = data.rotation;
            this.hasSocket = data.hasSocket;
            this.socket = data.socket;
        };
        SkillFixEffect.prototype.onPlayCom = function (event) {
            if (event === void 0) { event = null; }
            // this.particle.removeEventListener(BaseEvent.COMPLETE, this.onPlayCom, this);
            this.skill.skillMgr.scene.removeParticle(this.particle);
            this.removeCallFun(this);
        };
        SkillFixEffect.prototype.addToRender = function () {
            var _this = this;
            if (!this.particle) {
                return;
            }
            this.particle.reset();
            this.particle.sceneVisible = true;
            this.particle.onComplete = function (particle) {
                _this.onPlayCom();
            };
            this.skill.skillMgr.scene.addParticle(this.particle);
            // this.particle.addEventListener(BaseEvent.COMPLETE, this.onPlayCom, this);
            if (this.hasSocket) {
                var targetActive = this.active;
                this.particle.bindTarget = (targetActive);
                this.particle.bindSocket = this.socket;
            }
            else {
                var ma = new tl3d.Matrix3D;
                ma.appendRotation(this.active.rotationY, tl3d.Vector3D.Y_AXIS);
                var v3d = ma.transformVector(this.pos);
                v3d.x += this.outPos == null ? this.active.x : this.outPos.x;
                v3d.y += this.outPos == null ? this.active.y : this.outPos.y;
                v3d.z += this.outPos == null ? this.active.z : this.outPos.z;
                var $SkillBugBind = new tl3d.SkillBugBind();
                $SkillBugBind.bindMatrix = new tl3d.Matrix3D;
                $SkillBugBind.bindMatrix.appendRotation(this.rotation.x, tl3d.Vector3D.X_AXIS);
                $SkillBugBind.bindMatrix.appendRotation(this.rotation.y, tl3d.Vector3D.Y_AXIS);
                $SkillBugBind.bindMatrix.appendRotation(this.rotation.z, tl3d.Vector3D.Z_AXIS);
                $SkillBugBind.bindMatrix.appendRotation(this.active.rotationY, tl3d.Vector3D.Y_AXIS);
                $SkillBugBind.bindMatrix.appendTranslation(v3d.x, v3d.y, v3d.z);
                this.particle.bindTarget = $SkillBugBind;
            }
        };
        return SkillFixEffect;
    }(tl3d.SkillEffect));
    tl3d.SkillFixEffect = SkillFixEffect;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkillTrajectory = /** @class */ (function (_super) {
        __extends(SkillTrajectory, _super);
        function SkillTrajectory(skillMgr) {
            var _this = _super.call(this, skillMgr) || this;
            _this._currentPos = new tl3d.Vector3D;
            _this.rotationMatrix = new tl3d.Matrix3D;
            _this._socketMaxrix = new tl3d.Matrix3D;
            _this._currentTargetPos = new tl3d.Vector3D;
            return _this;
            //this.path = new SkillSinPath();
            //this.path.setData(this, () => { this.applyArrive() } ,this._currentPos, this.rotationMatrix, this._currentTargetPos);
        }
        SkillTrajectory.prototype.update = function (t) {
            this.path.update(t);
        };
        SkillTrajectory.prototype.reset = function () {
            _super.prototype.reset.call(this);
            //if(false){ 
            if (this.endParticle) {
                this.skillMgr.scene.addParticle(this.endParticle);
                this.endParticle.reset();
                this.endParticle.setPos(this._currentTargetPos.x, this._currentTargetPos.y, this._currentTargetPos.z);
            }
            if (this.removeCallFun) {
                this.removeCallFun(this);
            }
        };
        SkillTrajectory.prototype.endPlayFun = function (e) {
            if (e === void 0) { e = null; }
            this.skillMgr.scene.removeParticle(this.endParticle);
            this.endParticle.removeEventListener(tl3d.BaseEvent.COMPLETE, this.endPlayFun, this);
        };
        SkillTrajectory.prototype.setCurrentPos = function () {
            if (this.data.hitSocket) {
                var targetMovie = (this.target);
                if (targetMovie) {
                    targetMovie.getSocket(this.data.hitSocket, this._socketMaxrix);
                    this._currentTargetPos.setTo(this._socketMaxrix.position.x, this._socketMaxrix.position.y, this._socketMaxrix.position.z);
                }
                else {
                    //console.log("需要处理,特殊没有指定对象")
                }
                return true;
            }
            else {
                if (this._currentTargetPos.x == this.target.x && this._currentTargetPos.y == this.target.y && this._currentTargetPos.z == this.target.z) {
                    return false;
                }
                else {
                    this._currentTargetPos.setTo(this.target.x, this.target.y, this.target.z);
                    return true;
                }
            }
        };
        SkillTrajectory.prototype.addToRender = function () {
            _super.prototype.addToRender.call(this);
            var beginPos;
            if (this.data.beginType == 0) {
                var ma = new tl3d.Matrix3D;
                ma.appendRotation(this.active.rotationY, tl3d.Vector3D.Y_AXIS);
                beginPos = ma.transformVector(this.data.beginPos);
                this._currentPos.setTo(this.active.x + beginPos.x, this.active.y + beginPos.y, this.active.z + beginPos.z);
            }
            else if (this.data.beginType == 1) {
                var tempMa = new tl3d.Matrix3D;
                var bindActive = (this.active);
                bindActive.getSocket(this.data.beginSocket, tempMa);
                beginPos = tempMa.position;
                this._currentPos.setTo(beginPos.x, beginPos.y, beginPos.z);
            }
            this.particle.setPos(this._currentPos.x, this._currentPos.y, this._currentPos.z);
            this.path.add();
        };
        SkillTrajectory.prototype.getSocket = function (socketName, resultMatrix) {
            resultMatrix.identity();
            resultMatrix.append(this.rotationMatrix);
            resultMatrix.appendTranslation(this._currentPos.x, this._currentPos.y, this._currentPos.z);
        };
        SkillTrajectory.prototype.getSunType = function () {
            return 0;
        };
        SkillTrajectory.prototype.setInfo = function (obj) {
            _super.prototype.setInfo.call(this, obj);
            this.particle.bindTarget = this;
            this.data = obj;
            //this.path.speed = this.data.speed;
            if (this.data.endParticleUrl) {
                this.endParticle = tl3d.ParticleManager.getInstance().getParticleByte(tl3d.Scene_data.fileRoot + this.data.endParticleUrl);
                this.endParticle.addEventListener(tl3d.BaseEvent.COMPLETE, this.endPlayFun, this);
            }
        };
        SkillTrajectory.prototype.setPlayData = function ($active, $target, $removeCallFun, types, $bloodFun) {
            var _this = this;
            if (types === void 0) { types = 0; }
            if ($bloodFun === void 0) { $bloodFun = null; }
            this.active = $active;
            this.target = $target;
            this.removeCallFun = $removeCallFun;
            this._currentPos.setTo(0, 0, 0);
            this.rotationMatrix.identity();
            this._socketMaxrix.identity();
            this._currentTargetPos.setTo(0, 0, 0);
            if (!this.path) {
                this.path = tl3d.PathManager.getNewPath(2);
                this.path.setData(this, function () { _this.reset(); }, this._currentPos, this.rotationMatrix, this._currentTargetPos, $bloodFun);
                this.path.speed = this.data.speed;
            }
            this.path.reset();
        };
        SkillTrajectory.prototype.destory = function () {
            _super.prototype.destory.call(this);
            this.active = null;
            this.target = null;
            this.data = null;
            this._currentPos = null;
            this.rotationMatrix = null;
            this._socketMaxrix = null;
            this._currentTargetPos = null;
            this.path = null;
        };
        return SkillTrajectory;
    }(tl3d.SkillKey));
    tl3d.SkillTrajectory = SkillTrajectory;
})(tl3d || (tl3d = {}));
/// <reference path="SkillTrajectory.ts" />

(function (tl3d) {
    var SkillMulTrajectory = /** @class */ (function (_super) {
        __extends(SkillMulTrajectory, _super);
        function SkillMulTrajectory() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SkillMulTrajectory.prototype.update = function (t) {
            this.pathMul.update(t);
        };
        SkillMulTrajectory.prototype.getSunType = function () {
            return 1;
        };
        SkillMulTrajectory.prototype.addToRender = function () {
            if (!this.particle) {
                return;
            }
            this.particle.reset();
            this.skillMgr.scene.addParticle(this.particle);
            if (!this.currentPosList) {
                this.currentPosList = new Array;
                for (var i = 0; i < this.activeList.length; i++) {
                    this.currentPosList.push(new tl3d.Vector3D(this.activeList[i].x, this.activeList[i].y + 10, this.activeList[i].z + 5));
                }
                this.pathMul.setInitCurrentPos(this.currentPosList);
            }
            else {
                for (var i = 0; i < this.activeList.length; i++) {
                    this.currentPosList[i].setTo(this.activeList[i].x, this.activeList[i].y + 10, this.activeList[i].z + 5);
                    this.currentPosList[i].w = 0;
                }
            }
            //this.particle.setMulPos(this.currentPosList);
            this.pathMul.add();
            this.particle.setMulPos(this.pathMul.resultAry);
        };
        SkillMulTrajectory.prototype.setMulPlayData = function ($activeList, $target, $removeCallFun, types) {
            var _this = this;
            if (types === void 0) { types = 0; }
            this.activeList = $activeList;
            this.active = this.activeList[0];
            this.target = $target;
            this.removeCallFun = $removeCallFun;
            this._currentPos.setTo(0, 0, 0);
            this.rotationMatrix.identity();
            this._socketMaxrix.identity();
            this._currentTargetPos.setTo(0, 0, 0);
            if (!this.pathMul) {
                this.pathMul = tl3d.PathManager.getNewPath(types);
                this.pathMul.setData(this, function () { _this.reset(); }, this._currentPos, this.rotationMatrix, this._currentTargetPos);
                this.pathMul.speed = this.data.speed;
            }
            this.pathMul.reset();
        };
        SkillMulTrajectory.prototype.getMulSocket = function (ary) {
            if (ary) {
                this.pathMul.applyData(ary);
            }
        };
        return SkillMulTrajectory;
    }(tl3d.SkillTrajectory));
    tl3d.SkillMulTrajectory = SkillMulTrajectory;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var PathManager = /** @class */ (function () {
        function PathManager() {
        }
        PathManager.reg = function (types, cls) {
            this.dic[types] = cls;
        };
        PathManager.getNewPath = function (types) {
            var cls = this.dic[types];
            return new cls();
        };
        PathManager.init = function () {
            this.dic[0] = tl3d.SkillPath;
            this.dic[1] = tl3d.SkillSinPath;
            this.dic[2] = tl3d.SkillCosPath;
        };
        PathManager.dic = new Object;
        return PathManager;
    }());
    tl3d.PathManager = PathManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkillPath = /** @class */ (function () {
        function SkillPath() {
            /**
            * 当前方向
            */
            this._currentDirect = new tl3d.Vector3D;
        }
        SkillPath.prototype.update = function (t) {
            this.time = t;
            if (this.hasReached) {
                this.endTime += t;
                if (this.endTime > 200) {
                    this.applyArrive();
                }
                return;
            }
            if (this.skillTrajectory.setCurrentPos()) {
                this._currentDirect.x = this.currentTargetPos.x - this.currentPos.x;
                this._currentDirect.y = this.currentTargetPos.y - this.currentPos.y;
                this._currentDirect.z = this.currentTargetPos.z - this.currentPos.z;
                this._currentDirect.normalize();
                this._currentDirect.scaleBy(this.speed);
                this.setRotationMatrix(this.currentTargetPos.subtract(this.currentPos));
                if (this._currentDirect.length == 0) {
                    this.arrive();
                    return;
                }
            }
            var currentDistance = this._currentDirect.length * this.time;
            if (!this.hasReached) {
                var targetDistance = tl3d.Vector3D.distance(this.currentPos, this.currentTargetPos);
                this.currentPos.x += this._currentDirect.x * this.time;
                this.currentPos.y += this._currentDirect.y * this.time;
                this.currentPos.z += this._currentDirect.z * this.time;
            }
            if (currentDistance > targetDistance) {
                this.arrive();
            }
            //this.distance += currentDistance;
        };
        SkillPath.prototype.setRotationMatrix = function ($newPos) {
            $newPos.normalize();
            var base = new tl3d.Vector3D(0, 0, 1);
            var axis = base.cross($newPos);
            axis.normalize();
            var angle = Math.acos($newPos.dot(base));
            var qu = new tl3d.Quaternion();
            qu.fromAxisAngle(axis, angle);
            qu.toMatrix3D(this.rotationMatrix);
        };
        SkillPath.prototype.arrive = function () {
            this.hasReached = true;
        };
        SkillPath.prototype.applyArrive = function () {
            this.endFun();
            if (this.bloodFun) {
                this.bloodFun();
            }
        };
        SkillPath.prototype.reset = function () {
            this.hasReached = false;
            this._currentDirect.setTo(0, 0, 0);
            this.endTime = 0;
        };
        SkillPath.prototype.add = function () {
        };
        SkillPath.prototype.setData = function ($skillTrajectory, $endFun, $currentPos, $rotationMatrix, $currentTargetPos, $bloodFun) {
            this.skillTrajectory = $skillTrajectory;
            this.currentPos = $currentPos;
            this.rotationMatrix = $rotationMatrix;
            this.currentTargetPos = $currentTargetPos;
            this.endFun = $endFun;
            this.bloodFun = $bloodFun;
        };
        return SkillPath;
    }());
    tl3d.SkillPath = SkillPath;
})(tl3d || (tl3d = {}));
/// <reference path="SkillPath.ts" />

(function (tl3d) {
    var SkillMulPath = /** @class */ (function (_super) {
        __extends(SkillMulPath, _super);
        function SkillMulPath() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.lastTime = 0;
            return _this;
        }
        SkillMulPath.prototype.setInitCurrentPos = function (ary) {
            this.currentPosAry = ary;
            this.allTimeList = new Array;
            for (var i = 0; i < ary.length; i++) {
                this.allTimeList.push(0);
            }
        };
        SkillMulPath.prototype.add = function () {
            this.skillTrajectory.setCurrentPos();
            this.directAry = new Array;
            var maxLenght = 0;
            for (var i = 0; i < this.currentPosAry.length; i++) {
                var v3d = new tl3d.Vector3D();
                v3d.x = this.currentTargetPos.x - this.currentPosAry[i].x;
                v3d.y = this.currentTargetPos.y - this.currentPosAry[i].y;
                v3d.z = this.currentTargetPos.z - this.currentPosAry[i].z;
                var le = v3d.length;
                if (le > maxLenght) {
                    maxLenght = le;
                    this.maxV3d = this.currentPosAry[i];
                }
                this.allTimeList[i] = le / this.speed;
                v3d.normalize();
                v3d.scaleBy(this.speed);
                this.directAry.push(v3d);
            }
            this.alltime = maxLenght / this.speed;
            this.setAllData();
        };
        SkillMulPath.prototype.setAllData = function () {
            var frame = tl3d.Util.float2int(this.alltime / 33) + 8;
            this.resultAry = new Array;
            for (var i = 0; i < this.currentPosAry.length; i++) {
                var itemAry = new Array;
                this.resultAry.push(itemAry);
                var directV3d = this.directAry[i];
                for (var k = 0; k < 6; k++) {
                    itemAry.push([this.currentPosAry[i].x, this.currentPosAry[i].y, this.currentPosAry[i].z]);
                }
                for (var j = 0; j < frame; j++) {
                    this.lastTime = 33 * j;
                    var per = (this.lastTime / this.allTimeList[i]);
                    var ypos = per;
                    var pos;
                    if (per >= 1) {
                        ypos = 0;
                        pos = [this.currentTargetPos.x, this.currentTargetPos.y, this.currentTargetPos.z];
                    }
                    else {
                        ypos = ypos - ypos * ypos;
                        ypos *= 250;
                        pos = [directV3d.x * this.lastTime + this.currentPosAry[i].x, directV3d.y * this.lastTime + ypos + this.currentPosAry[i].y, directV3d.z * this.lastTime + this.currentPosAry[i].z];
                    }
                    var normal;
                    if (j == 0) {
                        normal = [0, 1, 0];
                    }
                    else {
                        var lastpos = itemAry[j * 2 - 2];
                        normal = [pos[0] - lastpos[0], pos[1] - lastpos[1], pos[2] - lastpos[2]];
                        var len = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);
                        normal[0] /= len;
                        normal[1] /= len;
                        normal[2] /= len;
                    }
                    itemAry.push(pos, normal);
                }
            }
        };
        SkillMulPath.prototype.update = function (t) {
            this.time = t;
            this.lastTime += t;
            if (this.hasReached) {
                this.endTime += t;
                if (this.endTime > 200) {
                    this.applyArrive();
                }
                return;
            }
            this.skillTrajectory.setCurrentPos();
            for (var i = 0; i < this.currentPosAry.length; i++) {
                var ypos = (this.lastTime / this.allTimeList[i]);
                ypos = ypos - ypos * ypos;
                ypos *= 250;
                var basePos = this.currentPosAry[i];
                this._currentDirect.x = this.currentTargetPos.x - basePos.x;
                this._currentDirect.y = this.currentTargetPos.y - basePos.y;
                this._currentDirect.z = this.currentTargetPos.z - basePos.z;
                this._currentDirect.normalize();
                this._currentDirect.scaleBy(this.speed);
                if (this.maxV3d == basePos) {
                    this.setRotationMatrix(this.currentTargetPos.subtract(basePos));
                    if (this._currentDirect.length == 0) {
                        this.arrive();
                        return;
                    }
                }
                var currentDistance = this._currentDirect.length * this.time;
                if (!this.hasReached) {
                    var targetDistance = tl3d.Vector3D.distance(basePos, this.currentTargetPos);
                    basePos.x += this._currentDirect.x * this.time;
                    basePos.y += this._currentDirect.y * this.time;
                    basePos.z += this._currentDirect.z * this.time;
                    basePos.w = ypos;
                }
                if (this.maxV3d == basePos) {
                    if (currentDistance > targetDistance) {
                        this.arrive();
                    }
                }
            }
            this.currentPos.setTo(this.currentPosAry[0].x, this.currentPosAry[0].y + this.currentPosAry[0].w, this.currentPosAry[0].z);
        };
        SkillMulPath.prototype.setData = function ($skillTrajectory, $endFun, $currentPos, $rotationMatrix, $currentTargetPos) {
            _super.prototype.setData.call(this, $skillTrajectory, $endFun, $currentPos, $rotationMatrix, $currentTargetPos, null);
            this.skillMul = $skillTrajectory;
        };
        SkillMulPath.prototype.applyData = function (ary) {
            for (var i = 0; i < ary.length; i++) {
                ary[i].setTo(this.currentPosAry[i].x, this.currentPosAry[i].y + this.currentPosAry[i].w, this.currentPosAry[i].z);
            }
        };
        SkillMulPath.prototype.reset = function () {
            _super.prototype.reset.call(this);
            this.lastTime = 0;
        };
        return SkillMulPath;
    }(tl3d.SkillPath));
    tl3d.SkillMulPath = SkillMulPath;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkillSinPath = /** @class */ (function (_super) {
        __extends(SkillSinPath, _super);
        function SkillSinPath() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.basePos = new tl3d.Vector3D;
            return _this;
        }
        SkillSinPath.prototype.add = function () {
            this.skillTrajectory.setCurrentPos();
            var v3d = new tl3d.Vector3D();
            v3d.x = this.currentTargetPos.x - this.currentPos.x;
            v3d.y = this.currentTargetPos.y - this.currentPos.y;
            v3d.z = this.currentTargetPos.z - this.currentPos.z;
            this.basePos.setTo(this.currentPos.x, this.currentPos.y, this.currentPos.z);
            this.alltime = v3d.length / this.speed;
        };
        SkillSinPath.prototype.update = function (t) {
            this.time = t;
            this.lastTime += t;
            if (this.hasReached) {
                this.endTime += t;
                if (this.endTime > 200) {
                    this.applyArrive();
                }
                return;
            }
            this.skillTrajectory.setCurrentPos();
            var ypos = (this.lastTime / this.alltime);
            if (ypos > 1) {
                ypos = 1;
            }
            //ypos = ypos - ypos * ypos;   
            //ypos *= 150; 
            var offsetv3d = this.getOffset(ypos);
            this._currentDirect.x = this.currentTargetPos.x - this.basePos.x;
            this._currentDirect.y = this.currentTargetPos.y - this.basePos.y;
            this._currentDirect.z = this.currentTargetPos.z - this.basePos.z;
            this._currentDirect.normalize();
            this._currentDirect.scaleBy(this.speed);
            this.setRotationMatrix(this.currentTargetPos.subtract(this.basePos));
            if (this._currentDirect.length == 0) {
                this.arrive();
                return;
            }
            var currentDistance = this._currentDirect.length * this.time;
            if (!this.hasReached) {
                var targetDistance = tl3d.Vector3D.distance(this.basePos, this.currentTargetPos);
                this.basePos.x += this._currentDirect.x * this.time;
                this.basePos.y += this._currentDirect.y * this.time;
                this.basePos.z += this._currentDirect.z * this.time;
                // this.currentPos.x = this.basePos.x + ypos;
                // this.currentPos.y = this.basePos.y;
                // this.currentPos.z = this.basePos.z;
                this.setApplyPos(offsetv3d);
            }
            if (currentDistance > targetDistance) {
                this.arrive();
            }
            //this.distance += currentDistance;
        };
        SkillSinPath.prototype.setApplyPos = function ($offset) {
            this.currentPos.x = this.basePos.x + $offset.x;
            this.currentPos.y = this.basePos.y + $offset.y;
            this.currentPos.z = this.basePos.z + $offset.z;
        };
        SkillSinPath.prototype.getOffset = function (ypos) {
            ypos = Math.sin(ypos * Math.PI) * 100;
            var offsetv3d = this._currentDirect.cross(new tl3d.Vector3D(0, 1, 0));
            offsetv3d.scaleBy(ypos);
            return new tl3d.Vector3D;
        };
        SkillSinPath.prototype.reset = function () {
            _super.prototype.reset.call(this);
            this.lastTime = 0;
        };
        return SkillSinPath;
    }(tl3d.SkillPath));
    tl3d.SkillSinPath = SkillSinPath;
    var SkillCosPath = /** @class */ (function (_super) {
        __extends(SkillCosPath, _super);
        function SkillCosPath() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SkillCosPath.prototype.getOffset = function (ypos) {
            ypos = (ypos - ypos * ypos) * 300; //Math.sin(ypos * Math.PI) * 100;
            var offsetv3d = this._currentDirect.cross(new tl3d.Vector3D(0, -1, 0));
            offsetv3d.scaleBy(ypos);
            return new tl3d.Vector3D;
        };
        return SkillCosPath;
    }(SkillSinPath));
    tl3d.SkillCosPath = SkillCosPath;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkillKeyVo = /** @class */ (function () {
        function SkillKeyVo() {
            this.frame = 0;
        }
        SkillKeyVo.prototype.setData = function ($data) {
            this.frame = $data.frame;
            this.url = $data.url;
        };
        return SkillKeyVo;
    }());
    tl3d.SkillKeyVo = SkillKeyVo;
    var SkillShockVo = /** @class */ (function () {
        function SkillShockVo() {
        }
        SkillShockVo.prototype.setData = function ($data) {
            this.time = $data.time * tl3d.Scene_data.frameTime;
            this.lasttime = $data.lasttime * tl3d.Scene_data.frameTime;
            this.amp = $data.amp;
        };
        return SkillShockVo;
    }());
    tl3d.SkillShockVo = SkillShockVo;
    var SkillFixEffectKeyVo = /** @class */ (function (_super) {
        __extends(SkillFixEffectKeyVo, _super);
        function SkillFixEffectKeyVo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SkillFixEffectKeyVo.prototype.setData = function ($data) {
            _super.prototype.setData.call(this, $data);
            this.hasSocket = $data.hasSocket;
            if (this.hasSocket) {
                this.socket = $data.socket;
            }
            else {
                this.pos = new tl3d.Vector3D($data.pos.x, $data.pos.y, $data.pos.z);
                this.rotation = new tl3d.Vector3D($data.rotation.x, $data.rotation.y, $data.rotation.z);
            }
        };
        return SkillFixEffectKeyVo;
    }(SkillKeyVo));
    tl3d.SkillFixEffectKeyVo = SkillFixEffectKeyVo;
    var SkillTrajectoryTargetKeyVo = /** @class */ (function (_super) {
        __extends(SkillTrajectoryTargetKeyVo, _super);
        function SkillTrajectoryTargetKeyVo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SkillTrajectoryTargetKeyVo.prototype.setData = function ($data) {
            _super.prototype.setData.call(this, $data);
            this.beginType = $data.beginType;
            if (this.beginType == 0) {
                this.beginPos = new tl3d.Vector3D($data.beginPos.x, $data.beginPos.y, $data.beginPos.z);
            }
            else if (this.beginType == 1) {
                this.beginSocket = $data.beginSocket;
            }
            this.speed = $data.speed;
            if ($data.hitSocket) {
                this.hitSocket = $data.hitSocket;
            }
            if ($data.endParticle) {
                this.endParticleUrl = $data.endParticle;
            }
            this.multype = $data.multype;
        };
        return SkillTrajectoryTargetKeyVo;
    }(SkillKeyVo));
    tl3d.SkillTrajectoryTargetKeyVo = SkillTrajectoryTargetKeyVo;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkillVo = /** @class */ (function () {
        function SkillVo() {
        }
        SkillVo.prototype.setData = function ($info) {
            this.keyAry = new Array;
            if (!$info) {
                //console.log("技能有错")
            }
            this.action = $info.action;
            this.skillname = $info.skillname;
            this.bloodTime = $info.blood;
            this.types = $info.type;
            if (this.types == SkillType.FixEffect) {
                this.keyAry = this.getFixEffect($info.data);
            }
            else if (this.types == SkillType.TrajectoryDynamicTarget || this.types == SkillType.TrajectoryDynamicPoint) {
                this.keyAry = this.getTrajectoryDynamicTarget($info.data);
            }
            if ($info.sound) {
                this.sound = new tl3d.SkillKeyVo;
                this.sound.frame = $info.sound.time * tl3d.Scene_data.frameTime;
                this.sound.url = $info.sound.name;
            }
            if ($info.shock) {
                this.shockAry = this.getShockAry($info.shock);
            }
        };
        SkillVo.prototype.getShockAry = function ($ary) {
            var keyAry = new Array;
            for (var i = 0; i < $ary.length; i++) {
                var key = new tl3d.SkillShockVo();
                key.setData($ary[i]);
                keyAry.push(key);
            }
            return keyAry;
        };
        SkillVo.prototype.getFixEffect = function ($ary) {
            var keyAry = new Array;
            for (var i = 0; i < $ary.length; i++) {
                var key = new tl3d.SkillFixEffectKeyVo();
                key.setData($ary[i]);
                keyAry.push(key);
            }
            return keyAry;
        };
        SkillVo.prototype.getTrajectoryDynamicTarget = function ($ary) {
            var keyAry = new Array;
            for (var i = 0; i < $ary.length; i++) {
                var key = new tl3d.SkillTrajectoryTargetKeyVo();
                key.setData($ary[i]);
                keyAry.push(key);
            }
            return keyAry;
        };
        SkillVo.defaultBloodTime = 250;
        return SkillVo;
    }());
    tl3d.SkillVo = SkillVo;
    /**
     * 技能类型
     */
    var SkillType = /** @class */ (function () {
        function SkillType() {
        }
        SkillType.TrajectoryDynamicTarget = 1; //动态轨迹对象，线性运动
        SkillType.FixEffect = 4; //固定特效，添加固定位置
        SkillType.TrajectoryDynamicPoint = 3; //动态点，添加动态位置
        return SkillType;
    }());
    tl3d.SkillType = SkillType;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var PuiData = /** @class */ (function () {
        function PuiData() {
        }
        /** 方形高亮64*64 */
        PuiData.A_HIGHT_F = "A_hight_f";
        /** tab高亮边框10*10 */
        PuiData.TAB_HIGHT = "Tab_hight";
        /** 圆形高亮75*75 */
        PuiData.A_HIGHT_C = "A_hight_c";
        /** 关闭按钮43*41 */
        PuiData.A_DELETEBTN = "A_deletebtn";
        /** 真气图标27*27 */
        PuiData.A_ZHENQI = "A_zhenqi";
        /** 兽灵图标27*27 */
        PuiData.A_SHOULING = "A_SHOULING";
        /** 精华图标27*27 */
        PuiData.A_JINGHUA = "A_JINGHUA";
        /** 箭头36*44 */
        PuiData.A_JIANTOU = "A_jiantou";
        /** 物品框44*44 */
        PuiData.A_WUPINKUANG = "A_wupinkuang";
        /** 圆形黑框69*69 */
        PuiData.A_BLACK_C = "A_black_c";
        /** 方形黑框64*64 */
        PuiData.A_BLACK_F = "A_black_f";
        /** 黑色星星28*28 */
        PuiData.A_BLACK_START = "A_black_start";
        /** 亮色星星28*28 */
        PuiData.A_HIGHT_START = "A_hight_start";
        /** 圆形头像底色71*71 */
        PuiData.A_BLACK_BASE = "A_black_base ";
        /** 红点17*16 */
        PuiData.A_RED_POINT = "A_red_point";
        /** 银币25*23 */
        PuiData.A_YINBI = "A_yinbi";
        /** 元宝25*23 */
        PuiData.A_YUANBAO = "A_yuanbao";
        /** 帮贡25*25 */
        PuiData.A_BANGGONG = "A_banggong";
        /** 斗魂25*25 */
        PuiData.A_DOUHUN = "A_DOUHUN";
        /** 经验25*25 */
        PuiData.A_EXP = "A_EXP";
        /** 荣誉25*25 */
        PuiData.A_HONOR = "A_HONOR";
        /** 绑定元宝25*23 */
        PuiData.A_BANGYUAN = "A_bangyuan";
        /** 右边括号25*19 */
        PuiData.A_RIGHT_XING = "A_RIGHT_XING";
        /** 单独一个星字18*19 */
        PuiData.A_SSTART = "A_SSTART";
        /** 左边括号8*19 */
        PuiData.A_LEFT_XING = "A_LEFT_XING";
        /** 武器紫色62*62 */
        PuiData.A_GOODS_PURPLE = "A_GOODS_PURPLE";
        /** 武器蓝色62*62 */
        PuiData.A_GOODS_BLUE = "A_GOODS_BLUE";
        /** 武器红色62*62 */
        PuiData.A_GOODS_RED = "A_GOODS_RED";
        /** 武器绿色62*62 */
        PuiData.A_GOODS_GREEN = "A_GOODS_GREEN";
        /** 武器白色62*62 */
        PuiData.A_GOODS_WHITE = "A_GOODS_WHITE";
        /** 武器橙色62*62 */
        PuiData.A_GOODS_ORANGE = "A_GOODS_ORANGE";
        /** 金星背景24*23 */
        PuiData.A_START_BG = "A_START_BG";
        /** 金星24*23 */
        PuiData.A_START = "A_START";
        /** 链条65*65 */
        PuiData.A_CHAIN = "A_CHAIN";
        /** 已装备26*56 */
        PuiData.A_OK = "A_OK";
        /** 前往按钮78*46 */
        PuiData.A_QIANWANG = "A_QIANWANG";
        /** T左31*62 */
        PuiData.T_LEFT = "T_LEFT";
        /** T中8*62 */
        PuiData.T_MID = "T_MID";
        /** T右60*62 */
        PuiData.T_RIGHT = "T_RIGHT";
        /** E左31*62 */
        PuiData.E_LEFT = "E_LEFT";
        /** E中8*62 */
        PuiData.E_MID = "E_MID";
        /** E右60*62 */
        PuiData.E_RIGHT = "E_RIGHT";
        /** F左31*62 */
        PuiData.F_LEFT = "F_LEFT";
        /** F中8*62 */
        PuiData.F_MID = "F_MID";
        /** F右60*62 */
        PuiData.F_RIGHT = "F_RIGHT";
        /** 22*22的物品框 */
        PuiData.A_F_22 = "A_F_22";
        /** 66*66的人物头像框 */
        PuiData.A_BLACK_BASE_66 = "A_BLACK_BASE_66 ";
        /** 66*66的人物头像框亮 */
        PuiData.A_HIGHR_C_66 = "A_HIGHR_C_66";
        /** 22*19Vip的V */
        PuiData.A_V = "A_V";
        /** 8*8赠送物品格的背景 */
        PuiData.A_GIVING_BG = "A_GIVING_BG";
        /** 24*24减号 */
        PuiData.B_SUB = "B_SUB";
        /** 90*90家族头像底框 */
        PuiData.A_FACTION_ICON = "A_FACTION_ICON";
        /** 30*30选中勾选框 */
        PuiData.SELECT_1 = "SELECT_1";
        /** 30*30未选中勾选框 */
        PuiData.SELECT_0 = "SELECT_0";
        /** 15*16排行榜用到的阶字 */
        PuiData.A_JIE = "A_JIE";
        /** 15*16排行榜用到的星字 */
        PuiData.A_XING = "A_XING";
        /** 系统提示文字北京 */
        PuiData.T_tips_txt_bg = "T_tips_txt_bg";
        /** Item底51*51 */
        PuiData.ITEMBG = "ITEMBG";
        /** 左边任务背景 */
        PuiData.A_quest_top = "A_quest_top";
        PuiData.A_quest_mid = "A_quest_mid";
        PuiData.A_quest_bottom = "A_quest_bottom";
        /** 左边任务<主> */
        PuiData.A_quest_ion0 = "A_quest_ion0";
        /** 左边任务<支> */
        PuiData.A_quest_ion1 = "A_quest_ion1";
        /** 左边任务<奇> */
        PuiData.A_quest_ion2 = "A_quest_ion2";
        /** 左边任务<活> */
        PuiData.A_quest_ion3 = "A_quest_ion3";
        /** 左边任务<完成> */
        PuiData.A_quest_finish = "A_quest_finish";
        PuiData.S_sys_tip0 = "S_sys_tip0";
        PuiData.S_sys_tip1 = "S_sys_tip1";
        /** 站力文字 */
        PuiData.A_zhanli_label = "A_zhanli_label";
        PuiData.A_gou = "A_gou";
        PuiData.A_cha = "A_cha";
        /** 战斗飘字 50*25 */
        PuiData.TYPE3 = "TYPE3"; //闪避
        PuiData.TYPE5 = "TYPE5"; //晕眩
        PuiData.TYPE9 = "TYPE9"; //经验
        PuiData.TYPE7 = "TYPE7"; //攻击
        PuiData.B_ZHUFUZHI = "B_ZHUFUZHI"; //
        PuiData.B_DABAOJI = "B_DABAOJI"; //攻击
        PuiData.B_XIAOBAOJI = "B_XIAOBAOJI"; //攻击
        PuiData.B_JINGYAN = "B_JINGYAN"; //攻击
        PuiData.NewPicBg = "NewPicBg"; //图片底
        PuiData.Select = "Select"; //选中
        PuiData.CostBg = "CostBg"; //背景3
        PuiData.BG2 = "BG2"; //背景2
        PuiData.PropBg40 = "PropBg40"; //46*46新物品框
        PuiData.PropBg60 = "PropBg60"; //66*66新物品框
        PuiData.PropBg100 = "PropBg100"; //108*108新物品框
        PuiData.REWARD_BG1 = "REWARD_BG1"; //46*46主界面物品背景
        PuiData.SKILL_BG68 = "SKILL_BG68"; //68*68技能背景
        PuiData.SKILL_BG58 = "SKILL_BG58"; //58*58技能背景
        PuiData.BG6 = "BG6"; //通用背景6
        PuiData.Slist_nselect = "Slist_nselect"; //未选中边框
        PuiData.Slist_select = "Slist_select"; //选中边框
        PuiData.TXTBG = "TXTBG"; //文本底框
        PuiData.ARROW_TOP = "ARROW_TOP"; //上箭头
        PuiData.ARROW_RIGHT = "ARROW_RIGHT"; //右箭头
        PuiData.MASK = "MASK"; //遮罩
        PuiData.BTNADD = "BTNADD"; //添加按钮
        PuiData.BOSSBG76 = "BOSSBG76"; //boss头像底框76*76
        PuiData.BOSSBG64 = "BOSSBG64"; //boss头像底框64*64
        PuiData.CIRCL74 = "CIRCL74"; //圆形头像选中框
        PuiData.LISTITEMBG = "LISTITEMBG"; //slist条纹底
        PuiData.ADDITEM = "ADDITEM"; //加号35*35
        PuiData.HASSEL = "HASSEL"; //已放入背景27*27 .9
        PuiData.SKILL_LEV_BG = "SKILL_LEV_BG"; //技能等级背景53*18 
        PuiData.TITLEBG = "TITLEBG"; //称号背景40*35 .9
        PuiData.TITLEHIGHT = "TITLEHIGHT"; //称号选中46*45 .9
        PuiData.NEWLISTITEMBG = "NEWLISTITEMBG"; //新的item背景 随意拉伸
        PuiData.CHATBG = "CHATBG"; //聊天背景底框 .9
        PuiData.ITEMBIGBG = "ITEMBIGBG"; //底框 .9
        PuiData.I1bg_2 = "I1bg_2"; //福利底框 .9
        PuiData.I1bg_1 = "I1bg_1"; //福利底框 .9
        PuiData.ARROWUP = "ARROWUP"; //上箭头
        PuiData.ARROWDOWN = "ARROWDOWN"; //下箭头   
        PuiData.A_EQULEVBG = "A_EQULEVBG"; //品阶底41*17   
        PuiData.DISABLE = "DISABLE"; //不可用23*23  
        PuiData.EQUBG = "EQUBG"; //道具框粉色背景10*10
        PuiData.RESLISTBG = "RESLISTBG"; //资源获取背景10*10
        PuiData.A_CARD_C = "A_CARD_C"; //采集图标
        PuiData.A_CARD_G = "A_CARD_G"; //怪物图标
        PuiData.A_CARD_B = "A_CARD_B"; //押镖图标
        PuiData.RESBG = "RESBG"; //资源获取list背景
        PuiData.STATEUP_LISTBG = "STATEUP_LISTBG"; //境界突破list背景124*53
        PuiData.A_LEAGUELISTBG = "A_LEAGUELISTBG"; //联赛list背景76*33
        PuiData.TEAMLISTBG = "TEAMLISTBG"; //队伍list背景54*51 22*20 
        PuiData.A_JJ0 = "A_JJ0"; //境界提头
        PuiData.A_JJ1 = "A_JJ1"; //境界提头
        PuiData.A_JJ2 = "A_JJ2"; //境界提头
        PuiData.A_JJ3 = "A_JJ3"; //境界提头
        PuiData.A_JJ4 = "A_JJ4"; //境界提头
        PuiData.A_JJ5 = "A_JJ5"; //境界提头
        PuiData.A_JJ6 = "A_JJ6"; //境界提头
        PuiData.A_JJ7 = "A_JJ7"; //境界提头
        PuiData.A_JJ8 = "A_JJ8"; //境界提头
        PuiData.A_JJ9 = "A_JJ9"; //境界提头
        PuiData.A_JJ10 = "A_JJ10"; //境界提头
        return PuiData;
    }());
    tl3d.PuiData = PuiData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UiTweenVo = /** @class */ (function () {
        function UiTweenVo() {
            this._scale = 1;
        }
        Object.defineProperty(UiTweenVo.prototype, "ui", {
            get: function () {
                return this._ui;
            },
            set: function (value) {
                this._ui = value;
                this._baseRect = new tl3d.Rectangle(this._ui.x, this._ui.y, this._ui.width, this._ui.height);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UiTweenVo.prototype, "scale", {
            get: function () {
                return this._scale;
            },
            set: function (value) {
                this._scale = value;
                this._ui.width = this._baseRect.width * this._scale;
                this._ui.height = this._baseRect.height * this._scale;
                this._ui.x = this._baseRect.x + (this._baseRect.width - this._ui.width) / 2;
                this._ui.y = this._baseRect.y + (this._baseRect.height - this._ui.height) / 2;
            },
            enumerable: true,
            configurable: true
        });
        UiTweenVo.prototype.destory = function () {
            this._ui = null;
            this._scale = null;
            this._baseRect = null;
        };
        UiTweenVo.getPosByPanel = function ($v2d, $layout, $toUIConatiner) {
            if ($layout === void 0) { $layout = null; }
            if ($toUIConatiner === void 0) { $toUIConatiner = null; }
            if (!this.baseUIConatiner) {
                this.baseUIConatiner = new tl3d.UIConatiner;
            }
            this.baseUIConatiner.width = tl3d.UIData.designWidth;
            this.baseUIConatiner.height = tl3d.UIData.designHeight;
            this.baseUIConatiner.middle = 0;
            this.baseUIConatiner.center = 0;
            if ($layout) {
                for (var $key in $layout) {
                    this.baseUIConatiner[$key] = $layout[$key];
                }
            }
            this.baseUIConatiner.resize();
            var $toPos = new tl3d.Vector2D;
            $toPos.x = $v2d.x + this.baseUIConatiner.x / tl3d.UIData.Scale;
            $toPos.y = $v2d.y + this.baseUIConatiner.y / tl3d.UIData.Scale;
            if ($toUIConatiner) {
                $toPos.x = $toPos.x - ($toUIConatiner.x / tl3d.UIData.Scale);
                $toPos.y = $toPos.y - ($toUIConatiner.y / tl3d.UIData.Scale);
            }
            return $toPos;
        };
        return UiTweenVo;
    }());
    tl3d.UiTweenVo = UiTweenVo;
    var UiTweenScale = /** @class */ (function () {
        function UiTweenScale() {
        }
        UiTweenScale.getInstance = function () {
            if (!this._instance) {
                this._instance = new UiTweenScale();
            }
            return this._instance;
        };
        UiTweenScale.prototype.changeButSize = function ($ui) {
        };
        return UiTweenScale;
    }());
    tl3d.UiTweenScale = UiTweenScale;
    var UIManager = /** @class */ (function () {
        function UIManager() {
            this._eventItem = new Array;
            this.lastTime = 0;
            tl3d.Scene_data.uiStage = new tl3d.UIStage();
            tl3d.Scene_data.uiBlankStage = new tl3d.UIStage();
            this._canvas = document.createElement("canvas");
            this._canvas.style.zIndex = "3";
            this._canvas.width = 200;
            this._canvas.height = 200;
            this._canvas.style.left = 200;
            this._canvas.style.top = 300;
            this._ctx = this._canvas.getContext("2d");
            this._ctx.textBaseline = "top";
        }
        UIManager.getInstance = function () {
            var _this = this;
            if (!this._instance) {
                this._instance = new UIManager();
                UIManager.popClikNameFun = function ($name, $id) {
                    if ($id === void 0) { $id = 0; }
                    _this.uiClikName($name, $id);
                };
            }
            return this._instance;
        };
        UIManager.uiClikName = function ($name, $id) {
        };
        UIManager.prototype.getContext2D = function ($width, $height, alianDefault) {
            if (alianDefault === void 0) { alianDefault = true; }
            this._canvas.width = $width;
            this._canvas.height = $height;
            this._ctx.clearRect(0, 0, $width, $height);
            alianDefault = true;
            if (alianDefault) {
                this._ctx.textBaseline = "top";
                this._ctx.textAlign = "left";
            }
            return this._ctx;
        };
        UIManager.prototype.getGrayImageDatabyImg = function ($img) {
            var $ctx = UIManager.getInstance().getContext2D($img.width, $img.height, false);
            $ctx.drawImage($img, 0, 0);
            var $imgData = $ctx.getImageData(0, 0, $img.width, $img.height);
            var $gray;
            for (var i = 0; i < $imgData.data.length; i += 4) {
                $gray = Math.floor($imgData.data[i + 0] * 0.3) + Math.floor($imgData.data[i + 1] * 0.59) + Math.floor($imgData.data[i + 2] * 0.11);
                $imgData.data[i + 0] = $gray;
                $imgData.data[i + 1] = $gray;
                $imgData.data[i + 2] = $gray;
            }
            return $imgData;
        };
        UIManager.prototype.makeCtxToGray = function ($ctx, $rect) {
            var $imgData = $ctx.getImageData($rect.x, $rect.y, $rect.width, $rect.height);
            var $gray;
            for (var i = 0; i < $imgData.data.length; i += 4) {
                $gray = Math.floor($imgData.data[i + 0] * 0.3) + Math.floor($imgData.data[i + 1] * 0.59) + Math.floor($imgData.data[i + 2] * 0.11);
                $gray = $gray * 0.5 + 0.5;
                $imgData.data[i + 0] = $gray;
                $imgData.data[i + 1] = $gray;
                $imgData.data[i + 2] = $gray;
            }
            $ctx.putImageData($imgData, $rect.x, $rect.y);
        };
        UIManager.prototype.showCanvas = function ($x, $y) {
            if ($x === void 0) { $x = 0; }
            if ($y === void 0) { $y = 0; }
            this._canvas.style.left = $x;
            this._canvas.style.top = $y;
            document.getElementById("root").appendChild(this._canvas);
        };
        UIManager.prototype.init = function () {
            tl3d.ProgrmaManager.getInstance().registe(tl3d.UIShader.UI_SHADER, new tl3d.UIShader());
            tl3d.ProgrmaManager.getInstance().registe(tl3d.UIImageShader.UI_IMG_SHADER, new tl3d.UIImageShader());
            tl3d.ProgrmaManager.getInstance().registe(tl3d.UIMaskShader.UI_MASK_SHADER, new tl3d.UIMaskShader());
            tl3d.ProgrmaManager.getInstance().registe(tl3d.Movie2DShader.MOVIE2D_SHADER, new tl3d.Movie2DShader());
            tl3d.ProgrmaManager.getInstance().registe(tl3d.Sprite2DShader.SPRITE2D_SHADER, new tl3d.Sprite2DShader());
            this._uiList = new Array;
            this._containerList = new Array;
            //UIData.setDesignWH(600, 400);
            //UIData.setDesignWH(50 * 16, 50 * 9);
            tl3d.UIData.setDesignWH(960, 540);
            //  UIData.setDesignWH(1280, 720);
        };
        UIManager.prototype.addUI = function ($ui) {
            var $id = 0;
            for (var i = this._uiList.length - 1; i >= 0; i--) {
                if (this._uiList[i].sortnum <= $ui.sortnum) {
                    $id = i + 1;
                    break;
                }
            }
            this._uiList.splice($id, 0, $ui);
            // this._uiList.push($ui)
            $ui.rendering = true;
        };
        UIManager.prototype.removeUI = function ($ui) {
            var index = this._uiList.indexOf($ui);
            $ui.rendering = false;
            if (index != -1) {
                this._uiList.splice(index, 1);
            }
        };
        UIManager.prototype.addUIContainer = function ($container) {
            if ($container.hasStage) {
                return;
            }
            this._containerList.push($container);
            $container.resize();
            for (var i = 0; i < $container.renderList.length; i++) {
                this.addUI($container.renderList[i]);
            }
            $container.hasStage = true;
        };
        UIManager.prototype.removeAll = function () {
            while (this._containerList.length) {
                ////console.log("this._containerList.length",this._containerList.length)
                this.removeUIContainer(this._containerList[this._containerList.length - 1]);
            }
        };
        UIManager.prototype.removeUIContainer = function ($container) {
            if (!$container.hasStage) {
                return;
            }
            var index = this._containerList.indexOf($container);
            $container.hasStage = false;
            if (index != -1) {
                this._containerList.splice(index, 1);
            }
            for (var i = 0; i < $container.renderList.length; i++) {
                this.removeUI($container.renderList[i]);
            }
        };
        UIManager.prototype.hasWindowUI = function () {
            return false;
        };
        UIManager.prototype.removeNoInterfaceUI = function () {
            for (var i = (this._containerList.length - 1); i >= 0; i--) {
                if (!this._containerList[i].interfaceUI) { //非主界面的时候
                    this.removeUIContainer(this._containerList[i]);
                }
            }
        };
        UIManager.prototype.resize = function () {
            if (!this._uiList) {
                return;
            }
            tl3d.UIData.resize();
            for (var i = 0; i < this._uiList.length; i++) {
                this._uiList[i].resize();
            }
            for (var i = 0; i < this._containerList.length; i++) {
                this._containerList[i].resize();
            }
        };
        UIManager.prototype.upBgGroundZero = function () {
            for (var i = 0; i < this._uiList.length; i++) {
                if (this._uiList[i].container.layer == -1 || this._uiList[i].sortnum == -1) {
                    this._uiList[i].update();
                }
            }
        };
        UIManager.prototype.update = function () {
            for (var i = 0; i < this._uiList.length; i++) {
                if (this._uiList[i].container.layer >= 0 && this._uiList[i].sortnum != -1) {
                    this._uiList[i].update();
                }
            }
        };
        //private _touch: any;
        UIManager.prototype.regEvent = function ($touce) {
            //this._touch = $touce;
            //this._touch.on("panstart panmove panend tap", ($e: any) => { this.onTouch($e) });
            // if (false) {
            //     if (Scene_data.isPc) {
            //         document.addEventListener(MouseType.MouseDown, ($evt: MouseEvent) => { this.onMouse($evt) });
            //         document.addEventListener(MouseType.MouseUp, ($evt: MouseEvent) => { this.onMouse($evt) });
            //         document.addEventListener(MouseType.MouseMove, ($evt: MouseEvent) => { this.onMouse($evt) });
            //     } else {
            //         document.addEventListener(MouseType.TouchStart, ($evt: TouchEvent) => { this.onTouch($evt) });
            //         document.addEventListener(MouseType.TouchEnd, ($evt: TouchEvent) => { this.onTouch($evt) });
            //         document.addEventListener(MouseType.TouchMove, ($evt: TouchEvent) => { this.onTouch($evt) });
            //     }
            // }
        };
        UIManager.prototype.onTouch = function ($e) {
            this.interactiveEvent($e);
        };
        UIManager.prototype.onMouse = function ($e) {
            this.interactiveEvent($e);
        };
        UIManager.prototype.interactiveEvent = function ($e) {
            var evt;
            var point = new tl3d.Vector2D();
            if ($e instanceof MouseEvent) {
                if ($e.type == tl3d.MouseType.MouseDown) {
                    evt = new tl3d.InteractiveEvent(tl3d.InteractiveEvent.Down);
                }
                else if ($e.type == tl3d.MouseType.MouseUp) {
                    evt = new tl3d.InteractiveEvent(tl3d.InteractiveEvent.Up);
                }
                else if ($e.type == tl3d.MouseType.MouseMove) {
                    evt = new tl3d.InteractiveEvent(tl3d.InteractiveEvent.Move);
                }
                else if ($e.type == tl3d.MouseType.MouseClick) {
                }
                //evt.x = $e.pageX;
                //evt.y = $e.pageY;
                point.x = $e.pageX;
                point.y = $e.pageY;
            }
            else {
                if ($e.type == tl3d.MouseType.TouchStart) {
                    //$e.preventDefault();
                    evt = new tl3d.InteractiveEvent(tl3d.InteractiveEvent.Down);
                    if ($e.touches.length > 1) {
                        // evt = new InteractiveEvent(InteractiveEvent.PinchStart);
                        // this.lastSwipeDis = MathClass.math_distance($e.touches[0].clientX, $e.touches[0].clientY, $e.touches[1].clientX, $e.touches[1].clientY);
                        // this.lastSwipeRot = Math.atan2($e.touches[1].clientY - $e.touches[0].clientY, $e.touches[1].clientX - $e.touches[0].clientX);
                        point.x = $e.touches[$e.touches.length - 1].pageX;
                        point.y = $e.touches[$e.touches.length - 1].pageY;
                    }
                    else {
                        point.x = $e.pageX;
                        point.y = $e.pageY;
                    }
                }
                else if ($e.type == tl3d.MouseType.TouchEnd) {
                    //alert("touseend");
                    evt = new tl3d.InteractiveEvent(tl3d.InteractiveEvent.Up);
                    point.x = $e.changedTouches[0].pageX;
                    point.y = $e.changedTouches[0].pageY;
                }
                else if ($e.type == tl3d.MouseType.TouchMove) {
                    //$e.preventDefault();
                    if ($e.touches.length > 1) {
                        evt = new tl3d.InteractiveEvent(tl3d.InteractiveEvent.Pinch);
                        evt.data = tl3d.MathClass.math_distance($e.touches[0].clientX, $e.touches[0].clientY, $e.touches[1].clientX, $e.touches[1].clientY) / this.lastSwipeDis;
                        evt.roation = (Math.atan2($e.touches[1].clientY - $e.touches[0].clientY, $e.touches[1].clientX - $e.touches[0].clientX) - this.lastSwipeRot) * 180 / Math.PI;
                    }
                    else {
                        evt = new tl3d.InteractiveEvent(tl3d.InteractiveEvent.Move);
                    }
                    point.x = $e.pageX;
                    point.y = $e.pageY;
                }
                if ($e.touches.length) {
                    for (var i = 0; i < $e.touches.length; i++) {
                        point.x = $e.touches[i].clientX;
                        point.y = $e.touches[i].clientY;
                    }
                }
            }
            ////console.log(point.x, point.y);
            this.mouseEvetData(evt, point);
        };
        UIManager.prototype.disMoveNnum = function (v2d, $num) {
            return tl3d.Vector2D.distance(v2d, this.lastMousePos) < $num;
        };
        UIManager.prototype.mouseEvetData = function (evt, point) {
            UIManager.cando = true;
            if (tl3d.Scene_data.verticalScene) {
                evt.x = point.y;
                evt.y = tl3d.Scene_data.stageHeight - point.x;
            }
            else {
                evt.x = point.x;
                evt.y = point.y;
            }
            var tf = false;
            if (!tf) {
                for (var i = this._uiList.length - 1; i >= 0; i--) {
                    if (this._uiList[i]) {
                        if (this._uiList[i].container.interfaceUI == false) { //非主UI
                            if (this._uiList[i] && this._uiList[i].interactiveEvent(evt)) {
                                tf = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (!tf) {
                for (var i = this._uiList.length - 1; i >= 0; i--) {
                    if (this._uiList[i]) {
                        if (this._uiList[i].container.interfaceUI == true) { //是主UI
                            if (this._uiList[i] && this._uiList[i].interactiveEvent(evt)) {
                                tf = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (evt.type == tl3d.InteractiveEvent.Down) {
                this.lastMousePos = new tl3d.Vector2D(evt.x, evt.y);
                var dt = tl3d.TimeUtil.getTimer() - this.lastTime;
                if (dt < 200) { //小于200毫秒就只认为是一次按下事件
                    return true;
                }
                this.lastTime = tl3d.TimeUtil.getTimer();
            }
            var $uistageTemp = tl3d.Scene_data.uiStage.interactiveEvent(evt);
            if (!tf) {
                tl3d.Scene_data.uiBlankStage.interactiveEvent(evt);
                return $uistageTemp;
            }
            else {
                return true;
            }
        };
        UIManager.prototype.setUseMouseEventCon = function ($uiConatiner) {
            this._eventItem.length = 0;
            if ($uiConatiner) {
                this._eventItem.push($uiConatiner);
            }
        };
        UIManager.prototype.getObjectsUnderPoint = function (evt) {
            for (var i = this._uiList.length - 1; i >= 0; i--) {
                if (this._uiList[i]) {
                    if (this._uiList[i] && this._uiList[i].insetUi(evt)) {
                        return this._uiList[i].insetUi(evt);
                    }
                }
            }
            return null;
        };
        UIManager.prototype.getcurrentList = function () {
            var currentList = new Array();
            for (var i = this._uiList.length - 1; i > 0; i--) {
                if (this._eventItem.length) {
                    for (var j = 0; j < this._eventItem.length; j++) {
                        if (this._eventItem[j] == this._uiList[i].container) {
                            currentList.push(this._uiList[i]);
                            j = this._eventItem.length;
                            continue;
                        }
                    }
                }
                else {
                    currentList.push(this._uiList[i]);
                }
            }
            return currentList;
        };
        UIManager.cando = true; //  标记只会选择一次。此循环结束
        return UIManager;
    }());
    tl3d.UIManager = UIManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UIStage = /** @class */ (function (_super) {
        __extends(UIStage, _super);
        function UIStage() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        UIStage.prototype.interactiveEvent = function (e) {
            var evtType = e.type;
            var eventMap = this._eventsMap;
            if (!eventMap) {
                return false;
            }
            var list = eventMap[evtType];
            if (!list) {
                return false;
            }
            var length = list.length;
            if (length == 0) {
                return false;
            }
            //for (var i: number = 0; i < length; i++) {
            //    var eventBin: any = list[i];
            //    eventBin.listener.call(eventBin.thisObject, e);
            //}
            for (var i = length - 1; i >= 0; i--) {
                var eventBin = list[i];
                eventBin.listener.call(eventBin.thisObject, e);
            }
            return true;
        };
        return UIStage;
    }(tl3d.EventDispatcher));
    tl3d.UIStage = UIStage;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var InteractiveEvent = /** @class */ (function (_super) {
        __extends(InteractiveEvent, _super);
        function InteractiveEvent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InteractiveEvent.Down = "down";
        InteractiveEvent.Up = "Up";
        InteractiveEvent.Move = "Move";
        InteractiveEvent.PinchStart = "PinchStart";
        InteractiveEvent.Pinch = "Pinch";
        return InteractiveEvent;
    }(tl3d.BaseEvent));
    tl3d.InteractiveEvent = InteractiveEvent;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TextAlign = /** @class */ (function () {
        function TextAlign() {
        }
        TextAlign.LEFT = "left";
        TextAlign.CENTER = "center";
        TextAlign.RIGHT = "right";
        TextAlign.TOP = "top";
        TextAlign.MIDDLE = "middle";
        TextAlign.BOTTOM = "bottom";
        return TextAlign;
    }());
    tl3d.TextAlign = TextAlign;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UIAtlas = /** @class */ (function () {
        //public texture: WebGLTexture;
        function UIAtlas() {
            this._hasDispose = false;
        }
        Object.defineProperty(UIAtlas.prototype, "texture", {
            get: function () {
                if (this.textureRes) {
                    return this.textureRes.texture;
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        UIAtlas.prototype.setInfo = function (configUrl, imgUrl, $fun, useImgUrl) {
            var _this = this;
            if (useImgUrl === void 0) { useImgUrl = null; }
            this._useImgUrl = useImgUrl;
            tl3d.LoadManager.getInstance().load(tl3d.Scene_data.fileRoot + configUrl, tl3d.LoadManager.XML_TYPE, function ($str) {
                var obj = JSON.parse($str);
                _this.configData = obj.uiArr;
                _this.layoutData = obj.panelArr;
                _this.loadImgUrl(imgUrl, $fun);
            });
        };
        UIAtlas.prototype.loadConfig = function (configUrl, $fun) {
            var _this = this;
            tl3d.LoadManager.getInstance().load(tl3d.Scene_data.fileRoot + configUrl, tl3d.LoadManager.XML_TYPE, function ($str) {
                var obj = JSON.parse($str);
                _this.configData = obj.uiArr;
                $fun();
            });
        };
        UIAtlas.prototype.loadImgUrl = function (imgUrl, $fun) {
            var _this = this;
            tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + imgUrl, function ($texture) {
                //this.texture = $texture.texture;
                _this.textureRes = $texture;
                ////console.log(imgUrl);
                if (_this._useImgUrl) {
                    _this.loadUseImg($fun);
                }
                else {
                    $fun();
                }
            }, 1, null, 0);
        };
        UIAtlas.prototype.loadUseImg = function ($fun) {
            this.useImg = tl3d.Util.makeImage();
            this.useImg.onload = function () {
                $fun();
            };
            this.useImg.src = tl3d.Scene_data.fileRoot + this._useImgUrl;
        };
        UIAtlas.prototype.getRec = function ($name) {
            var rec = new tl3d.UIRectangle;
            for (var j = 0; j < this.configData.length; j++) {
                if (this.configData[j].name == $name) {
                    rec.x = this.configData[j].x;
                    rec.y = this.configData[j].y;
                    rec.width = this.configData[j].width;
                    rec.height = this.configData[j].height;
                    rec.pixelWitdh = this.configData[j].ow;
                    rec.pixelHeight = this.configData[j].oh;
                    rec.pixelX = this.configData[j].ox;
                    rec.pixelY = this.configData[j].oy;
                    rec.type = this.configData[j].type;
                    rec.cellX = this.configData[j].cellX;
                    rec.cellY = this.configData[j].cellY;
                    break;
                }
            }
            return rec;
        };
        UIAtlas.prototype.getLayoutData = function ($name) {
            if (!this.layoutData) {
                return null;
            }
            for (var key in this.layoutData) {
                var ary = this.layoutData[key].item;
                for (var i = 0; i < ary.length; i++) {
                    if (ary[i].name == $name) {
                        return ary[i];
                    }
                }
            }
        };
        UIAtlas.prototype.getGridRec = function ($name) {
            var rec = new tl3d.UIGridRentangle;
            for (var j = 0; j < this.configData.length; j++) {
                if (this.configData[j].name == $name) {
                    rec.x = this.configData[j].x;
                    rec.y = this.configData[j].y;
                    rec.width = this.configData[j].width;
                    rec.height = this.configData[j].height;
                    rec.pixelWitdh = this.configData[j].ow;
                    rec.pixelHeight = this.configData[j].oh;
                    rec.pixelX = this.configData[j].ox;
                    rec.pixelY = this.configData[j].oy;
                    rec.ogw = this.configData[j].uow;
                    rec.ogh = this.configData[j].uoh;
                    break;
                }
            }
            return rec;
        };
        Object.defineProperty(UIAtlas.prototype, "hasData", {
            get: function () {
                return this.configData;
            },
            enumerable: true,
            configurable: true
        });
        UIAtlas.prototype.getObject = function ($name, $x, $y, $width, $height, $maxWidth, $maxHeight, $cellx, $celly) {
            if ($cellx === void 0) { $cellx = 0; }
            if ($celly === void 0) { $celly = 0; }
            var obj = new Object;
            obj.x = $x / $maxWidth;
            obj.y = $y / $maxHeight;
            obj.width = $width / $maxWidth;
            obj.height = $height / $maxHeight;
            obj.ow = $width;
            obj.oh = $height;
            obj.ox = $x;
            obj.oy = $y;
            obj.name = $name;
            obj.cellX = $cellx;
            obj.cellY = $celly;
            return obj;
        };
        UIAtlas.prototype.updateCtx = function ($ctx, xpos, ypos) {
            tl3d.TextureManager.getInstance().updateTexture(this.texture, xpos, ypos, $ctx);
        };
        UIAtlas.prototype.upDataPicToTexture = function ($url, $iconName) {
            var _this = this;
            tl3d.LoadManager.getInstance().load(tl3d.Scene_data.fileRoot + $url, tl3d.LoadManager.IMG_TYPE, function ($img) {
                var rec = _this.getRec($iconName);
                _this.ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
                _this.ctx.drawImage($img, 0, 0, rec.pixelWitdh, rec.pixelHeight);
                tl3d.TextureManager.getInstance().updateTexture(_this.texture, rec.pixelX, rec.pixelY, _this.ctx);
            });
        };
        UIAtlas.prototype.clearCtxTextureBySkilname = function ($iconName) {
            var rec = this.getRec($iconName);
            this.ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
            this.ctx.clearRect(0, 0, rec.pixelWitdh, rec.pixelHeight);
            tl3d.TextureManager.getInstance().updateTexture(this.texture, rec.pixelX, rec.pixelY, this.ctx);
        };
        UIAtlas.prototype.copyPicToTexture = function ($srcSkin, $desSkin) {
            var srcRec = this.getRec($srcSkin);
            var desRec = this.getRec($desSkin);
            this.ctx = tl3d.UIManager.getInstance().getContext2D(desRec.pixelWitdh, desRec.pixelHeight, false);
            this.ctx.drawImage(this.useImg, srcRec.pixelX, srcRec.pixelY, srcRec.pixelWitdh, srcRec.pixelWitdh, 0, 0, desRec.pixelWitdh, desRec.pixelWitdh);
            tl3d.TextureManager.getInstance().updateTexture(this.texture, desRec.pixelX, desRec.pixelY, this.ctx);
        };
        /**
         * 渲染文字
         */
        UIAtlas.prototype.updateLable = function ($key, $str, fontsize, fontColor, textBaseline, textAlign, bolder, maxWidth) {
            if (textBaseline === void 0) { textBaseline = "middle"; }
            if (textAlign === void 0) { textAlign = "center"; }
            if (bolder === void 0) { bolder = false; }
            if (maxWidth === void 0) { maxWidth = 0; }
            var rec = this.getRec($key);
            this.ctx = this.getTextCtx(rec, fontsize, fontColor, bolder, textBaseline, textAlign);
            var xpos = this.getTextxpos(textAlign, this.ctx);
            var ypos = this.getTextypos(textBaseline, this.ctx);
            if (maxWidth > 0) {
                this.wrapText(this.ctx, $str, xpos, ypos, maxWidth, fontsize + 3);
            }
            else {
                this.ctx.fillText($str, xpos, ypos);
            }
            tl3d.TextureManager.getInstance().updateTexture(this.texture, rec.pixelX, rec.pixelY, this.ctx);
        };
        UIAtlas.prototype.updateArtNum = function ($targetName, $srcName, num) {
            var str = String(num);
            var targetRec = this.getRec($targetName);
            var srcRec = this.getRec($srcName);
            this.ctx = tl3d.UIManager.getInstance().getContext2D(targetRec.pixelWitdh, targetRec.pixelHeight, false);
            var sw = srcRec.pixelWitdh / 10;
            for (var i = 0; i < str.length; i++) {
                var snum = Number(str.charAt(i));
                this.ctx.drawImage(this.useImg, srcRec.pixelX + snum * sw, srcRec.pixelY, sw, srcRec.pixelHeight, i * sw, 0, sw, srcRec.pixelHeight);
            }
            tl3d.TextureManager.getInstance().updateTexture(this.texture, targetRec.pixelX, targetRec.pixelY, this.ctx);
        };
        //写入单行颜色字体，字号,对齐，基础颜色 并上传显卡
        UIAtlas.prototype.writeSingleLabel = function ($key, $str, fontsize, $align, $baseColor) {
            if (fontsize === void 0) { fontsize = 12; }
            if ($align === void 0) { $align = tl3d.TextAlign.CENTER; }
            if ($baseColor === void 0) { $baseColor = "#ffffff"; }
            tl3d.LabelTextFont.writeSingleLabel(this, $key, $str, fontsize, $align, $baseColor);
        };
        //单行字绘制到CXT上
        UIAtlas.prototype.writeSingleLabelToCxt = function ($ctx, $str, fontsize, $tx, $ty) {
            if (fontsize === void 0) { fontsize = 12; }
            if ($tx === void 0) { $tx = 0; }
            if ($ty === void 0) { $ty = 0; }
            $ctx.textBaseline = "top";
            $ctx.textAlign = "left";
            $ctx.font = (true ? "bolder " : "") + " " + fontsize + "px " + tl3d.UIData.font;
            tl3d.TextRegExp.wrapText($ctx, $str, "#ffffff", $tx, $ty, 9999, 20); //9999为无限大
        };
        /**
         * 未渲染文字。只是绘制到CanvasRenderingContext2D
         * 返回CanvasRenderingContext2D对象
         */
        UIAtlas.prototype.updateLableCtx = function ($ctx, $str, $x, $y, $fontsize, $textAlign, $textBaseline, $textcolor, $textbolder, $maxWidth) {
            if ($textAlign === void 0) { $textAlign = "center"; }
            if ($textBaseline === void 0) { $textBaseline = "middle"; }
            if ($textcolor === void 0) { $textcolor = "#000000"; }
            if ($textbolder === void 0) { $textbolder = "bolder"; }
            if ($maxWidth === void 0) { $maxWidth = 0; }
            $ctx.textAlign = $textAlign;
            $ctx.textBaseline = $textBaseline;
            $ctx.fillStyle = $textcolor;
            $ctx.font = $textbolder + " " + $fontsize + "px " + tl3d.UIData.font;
            var $xpos = this.getTextxpos($textAlign, $ctx);
            if ($maxWidth > 0) {
                this.wrapText($ctx, $str, $x, $y, $maxWidth, $fontsize + 3);
            }
            else {
                $ctx.fillText($str, $x + $xpos, $y);
            }
        };
        UIAtlas.prototype.getTextCtx = function ($rec, $fontsize, $fontColor, $bolder, $textBaseline, $textAlign) {
            var $ctx = tl3d.UIManager.getInstance().getContext2D($rec.pixelWitdh, $rec.pixelHeight, false);
            $ctx.textBaseline = $textBaseline;
            $ctx.textAlign = $textAlign;
            $ctx.fillStyle = $fontColor;
            $ctx.font = ($bolder ? "bolder " : "") + " " + $fontsize + "px " + tl3d.UIData.font;
            return $ctx;
        };
        UIAtlas.prototype.getTextxpos = function ($textAlign, $ctx) {
            var $xpos = 0;
            if ($textAlign == tl3d.TextAlign.LEFT) {
                $xpos = 0;
            }
            else if ($textAlign == tl3d.TextAlign.RIGHT) {
                $xpos = $ctx.canvas.width;
            }
            else if ($textAlign == tl3d.TextAlign.CENTER) {
                $xpos = $ctx.canvas.width / 2;
            }
            return $xpos;
        };
        UIAtlas.prototype.getTextypos = function ($textBaseline, $ctx) {
            var $ypos = 0;
            if ($textBaseline == tl3d.TextAlign.BOTTOM) {
                $ypos = $ctx.canvas.height;
            }
            else if ($textBaseline == tl3d.TextAlign.TOP) {
                $ypos = 0;
            }
            else if ($textBaseline == tl3d.TextAlign.MIDDLE) {
                $ypos = $ctx.canvas.height / 2;
            }
            return $ypos;
        };
        UIAtlas.prototype.wrapText = function (context, text, x, y, maxWidth, lineHeight) {
            var words = text;
            var line = "";
            for (var n = 0; n < words.length; n++) {
                if (words[n] == "\n") {
                    context.fillText(line, x, y);
                    line = "";
                    y += lineHeight;
                }
                else {
                    var testLine = line + words[n] + " ";
                    var metrics = context.measureText(testLine);
                    var testWidth = metrics.width;
                    if (testWidth > maxWidth) {
                        context.fillText(line, x, y);
                        line = words[n] + "";
                        y += lineHeight;
                    }
                    else {
                        line = testLine;
                    }
                }
            }
            context.fillText(line, x, y);
        };
        UIAtlas.prototype.dispose = function () {
            if (this._hasDispose) {
                return;
            }
            this.textureRes.clearUseNum();
            this.configData = null;
            this.layoutData = null;
            this.useImg = null;
            this._hasDispose = true;
        };
        return UIAtlas;
    }());
    tl3d.UIAtlas = UIAtlas;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UIRenderComponent = /** @class */ (function () {
        function UIRenderComponent() {
            this._rendering = false;
            this.scale = 1;
            this.sortnum = 0; //排序编号
            this.blenderMode = 0;
            this.renderData = new Float32Array(0);
            this.renderData2 = new Float32Array(0);
            this.num = 0;
            this.visible = true;
            this.initData();
        }
        Object.defineProperty(UIRenderComponent.prototype, "rendering", {
            get: function () {
                return this._rendering;
            },
            set: function (val) {
                this._rendering = val;
                if (this._uiList) {
                    for (var i = 0; i < this._uiList.length; i++) {
                        this._uiList[i].rendering = val;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIRenderComponent.prototype, "texture", {
            get: function () {
                if (this.textureRes) {
                    return this.textureRes.texture;
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        UIRenderComponent.prototype.initData = function () {
            this._uiList = new Array;
            //   this.container = new UIConatiner();
            this.objData = new tl3d.ObjData();
            this.shader = tl3d.ProgrmaManager.getInstance().getProgram(tl3d.UIShader.UI_SHADER);
            this.program = this.shader.program;
            this.uiProLocation = tl3d.Scene_data.context3D.getLocation(this.program, "ui");
            this.ui2ProLocation = tl3d.Scene_data.context3D.getLocation(this.program, "ui2");
        };
        UIRenderComponent.prototype.resize = function () {
        };
        UIRenderComponent.prototype.setImgUrl = function ($url) {
            var _this = this;
            tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + $url, function ($texture) {
                _this.textureRes = $texture;
            });
        };
        UIRenderComponent.prototype.setInfo = function (configUrl, imgUrl, $fun) {
            this.uiAtlas = new tl3d.UIAtlas;
            this.uiAtlas.setInfo(configUrl, imgUrl, function () {
                $fun();
            });
        };
        UIRenderComponent.prototype.setAtlas = function ($atlas) {
            this.uiAtlas = $atlas;
        };
        UIRenderComponent.prototype.creatComponent = function ($tx, $ty, $tw, $th) {
            var ui = new tl3d.UICompenent();
            ui.tr.sets($tx, $ty, $tw, $th);
            ui.uiRender = this;
            return ui;
        };
        UIRenderComponent.prototype.getComponent = function ($uiName) {
            var obj = this.uiAtlas.getLayoutData($uiName);
            if (obj) {
                var types = obj.type;
                if (types == 0) {
                    var ui = this.creatBaseComponent(obj.dataItem[0]);
                    ui.width = obj.rect.width;
                    ui.height = obj.rect.height;
                    ui.x = obj.rect.x;
                    ui.y = obj.rect.y;
                    ui.baseRec = obj.rect;
                    ui.name = $uiName;
                    return ui;
                }
                else if (types == 1) {
                    var g9ui = this.creatGrid9Component(obj.dataItem[0], obj.rect.width, obj.rect.height);
                    g9ui.x = obj.rect.x;
                    g9ui.y = obj.rect.y;
                    g9ui.baseRec = obj.rect;
                    g9ui.name = $uiName;
                    return g9ui;
                }
                else if (types == 2) {
                    // if (obj.selected) {
                    //     var sbtn: Button = this.createSelectButton(obj.dataItem[0], obj.dataItem[1]);
                    //     sbtn.width = obj.rect.width;
                    //     sbtn.height = obj.rect.height;
                    //     sbtn.x = obj.rect.x;
                    //     sbtn.y = obj.rect.y;
                    //     sbtn.baseRec = obj.rect;
                    //     sbtn.name = $uiName;
                    //     return sbtn;
                    // } else {
                    //     var btn: Button = this.creatButton(obj.dataItem[0], obj.dataItem[1]);
                    //     btn.width = obj.rect.width;
                    //     btn.height = obj.rect.height;
                    //     btn.x = obj.rect.x;
                    //     btn.y = obj.rect.y;
                    //     btn.baseRec = obj.rect;
                    //     btn.name = $uiName;
                    //     return btn;
                    // }
                }
                else if (types == 4) {
                    var sFrame = this.createFrame(obj.dataItem[0]);
                    sFrame.width = obj.rect.width;
                    sFrame.height = obj.rect.height;
                    sFrame.x = obj.rect.x;
                    sFrame.y = obj.rect.y;
                    sFrame.baseRec = obj.rect;
                    sFrame.name = $uiName;
                    return sFrame;
                }
            }
            return null;
        };
        UIRenderComponent.prototype.createFrame = function ($upskin) {
            var frameMc = new tl3d.FrameCompenent;
            frameMc.skinName = $upskin;
            var rec = this.uiAtlas.getRec($upskin);
            frameMc.setFrameData(rec);
            frameMc.stopStatic == 2;
            frameMc.uiRender = this;
            return frameMc;
        };
        UIRenderComponent.prototype.creatBaseComponent = function ($skinName) {
            var ui = new tl3d.UICompenent();
            ui.skinName = $skinName;
            var rec = this.uiAtlas.getRec($skinName);
            ui.tr.setRec(rec);
            ui.width = rec.pixelWitdh;
            ui.height = rec.pixelHeight;
            ui.uiRender = this;
            return ui;
        };
        UIRenderComponent.prototype.creatGrid9Component = function ($skinName, $width, $height) {
            var ui = new tl3d.Grid9Compenent();
            ui.skinName = $skinName;
            var rec = this.uiAtlas.getGridRec($skinName);
            ui.tr.setRec(rec);
            ui.ogw = rec.ogw;
            ui.ogh = rec.ogh;
            ui.gw = ui.ogw / rec.pixelWitdh;
            ui.gh = ui.ogh / rec.pixelHeight;
            ui.width = $width;
            ui.height = $height;
            ui.uiRender = this;
            return ui;
        };
        // public creatButton($upskin: string, $downskin: string): Button {
        //     if (!this.uiAtlas.hasData) {
        //         return null;
        //     }
        //     var btn: Button = new Button;
        //     var rec: UIRectangle = this.uiAtlas.getRec($upskin)
        //     btn.tr.setRec(rec);
        //     btn.trDown.setRec(this.uiAtlas.getRec($downskin));
        //     btn.width = rec.pixelWitdh;
        //     btn.height = rec.pixelHeight;
        //     btn.uiRender = this;
        //     return btn;
        // }
        // public createSelectButton($upskin: string, $selectedskin: string): SelectButton {
        //     if (!this.uiAtlas.hasData) {
        //         return null;
        //     }
        //     var btn: SelectButton = new SelectButton;
        //     var rec: UIRectangle = this.uiAtlas.getRec($upskin)
        //     btn.tr.setRec(rec);
        //     btn.trDown.setRec(this.uiAtlas.getRec($selectedskin));
        //     btn.width = rec.pixelWitdh;
        //     btn.height = rec.pixelHeight;
        //     btn.uiRender = this;
        //     return btn;
        // }
        UIRenderComponent.prototype.addRenderUI = function (ui) {
            if (this._uiList.length >= 50) {
                //console.log("UIRenderComponent超限制51")
                alert("UIRenderComponent超限制51");
                return;
            }
            this._uiList.push(ui);
            ui.rendering = this.rendering;
            //this._uiList.sort((a: UICompenent, b: UICompenent) => { return a.z > b.z ? -1 : 1 });
            this.applyObjData();
        };
        UIRenderComponent.prototype.removeRenderUI = function (ui) {
            var index = this._uiList.indexOf(ui);
            if (index != -1) {
                this._uiList.splice(index, 1);
            }
            ui.rendering = false;
            this.applyObjData();
        };
        UIRenderComponent.prototype.applyObjData = function () {
            this.objData.vertices.length = 0;
            this.objData.uvs.length = 0;
            this.objData.indexs.length = 0;
            //var wh: number = 20;
            var beginIndex = 0;
            for (var i = 0; i < this._uiList.length; i++) {
                var ui = this._uiList[i];
                if (ui.isVirtual) {
                    continue;
                }
                //this.objData.vertices.push(
                //    0, 0, 0, 
                //    1, 0, 0,
                //    1, -1, 0,
                //    0, -1, 0);
                //this.objData.uvs.push(
                //    0, 0, i,
                //    1, 0, i,
                //    1, 1, i,
                //    0, 1, i);
                //this.objData.indexs.push(i * 4, 1 + i * 4, 2 + i * 4, i * 4, 2 + i * 4, 3 + i * 4);
                beginIndex = ui.pushVaData(this.objData, i, beginIndex);
            }
            this.objData.treNum = this.objData.indexs.length;
            if (this.objData.vertexBuffer) {
                tl3d.Scene_data.context3D.uploadBuff3DByBuffer(this.objData.vertexBuffer, this.objData.vertices);
                tl3d.Scene_data.context3D.uploadBuff3DByBuffer(this.objData.uvBuffer, this.objData.uvs);
                tl3d.Scene_data.context3D.uploadIndexBuff3DByBuffer(this.objData.indexBuffer, this.objData.indexs);
            }
            else {
                this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
                this.objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.uvs);
                this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            }
            if (this.mask) {
                this.mask.scale = this.scale;
                this.mask.applyAbsolutePoint();
            }
            this.makeRenderDataVc(-1);
        };
        //-1为所有都需要更新;
        UIRenderComponent.prototype.makeRenderDataVc = function ($vcId) {
            if (!this.renderData || (this.renderData && this.renderData.length != this._uiList.length * 4)) {
                //if (this.renderData.length != this._uiList.length * 4) {
                //  //console.log(this.renderData.length, this._uiList.length * 4, "$vcId", $vcId)
                //}
                this.renderData = new Float32Array(this._uiList.length * 4);
                this.renderData2 = new Float32Array(this._uiList.length * 4);
            }
            if ($vcId == -1) {
                for (var i = 0; this._uiList && i < this._uiList.length; i++) {
                    this._uiList[i].vcId = i;
                    this.renderData[i * 4 + 0] = this._uiList[i].renderData[0];
                    this.renderData[i * 4 + 1] = this._uiList[i].renderData[1];
                    this.renderData[i * 4 + 2] = this._uiList[i].renderData[2];
                    this.renderData[i * 4 + 3] = this._uiList[i].renderData[3];
                    this.renderData2[i * 4 + 0] = this._uiList[i].renderData2[0];
                    this.renderData2[i * 4 + 1] = this._uiList[i].renderData2[1];
                    this.renderData2[i * 4 + 2] = this._uiList[i].renderData2[2];
                    this.renderData2[i * 4 + 3] = this._uiList[i].renderData2[3];
                }
            }
            else {
                if ($vcId < this._uiList.length) {
                    this.renderData[$vcId * 4 + 0] = this._uiList[$vcId].renderData[0];
                    this.renderData[$vcId * 4 + 1] = this._uiList[$vcId].renderData[1];
                    this.renderData[$vcId * 4 + 2] = this._uiList[$vcId].renderData[2];
                    this.renderData[$vcId * 4 + 3] = this._uiList[$vcId].renderData[3];
                    this.renderData2[$vcId * 4 + 0] = this._uiList[$vcId].renderData2[0];
                    this.renderData2[$vcId * 4 + 1] = this._uiList[$vcId].renderData2[1];
                    this.renderData2[$vcId * 4 + 2] = this._uiList[$vcId].renderData2[2];
                    this.renderData2[$vcId * 4 + 3] = this._uiList[$vcId].renderData2[3];
                }
            }
        };
        UIRenderComponent.prototype.update = function () {
            if (!this.visible || this._uiList.length == 0) {
                if (this.modelRenderList && this.modelRenderList.length) {
                }
                else {
                    return;
                }
            }
            if (this.mask) {
                var renderContext = tl3d.Scene_data.context3D.renderContext;
                renderContext.enable(renderContext.STENCIL_TEST);
                renderContext.stencilMask(0xFF);
                renderContext.stencilFunc(renderContext.NEVER, this.mask.level, 0xFF);
                renderContext.stencilOp(renderContext.REPLACE, renderContext.REPLACE, renderContext.REPLACE);
                this.mask.update();
                renderContext.stencilFunc(renderContext.LESS, this.mask.level - 1, 0xFF);
                renderContext.stencilOp(renderContext.KEEP, renderContext.KEEP, renderContext.KEEP);
            }
            tl3d.Scene_data.context3D.setBlendParticleFactors(this.blenderMode);
            ////console.log(this.shader.name);
            tl3d.Scene_data.context3D.setProgram(this.program);
            this.setVc();
            tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
            tl3d.Scene_data.context3D.setVa(1, 3, this.objData.uvBuffer);
            this.setTextureToGpu();
            tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
            if (this.mask) {
                tl3d.Scene_data.context3D.renderContext.disable(tl3d.Scene_data.context3D.renderContext.STENCIL_TEST);
            }
            if (this.modelRenderList) {
                for (var i = 0; i < this.modelRenderList.length; i++) {
                    this.modelRenderList[i].update();
                }
            }
        };
        UIRenderComponent.prototype.setTextureToGpu = function () {
            if (this.uiAtlas) {
                tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this.uiAtlas.texture, 0);
            }
            else {
                tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this.texture, 0);
            }
        };
        UIRenderComponent.prototype.setVc = function () {
            // for (var i: number = 0; i < this._uiList.length; i++) {
            //     this._uiList[i].update();
            //     this._uiList[i].setVc(this.program, i);
            // }
            for (var i = 0; i < this._uiList.length; i++) {
                this._uiList[i].update();
                if (this._uiList[i].vcId != i) {
                    // //console.log(this._uiList[i].vcId , i)
                }
            }
            tl3d.Scene_data.context3D.setVc4fvLocation(this.uiProLocation, this.renderData);
            tl3d.Scene_data.context3D.setVc4fvLocation(this.ui2ProLocation, this.renderData2);
        };
        UIRenderComponent.prototype.addModel = function ($display) {
            if (!this.modelRenderList) {
                this.modelRenderList = new Array;
            }
            var idx = this.modelRenderList.indexOf($display);
            if (idx != -1) {
                return;
            }
            this.modelRenderList.push($display);
        };
        UIRenderComponent.prototype.removeModel = function ($display) {
            var idx = this.modelRenderList.indexOf($display);
            if (idx != -1) {
                this.modelRenderList.splice(idx, 1);
            }
        };
        UIRenderComponent.prototype.insetUi = function ($e) {
            for (var i = 0; i < this._uiList.length; i++) {
                if (this._uiList[i].testPoint($e.x, $e.y)) {
                    return this._uiList[i];
                }
            }
            return null;
        };
        UIRenderComponent.prototype.interactiveEvent = function ($e) {
            if (this.mask) {
                if (!this.mask.testPoint($e.x, $e.y)) {
                    return false;
                }
            }
            var tf = false;
            for (var i = 0; i < this._uiList.length; i++) {
                if (this._uiList[i].interactiveEvent($e) && tl3d.UIManager.cando) {
                    tf = true;
                    tl3d.UIManager.cando = false;
                    return true;
                }
            }
            return tf;
        };
        UIRenderComponent.prototype.dispose = function () {
            this.objData.destory();
            this.objData = null;
            if (this.uiAtlas) {
                this.uiAtlas.dispose();
                this.uiAtlas = null;
            }
            if (this.mask) {
                this.mask.dispose();
                this.mask = null;
            }
            this.renderData = null;
            this.renderData2 = null;
        };
        return UIRenderComponent;
    }());
    tl3d.UIRenderComponent = UIRenderComponent;
})(tl3d || (tl3d = {}));
/// <reference path="UIRenderComponent.ts" />

(function (tl3d) {
    var UIBackImg = /** @class */ (function (_super) {
        __extends(UIBackImg, _super);
        function UIBackImg() {
            var _this = _super.call(this) || this;
            _this._scaleData = [1, 1];
            _this._isFBO = false;
            _this.alpha = 1.0;
            return _this;
        }
        UIBackImg.prototype.initData = function () {
            this.objData = new tl3d.ObjData();
            this.shader = tl3d.ProgrmaManager.getInstance().getProgram(tl3d.UIImageShader.UI_IMG_SHADER);
            this.program = this.shader.program;
            this.objData.vertices.push(-1, 1, 0, 1, 1, 0, 1, -1, 0, -1, -1, 0);
            this.objData.uvs.push(0, 0, 1, 0, 1, 1, 0, 1);
            this.objData.indexs.push(0, 1, 2, 0, 2, 3);
            this.objData.treNum = 6;
            this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
            this.objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.uvs);
            this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
        };
        UIBackImg.prototype.resize = function () {
            this.appleyPos();
        };
        UIBackImg.prototype.setImgInfo = function ($url, $width, $height) {
            this.setImgUrl($url);
            this._width = $width;
            this._height = $height;
        };
        UIBackImg.prototype.appleyPos = function () {
            var widthScale = this._width / tl3d.Scene_data.stageWidth;
            var heightScale = this._height / tl3d.Scene_data.stageHeight;
            if (widthScale < heightScale) {
                this._scaleData[0] = 1;
                this._scaleData[1] = (this._height / tl3d.Scene_data.stageHeight) / widthScale;
            }
            else {
                this._scaleData[0] = (this._width / tl3d.Scene_data.stageWidth) / heightScale;
                this._scaleData[1] = 1;
            }
        };
        UIBackImg.prototype.setFbo = function () {
            this._isFBO = true;
        };
        UIBackImg.prototype.update = function () {
            var hasTexture = false;
            if (this._isFBO) {
                if (tl3d.Scene_data.fbo) {
                    hasTexture = true;
                }
                tl3d.Scene_data.context3D.clearContext();
                tl3d.Scene_data.context3D.setDepthTest(false);
            }
            else {
                if (this.texture) {
                    hasTexture = true;
                }
            }
            if (this.objData && hasTexture) {
                tl3d.Scene_data.context3D.setBlendParticleFactors(0);
                tl3d.Scene_data.context3D.setProgram(this.program);
                tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
                tl3d.Scene_data.context3D.setVa(1, 2, this.objData.uvBuffer);
                tl3d.Scene_data.context3D.setVc2fv(this.shader, "scale", this._scaleData);
                if (this._isFBO) {
                    tl3d.Scene_data.context3D.setVc2fv(this.shader, "scale", [1, -1]);
                    tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", tl3d.Scene_data.fbo.texture, 0);
                }
                else {
                    tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this.texture, 0);
                }
                tl3d.Scene_data.context3D.setVcFloat(this.shader, "alpha", [this.alpha]);
                tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
            }
        };
        UIBackImg.prototype.interactiveEvent = function ($e) {
            return true;
        };
        return UIBackImg;
    }(tl3d.UIRenderComponent));
    tl3d.UIBackImg = UIBackImg;
    var UIRenderOnlyPicComponent = /** @class */ (function (_super) {
        __extends(UIRenderOnlyPicComponent, _super);
        function UIRenderOnlyPicComponent() {
            return _super.call(this) || this;
        }
        UIRenderOnlyPicComponent.prototype.makeRenderDataVc = function ($vcId) {
            _super.prototype.makeRenderDataVc.call(this, $vcId);
            for (var i = 0; i < this.renderData2.length / 4; i++) {
                this.renderData2[i * 4 + 0] = 1;
                this.renderData2[i * 4 + 1] = 1;
                this.renderData2[i * 4 + 2] = 0;
                this.renderData2[i * 4 + 3] = 0;
            }
        };
        UIRenderOnlyPicComponent.prototype.update = function () {
            if (this.texture) {
                _super.prototype.update.call(this);
            }
        };
        UIRenderOnlyPicComponent.prototype.setTextureToGpu = function () {
            tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this.texture, 0);
        };
        /*
           var _bigPic: UIRenderOnlyPicComponent = new UIRenderOnlyPicComponent();
                this.addRender(_bigPic);
                _bigPic.uiAtlas = this._midRender.uiAtlas;
                _bigPic.setImgUrl("ui/uidata/basebg/skillbg.png");
                this.addChild(_bigPic.getComponent("ccav"));
    
        */
        UIRenderOnlyPicComponent.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.textureRes) {
                this.textureRes.clearUseNum();
            }
        };
        return UIRenderOnlyPicComponent;
    }(tl3d.UIRenderComponent));
    tl3d.UIRenderOnlyPicComponent = UIRenderOnlyPicComponent;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UICompenent = /** @class */ (function (_super) {
        __extends(UICompenent, _super);
        function UICompenent() {
            var _this = _super.call(this) || this;
            //设定相对坐标
            _this._x = 0;
            _this._y = 0;
            _this._width = 0;
            _this._height = 0;
            _this.z = 0;
            //设定绝对坐标
            _this.absoluteX = 0;
            _this.absoluteY = 0;
            _this.absoluteWidth = 0;
            _this.absoluteHeight = 0;
            _this.enable = true;
            _this._left = 0;
            _this._right = 0;
            _this._center = 0;
            _this._xType = -1;
            _this._top = 0;
            _this._bottom = 0;
            _this._middle = 0;
            _this._yType = -1;
            //实际渲染坐标
            _this.renderX = 0;
            _this.renderY = 0;
            _this.renderWidth = 0;
            _this.renderHeight = 0;
            _this.scale = 1;
            _this.isVirtual = false;
            _this.vcId = 0;
            _this._uvScale = 1; // UV显示比例
            _this._rendering = false;
            _this.isU = false;
            _this.isV = false;
            _this.tr = new tl3d.Rectangle;
            _this.mouseEnable = true;
            return _this;
        }
        Object.defineProperty(UICompenent.prototype, "rendering", {
            get: function () {
                return this._rendering;
            },
            set: function (val) {
                this._rendering = val;
            },
            enumerable: true,
            configurable: true
        });
        UICompenent.prototype.addStage = function () {
            this.renderData = [0, 0, 0, 0];
            this.renderData2 = [1, 1, 0, 0];
            this.applyAbsolutePoint();
            this.uiRender.addRenderUI(this);
        };
        UICompenent.prototype.removeStage = function () {
            this.uiRender.removeRenderUI(this);
        };
        UICompenent.prototype.pushVaData = function (objData, i, beginIndex) {
            objData.vertices.push(0, 0, 0, 1, 0, 0, 1, -1, 0, 0, -1, 0);
            objData.uvs.push(this.isU ? 1 : 0, this.isV ? 1 : 0, i, this.isU ? 0 : 1, this.isV ? 1 : 0, i, this.isU ? 0 : 1, this.isV ? 0 : 1, i, this.isU ? 1 : 0, this.isV ? 0 : 1, i);
            objData.indexs.push(beginIndex, 1 + beginIndex, 2 + beginIndex, beginIndex, 2 + beginIndex, 3 + beginIndex);
            return beginIndex + 4;
            /*
            objData.vertices.push(
                0, 0, 0,
                1, 0, 0,
                1, -1, 0,
                0, -1, 0);
            objData.uvs.push(
                0, 0, i,
                1, 0, i,
                1, 1, i,
                0, 1, i);
            objData.indexs.push(beginIndex, 1 + beginIndex, 2 + beginIndex, beginIndex, 2 + beginIndex, 3 + beginIndex);
            return beginIndex + 4;
            */
        };
        UICompenent.prototype.setVc = function (program, index) {
            tl3d.Scene_data.context3D.setVc4fv(program, "ui[" + index + "]", this.renderData);
            tl3d.Scene_data.context3D.setVc4fv(program, "ui2[" + index + "]", this.renderData2);
        };
        UICompenent.prototype.update = function () {
        };
        UICompenent.prototype.applyRenderSize = function () {
            if (!this.parent) {
                return;
            }
            this.renderX = this.absoluteX / tl3d.Scene_data.stageWidth;
            this.renderY = this.absoluteY / tl3d.Scene_data.stageHeight;
            this.renderWidth = this.absoluteWidth / tl3d.Scene_data.stageWidth;
            this.renderHeight = this.absoluteHeight / tl3d.Scene_data.stageHeight;
            if (this._uvScale >= 0) {
                //this.renderX + this.renderWidth * this.scale - this.renderWidth * this.scale * this._uvScale;
                this.renderData[0] = this.renderX;
                this.renderData[1] = this.renderY;
                this.renderData[2] = this.renderWidth * this.scale * this._uvScale;
                this.renderData[3] = this.renderHeight * this.scale;
                //this.tr.x +this.tr.width - this.tr.width * this._uvScale
                this.renderData2[0] = this.tr.width * this._uvScale;
                this.renderData2[1] = this.tr.height;
                this.renderData2[2] = this.tr.x;
                this.renderData2[3] = this.tr.y;
            }
            else {
                var $vt = Math.abs(this._uvScale);
                this.renderData[0] = this.renderX + this.renderWidth * (1 - $vt);
                this.renderData[1] = this.renderY;
                this.renderData[2] = this.renderWidth * this.scale * $vt;
                this.renderData[3] = this.renderHeight * this.scale;
                this.renderData2[0] = this.tr.width * $vt;
                this.renderData2[1] = this.tr.height;
                this.renderData2[2] = this.tr.x + (this.tr.width * (1 - $vt));
                this.renderData2[3] = this.tr.y;
            }
            this.uiRender.makeRenderDataVc(this.vcId);
            // 
        };
        Object.defineProperty(UICompenent.prototype, "uvScale", {
            get: function () {
                return this._uvScale;
            },
            set: function (value) {
                this._uvScale = value;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        UICompenent.prototype.setScale = function (num) {
            this.scale = num;
            this.applyAbsolutePoint();
        };
        UICompenent.prototype.applyAbsolutePoint = function () {
            if (this.parent) {
                //this.absoluteX = this._x * UIData.Scale + this.parent.x;
                //this.absoluteY = this._y * UIData.Scale + this.parent.y;
                if (this._xType == -1) {
                    this.absoluteX = this._x * tl3d.UIData.Scale * this.scale + this.parent.x;
                }
                else if (this._xType == 0) {
                    this.absoluteX = this._left * tl3d.UIData.Scale;
                }
                else if (this._xType == 1) {
                    this.absoluteX = tl3d.Scene_data.stageWidth - this._right * tl3d.UIData.Scale - this.width * tl3d.UIData.Scale;
                }
                else if (this._xType == 2) {
                    this.absoluteX = this._center * tl3d.UIData.Scale + tl3d.Scene_data.stageWidth / 2 - this.width * tl3d.UIData.Scale / 2;
                }
                if (this._yType == -1) {
                    this.absoluteY = this._y * tl3d.UIData.Scale * this.scale + this.parent.y;
                }
                else if (this._yType == 0) {
                    this.absoluteY = this._top * tl3d.UIData.Scale;
                }
                else if (this._yType == 1) {
                    this.absoluteY = tl3d.Scene_data.stageHeight - this._bottom * tl3d.UIData.Scale - this.height * tl3d.UIData.Scale;
                }
                else if (this._yType == 2) {
                    this.absoluteY = this._middle * tl3d.UIData.Scale + tl3d.Scene_data.stageHeight / 2 - this.height * tl3d.UIData.Scale / 2;
                }
                this.absoluteWidth = this.width * tl3d.UIData.Scale;
                this.absoluteHeight = this.height * tl3d.UIData.Scale;
                this.applyRenderSize();
            }
        };
        Object.defineProperty(UICompenent.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                if (value != this._x) {
                    this._x = value;
                    this.applyAbsolutePoint();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICompenent.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                if (value != this._y) {
                    this._y = value;
                    this.applyAbsolutePoint();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICompenent.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (value) {
                if (value != this._width) {
                    this._width = value;
                    this.applyAbsolutePoint();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICompenent.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (value) {
                if (value != this._height) {
                    this._height = value;
                    this.applyAbsolutePoint();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICompenent.prototype, "left", {
            set: function (value) {
                this._left = value;
                this._xType = 0;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICompenent.prototype, "right", {
            set: function (value) {
                this._right = value;
                this._xType = 1;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICompenent.prototype, "center", {
            set: function (value) {
                this._center = value;
                this._xType = 2;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICompenent.prototype, "top", {
            set: function (value) {
                this._top = value;
                this._yType = 0;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICompenent.prototype, "bottom", {
            set: function (value) {
                this._bottom = value;
                this._yType = 1;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICompenent.prototype, "middle", {
            set: function (value) {
                this._middle = value;
                this._yType = 2;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        UICompenent.prototype.testPoint = function ($x, $y) {
            if ($x > this.absoluteX && $x < (this.absoluteX + this.absoluteWidth) && $y > this.absoluteY && $y < (this.absoluteY + this.absoluteHeight)) {
                return true;
            }
            else {
                return false;
            }
        };
        UICompenent.prototype.setPos = function ($x, $y) {
            this.x = $x;
            this.y = $y;
        };
        UICompenent.prototype.interactiveEvent = function (e) {
            if (!this.enable) {
                return false;
            }
            var evtType = e.type;
            var eventMap = this._eventsMap;
            if (!eventMap) {
                return false;
            }
            var list = eventMap[e.type];
            if (!list) {
                return false;
            }
            if (!this.testPoint(e.x, e.y)) {
                return false;
            }
            var length = list.length;
            if (length == 0) {
                return false;
            }
            e.target = this;
            //for (var i: number = 0; i < length; i++) {
            //    var eventBin: any = list[i];
            //    eventBin.listener.call(eventBin.thisObject, e);
            //}
            for (var i = length - 1; i >= 0; i--) {
                var eventBin = list[i];
                //console.log("uiname", this.name)
                eventBin.listener.call(eventBin.thisObject, e);
            }
            return true;
        };
        UICompenent.prototype.preShow = function () {
            if (this.preParent) {
                this.preParent.addChild(this);
            }
        };
        UICompenent.prototype.preHide = function () {
            if (this.preParent) {
                this.preParent.removeChild(this);
            }
        };
        return UICompenent;
    }(tl3d.EventDispatcher));
    tl3d.UICompenent = UICompenent;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UIConatiner = /** @class */ (function () {
        function UIConatiner() {
            this._x = 0;
            this._y = 0;
            this._width = 0;
            this._height = 0;
            this._left = 0;
            this._right = 0;
            this._center = 0;
            this._xType = 0;
            this._top = 0;
            this._bottom = 0;
            this._middle = 0;
            this._yType = 0;
            this._list = new Array;
            this.renderList = new Array;
            this._hasStage = false;
            this._hasLoad = false;
            this._isLoading = false;
            this._needShowLoading = true;
            this._interfaceUI = false;
            this._layer = 100;
        }
        Object.defineProperty(UIConatiner.prototype, "layer", {
            get: function () {
                return this._layer;
            },
            set: function (val) {
                this._layer = val;
                for (var i = 0; i < this.renderList.length; i++) {
                    this.renderList[i].sortnum = this._layer;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIConatiner.prototype, "interfaceUI", {
            get: function () {
                return this._interfaceUI;
            },
            set: function (val) {
                this._interfaceUI = val;
                if (val) {
                    this.layer = 0;
                }
                else {
                    this.layer = 100;
                }
            },
            enumerable: true,
            configurable: true
        });
        UIConatiner.prototype.load = function ($complateFun, $needShowLoading) {
            if ($needShowLoading === void 0) { $needShowLoading = true; }
            if (this._isLoading) {
                return;
            }
            this._completeFun = $complateFun;
            this._needShowLoading = $needShowLoading;
            if (this._hasLoad) {
                $complateFun();
            }
            else {
                this._isLoading = true;
                // if (this._needShowLoading) {
                //     UILoading.getInstance().show();
                // }
                this.makeBaseWinUi();
            }
        };
        Object.defineProperty(UIConatiner.prototype, "hasLoad", {
            get: function () {
                return this._hasLoad;
            },
            enumerable: true,
            configurable: true
        });
        UIConatiner.prototype.makeBaseWinUi = function () {
            this.applyLoad();
        };
        UIConatiner.prototype.applyLoad = function () {
        };
        UIConatiner.prototype.applyLoadComplete = function () {
            this._isLoading = false;
            this._completeFun();
            // if (this._needShowLoading) {
            //     UILoading.getInstance().hide();
            // }
            this._hasLoad = true;
        };
        Object.defineProperty(UIConatiner.prototype, "hasStage", {
            get: function () {
                return this._hasStage;
            },
            set: function (val) {
                this._hasStage = val;
                if (val) {
                    this.onAdd();
                }
                else {
                    this.onRemove();
                }
            },
            enumerable: true,
            configurable: true
        });
        UIConatiner.prototype.setUiListVisibleByItem = function ($arr, $flag) {
            try {
                for (var i = 0; i < $arr.length; i++) {
                    if ($flag) {
                        if (!$arr[i].parent) {
                            this.addChild($arr[i]);
                        }
                    }
                    else {
                        if ($arr[i].parent) {
                            this.removeChild($arr[i]);
                        }
                    }
                }
            }
            catch (err) {
                //console.log("在此处理错误3");
            }
        };
        UIConatiner.prototype.onAdd = function () { };
        UIConatiner.prototype.onRemove = function () { };
        UIConatiner.prototype.addChild = function ($ui) {
            if (!$ui) {
                //console.log("ui cuo ")
                throw new Error("ui cuo");
            }
            if ($ui.parent) {
                return;
            }
            this._list.push($ui);
            $ui.parent = this;
            $ui.addStage();
            return $ui;
        };
        UIConatiner.prototype.addVirtualContainer = function ($con) {
            if (!this.virtualContainerList) {
                this.virtualContainerList = new Array;
            }
            $con.parent = this;
            this.virtualContainerList.push($con);
        };
        UIConatiner.prototype.removeVirtualContainer = function ($con) {
        };
        UIConatiner.prototype.addUIList = function ($ary, $uiRender) {
            var $arr = new Array();
            for (var i = 0; i < $ary.length; i++) {
                var ui = $uiRender.getComponent($ary[i]);
                this.addChild(ui);
                $arr.push(ui);
            }
            return $arr;
        };
        UIConatiner.prototype.getUIList = function ($ary, $uiRender) {
            var $arr = new Array();
            for (var i = 0; i < $ary.length; i++) {
                var ui = $uiRender.getComponent($ary[i]);
                $arr.push(ui);
            }
            return $arr;
        };
        /*
        *添加事件UI
        */
        UIConatiner.prototype.addEvntBut = function ($name, $uiRender) {
            var $temp = this.addChild($uiRender.getComponent($name));
            $temp.addEventListener(tl3d.InteractiveEvent.Down, this.butClik, this);
            return $temp;
        };
        UIConatiner.prototype.addEvntButUp = function ($name, $uiRender) {
            var $temp = this.addChild($uiRender.getComponent($name));
            $temp.addEventListener(tl3d.InteractiveEvent.Up, this.butClik, this);
            return $temp;
        };
        /*
        *移除事件UI
        */
        UIConatiner.prototype.removeEvntBut = function ($ui) {
            $ui.removeEventListener(tl3d.InteractiveEvent.Down, this.butClik, this);
            this.removeChild($ui);
        };
        UIConatiner.prototype.butClik = function (evt) {
        };
        /*
        *设置显示层的显示列表
        */
        UIConatiner.prototype.renderSetVisibel = function ($list, value) {
            for (var i = 0; i < $list.length; i++) {
                if (value) {
                    if (!$list[i].rendering) {
                        this.addRender($list[i]);
                    }
                }
                else {
                    if ($list[i].rendering) {
                        this.removeRender($list[i]);
                    }
                }
            }
        };
        UIConatiner.prototype.removeChild = function ($ui) {
            var index = this._list.indexOf($ui);
            if (index != -1) {
                this._list.splice(index, 1);
            }
            else {
                return;
            }
            $ui.parent = null;
            $ui.removeStage();
        };
        UIConatiner.prototype.removeAll = function () {
            while (this._list.length) {
                this.removeChild(this._list[0]);
            }
            while (this._maskList.length) {
                this.removeMaks(this._maskList[0]);
            }
        };
        UIConatiner.prototype.addMask = function ($mask) {
            if (!this._maskList) {
                this._maskList = new Array;
            }
            $mask.parent = this;
            $mask.applyAbsolutePoint();
            this._maskList.push($mask);
        };
        UIConatiner.prototype.removeMaks = function ($mask) {
            if (this._maskList) {
                var index = this._maskList.indexOf($mask);
                if (index != -1) {
                    this._maskList.splice(index, 1);
                }
            }
        };
        UIConatiner.prototype.addRender = function ($uiRender) {
            var index = this.renderList.indexOf($uiRender);
            if (index != -1) {
                return;
            }
            $uiRender.container = this;
            $uiRender.sortnum = this._layer;
            this.renderList.push($uiRender);
            if (this.hasStage) {
                tl3d.UIManager.getInstance().addUI($uiRender);
            }
        };
        UIConatiner.prototype.addRenderAt = function ($uiRender, $idx) {
            var index = this.renderList.indexOf($uiRender);
            if (index != -1) {
                return;
            }
            $uiRender.container = this;
            $uiRender.sortnum = this._layer;
            this.renderList.splice($idx, 0, $uiRender);
            if (this.hasStage) {
                tl3d.UIManager.getInstance().addUI($uiRender);
            }
        };
        UIConatiner.prototype.removeRender = function ($uiRender) {
            var index = this.renderList.indexOf($uiRender);
            if (index != -1) {
                this.renderList.splice(index, 1);
            }
            else {
                return;
            }
            if (this.hasStage) {
                tl3d.UIManager.getInstance().removeUI($uiRender);
            }
        };
        UIConatiner.prototype.resize = function () {
            if (this._xType == 0) {
                this._x = this._left * tl3d.UIData.Scale;
            }
            else if (this._xType == 1) {
                this._x = tl3d.Scene_data.stageWidth - this._right * tl3d.UIData.Scale - this.width * tl3d.UIData.Scale;
            }
            else if (this._xType == 2) {
                this._x = this._center * tl3d.UIData.Scale + tl3d.Scene_data.stageWidth / 2 - this.width * tl3d.UIData.Scale / 2;
            }
            if (this._yType == 0) {
                this._y = this._top * tl3d.UIData.Scale;
            }
            else if (this._yType == 1) {
                this._y = tl3d.Scene_data.stageHeight - this._bottom * tl3d.UIData.Scale - this.height * tl3d.UIData.Scale;
            }
            else if (this._yType == 2) {
                this._y = this._middle * tl3d.UIData.Scale + tl3d.Scene_data.stageHeight / 2 - this.height * tl3d.UIData.Scale / 2;
            }
            this.applyChild();
            this.resizeVirtualList();
        };
        UIConatiner.prototype.resizeVirtualList = function () {
            if (!this.virtualContainerList) {
                return;
            }
            for (var i = 0; i < this.virtualContainerList.length; i++) {
                this.virtualContainerList[i].resize();
            }
        };
        Object.defineProperty(UIConatiner.prototype, "left", {
            get: function () {
                return this._left;
            },
            set: function (value) {
                this._left = value;
                this._xType = 0;
                this._x = this._left * tl3d.UIData.Scale;
                this.applyChild();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIConatiner.prototype, "right", {
            get: function () {
                return this._right;
            },
            set: function (value) {
                this._right = value;
                this._xType = 1;
                this._x = tl3d.Scene_data.stageWidth - this._right * tl3d.UIData.Scale - this.width * tl3d.UIData.Scale;
                this.applyChild();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIConatiner.prototype, "center", {
            set: function (value) {
                this._center = value;
                this._xType = 2;
                this._x = this._center * tl3d.UIData.Scale + tl3d.Scene_data.stageWidth / 2 - this.width * tl3d.UIData.Scale / 2;
                this.applyChild();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIConatiner.prototype, "top", {
            get: function () {
                return this._top;
            },
            set: function (value) {
                this._top = value;
                this._yType = 0;
                this._y = this._top * tl3d.UIData.Scale;
                this.applyChild();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIConatiner.prototype, "bottom", {
            get: function () {
                return this._bottom;
            },
            set: function (value) {
                this._bottom = value;
                this._yType = 1;
                this._y = tl3d.Scene_data.stageHeight - this._bottom * tl3d.UIData.Scale - this.height * tl3d.UIData.Scale;
                this.applyChild();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIConatiner.prototype, "middle", {
            set: function (value) {
                this._middle = value;
                this._yType = 2;
                this._y = this._middle * tl3d.UIData.Scale + tl3d.Scene_data.stageHeight / 2 - this.height * tl3d.UIData.Scale / 2;
                this.applyChild();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIConatiner.prototype, "width", {
            get: function () {
                if (this._width != 0) {
                    return this._width;
                }
                var num = 0;
                for (var i = 0; i < this._list.length; i++) {
                    num = Math.max(this._list[i].width);
                }
                return num;
            },
            set: function (value) {
                this._width = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIConatiner.prototype, "height", {
            get: function () {
                if (this._height != 0) {
                    return this._height;
                }
                var num = 0;
                for (var i = 0; i < this._list.length; i++) {
                    num = Math.max(this._list[i].height);
                }
                return num;
            },
            set: function (value) {
                this._height = value;
            },
            enumerable: true,
            configurable: true
        });
        UIConatiner.prototype.applyChild = function () {
            for (var i = 0; i < this._list.length; i++) {
                this._list[i].applyAbsolutePoint();
            }
            if (this._maskList) {
                for (var i = 0; i < this._maskList.length; i++) {
                    this._maskList[i].applyAbsolutePoint();
                }
            }
        };
        Object.defineProperty(UIConatiner.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIConatiner.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
            },
            enumerable: true,
            configurable: true
        });
        UIConatiner.prototype.dispose = function () {
            //console.log("忘了重写disposepanel");
        };
        UIConatiner.prototype.setSizeForPanelUiCopy = function ($ui, $uiName, $uiRender) {
            var temp = $uiRender.getComponent($uiName);
            $ui.x = temp.x;
            $ui.y = temp.y;
            $ui.width = temp.width;
            $ui.height = temp.height;
        };
        return UIConatiner;
    }());
    tl3d.UIConatiner = UIConatiner;
    var Dis2DUIContianerBase = /** @class */ (function (_super) {
        __extends(Dis2DUIContianerBase, _super);
        function Dis2DUIContianerBase() {
            return _super.call(this) || this;
        }
        Dis2DUIContianerBase.prototype.update = function (t) {
        };
        Dis2DUIContianerBase.prototype.clearOneTemp = function () {
        };
        return Dis2DUIContianerBase;
    }(UIConatiner));
    tl3d.Dis2DUIContianerBase = Dis2DUIContianerBase;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MainUiLoad = /** @class */ (function () {
        function MainUiLoad() {
        }
        MainUiLoad.init = function ($res, $bfun, $loadFun) {
            if ($loadFun === void 0) { $loadFun = null; }
            this._itemLoad = $res; //初始化资源内容
            this._bFun = $bfun;
            this.loadFun = $loadFun;
            this.loadBaseConfigCom();
            return $res.length;
        };
        MainUiLoad.loadBaseConfigCom = function () {
            for (var i = 0; i < this._itemLoad.length; i++) {
                this.loadUIdata(this._itemLoad[i].xmlurl, this._itemLoad[i].picurl, this._itemLoad[i].name, Boolean(this._itemLoad[i].isTexture));
            }
        };
        MainUiLoad.loadOkNum = function ($num) {
            if (this.loadFun) {
                this.loadFun($num);
            }
        };
        MainUiLoad.loadUIdata = function ($xmlUrl, $imgUrl, $key, $isTexture) {
            var _this = this;
            if ($key === void 0) { $key = "default"; }
            if ($isTexture === void 0) { $isTexture = false; }
            if (!$isTexture) {
                var kim = new Image();
                this._imgDic[$key] = kim;
                kim.onload = function (evt) {
                    _this.loadOkd();
                };
            }
            tl3d.LoadManager.getInstance().load(tl3d.Scene_data.fileRoot + $xmlUrl, tl3d.LoadManager.XML_TYPE, function ($data) {
                var $arr = Array(JSON.parse($data))[0];
                _this._dic[$key] = $arr;
                if ($isTexture) {
                    tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + $imgUrl, function ($texture) {
                        _this._imgDic[$key] = $texture;
                        _this.loadOkd();
                    }, 1, null, 0);
                }
                else {
                    kim.src = tl3d.Scene_data.fileRoot + $imgUrl;
                }
            });
        };
        MainUiLoad.loadOkd = function () {
            this._skipnum++;
            this.loadOkNum(this._skipnum);
            if (this._skipnum >= this._itemLoad.length) {
                this._bFun();
            }
        };
        MainUiLoad._skipnum = 0;
        MainUiLoad._dic = new tl3d.Dictionary([]);
        MainUiLoad._imgDic = new tl3d.Dictionary([]);
        return MainUiLoad;
    }());
    tl3d.MainUiLoad = MainUiLoad;
    var UIData = /** @class */ (function () {
        function UIData() {
        }
        UIData.setDesignWH = function ($width, $height) {
            this.designWidth = $width;
            this.designHeight = $height;
            //  this.Scale = Math.min(Scene_data.stageWidth / $width, Scene_data.stageHeight / $height);
            this.resize();
        };
        UIData.resize = function () {
            // console.log("666");
            this.Scale = Math.min(tl3d.Scene_data.stageWidth / this.designWidth, tl3d.Scene_data.stageHeight / this.designHeight);
        };
        UIData.init = function ($res, $bfun, $loadFun) {
            if ($loadFun === void 0) { $loadFun = null; }
            this._itemLoad = $res; //初始化资源内容
            this._bFun = $bfun;
            this.loadFun = $loadFun;
            this.loadBaseConfigCom();
            return $res.length;
        };
        Object.defineProperty(UIData, "mainUIAtlas", {
            get: function () {
                return null;
            },
            enumerable: true,
            configurable: true
        });
        UIData.loadBaseConfigCom = function () {
            for (var i = 0; i < this._itemLoad.length; i++) {
                this.loadUIdata(this._itemLoad[i].xmlurl, this._itemLoad[i].picurl, this._itemLoad[i].name, Boolean(this._itemLoad[i].isTexture));
            }
        };
        UIData.loadOkNum = function ($num) {
            if (this.loadFun) {
                this.loadFun($num);
            }
        };
        UIData.loadUIdata = function ($xmlUrl, $imgUrl, $key, $isTexture) {
            var _this = this;
            if ($key === void 0) { $key = "default"; }
            if ($isTexture === void 0) { $isTexture = false; }
            if (!$isTexture) {
                var kim = new Image();
                this._imgDic[$key] = kim;
                kim.onload = function (evt) {
                    _this.loadOkd();
                };
            }
            tl3d.LoadManager.getInstance().load(tl3d.Scene_data.fileRoot + $xmlUrl, tl3d.LoadManager.XML_TYPE, function ($data) {
                var $arr = Array(JSON.parse($data))[0];
                _this._dic[$key] = $arr;
                if ($isTexture) {
                    tl3d.TextureManager.getInstance().getTexture(tl3d.Scene_data.fileRoot + $imgUrl, function ($texture) {
                        _this._imgDic[$key] = $texture;
                        _this.loadOkd();
                    }, 1, null, 0);
                }
                else {
                    kim.src = tl3d.Scene_data.fileRoot + $imgUrl;
                }
            });
        };
        UIData.loadOkd = function () {
            this._skipnum++;
            this.loadOkNum(this._skipnum);
            if (this._skipnum >= this._itemLoad.length) {
                UIData.textImg = this._imgDic[UIData.flytext]; //将指定图片给
                this._bFun();
            }
        };
        UIData.getImgByKey = function ($key) {
            if (this._imgDic.containsKey($key)) {
                return this._imgDic[$key];
            }
            //console.log("uiData getImgByKey=>" + $key)
            return null;
        };
        UIData.getUiByName = function ($key, $name) {
            if (this._dic.containsKey($key)) {
                var uiArr = this._dic[$key].uiArr;
                for (var i = 0; i < uiArr.length; i++) {
                    if (uiArr[i].name == $name) {
                        return uiArr[i];
                    }
                }
            }
            //console.log("uiData getUiByName =>" + $name)
            return null;
        };
        UIData.getUiArrByKey = function ($key) {
            if (this._dic.containsKey($key)) {
                return this._dic[$key].uiArr;
            }
            return null;
        };
        //设计宽高
        UIData.designWidth = 960;
        UIData.designHeight = 540;
        UIData.font = "Helvetica"; //Georgia
        UIData._skipnum = 0;
        // static textlist: string = "textlist";
        UIData.publicUi = "publicUi";
        UIData.flytext = "flytext";
        UIData.publicsUi = "publicsUi";
        UIData.faceItem = ["/大笑", "/脸2", "/脸3", "/脸4", "/脸5", "/脸6", "/脸7", "/脸8", "/脸9", "/脸a", "/脸b", "/脸c", "/脸d", "/脸e", "/脸f", "/脸g", "/脸h", "/脸i"];
        UIData._dic = new tl3d.Dictionary([]);
        UIData._imgDic = new tl3d.Dictionary([]);
        return UIData;
    }());
    tl3d.UIData = UIData;
    var UiDraw = /** @class */ (function () {
        function UiDraw() {
        }
        UiDraw.drawUseImg = function ($ui, $useImgAtlas, $skinName) {
            var $rec = $ui.uiRender.uiAtlas.getRec($ui.skinName);
            var ctx = tl3d.UIManager.getInstance().getContext2D($rec.pixelWitdh, $rec.pixelHeight, false);
            var useRec = $useImgAtlas.getRec($skinName);
            ctx.drawImage($useImgAtlas.useImg, useRec.pixelX, useRec.pixelY, useRec.pixelWitdh, useRec.pixelHeight, 0, 0, $rec.pixelWitdh, $rec.pixelHeight);
            $ui.uiRender.uiAtlas.updateCtx(ctx, $rec.pixelX, $rec.pixelY);
        };
        UiDraw.clearUI = function ($ui) {
            var $uiRect = $ui.uiRender.uiAtlas.getRec($ui.skinName);
            var $ctx = tl3d.UIManager.getInstance().getContext2D($uiRect.pixelWitdh, $uiRect.pixelHeight, false);
            $ui.uiRender.uiAtlas.updateCtx($ctx, $uiRect.pixelX, $uiRect.pixelY);
        };
        // static drawTxtLab($ui: UICompenent, $str: string, $fontsize: number, $align: string, $tx: number = 0, $ty: number = 3): void {
        //     var $rec: UIRectangle = $ui.uiRender.uiAtlas.getRec($ui.skinName);
        //     var ctx: CanvasRenderingContext2D = UIManager.getInstance().getContext2D($rec.pixelWitdh, $rec.pixelHeight, false);
        //     UiDraw.cxtDrawImg(ctx, PuiData.TXTBG, new Rectangle(0, 0, $rec.pixelWitdh, $rec.pixelHeight), UIData.publicUi);
        //     LabelTextFont.writeSingleLabelToCtx(ctx, $str, $fontsize, $tx, $ty, $align);
        //     $ui.uiRender.uiAtlas.updateCtx(ctx, $rec.pixelX, $rec.pixelY);
        // }
        /**属性 - value */
        UiDraw.drawAttVal = function ($ui, $att, $val, $align, $needadd) {
            if ($align === void 0) { $align = tl3d.TextAlign.LEFT; }
            if ($needadd === void 0) { $needadd = false; }
            var keyStr = "";
            if (typeof ($att) == "undefined") {
                UiDraw.clearUI($ui);
                return;
            }
            keyStr = tl3d.ColorType.Orange7a2f21 + tl3d.UnitFunction.getKeyProById($att) + ":  " + tl3d.ColorType.Orange9a683f + tl3d.UnitFunction.Snum(Math.floor($val / 100));
            if ($needadd) {
                keyStr = tl3d.ColorType.Orange7a2f21 + tl3d.UnitFunction.getKeyProById($att) + ":  " + tl3d.ColorType.Orange9a683f + "+" + tl3d.UnitFunction.Snum(Math.floor($val / 100));
            }
            tl3d.LabelTextFont.writeSingleLabel($ui.uiRender.uiAtlas, $ui.skinName, keyStr, 14, $align);
        };
        /**绘制未获得属性 - value */
        UiDraw.drawAttValAdd = function ($ui, $att, $val) {
            var keyStr = "";
            if (typeof ($att) == "undefined") {
                UiDraw.clearUI($ui);
                return;
            }
            keyStr = tl3d.ColorType.Orange7a2f21 + tl3d.UnitFunction.getKeyProById($att) + ":    " + tl3d.ColorType.Green2ca937 + "+" + tl3d.UnitFunction.Snum(Math.floor($val / 100));
            tl3d.LabelTextFont.writeSingleLabel($ui.uiRender.uiAtlas, $ui.skinName, keyStr, 14, tl3d.TextAlign.LEFT);
        };
        /**绘制增加属性 向上箭头 */
        // static drawAddValTop($ui: UICompenent, $val: number): void {
        //     var addStr: string = "";
        //     if ($val > 0) {
        //         addStr = "+" + Snum(Math.floor($val / 100));
        //     } else {
        //         addStr = "+0";
        //     }
        //     var $rec: UIRectangle = $ui.uiRender.uiAtlas.getRec($ui.skinName);
        //     var ctx: CanvasRenderingContext2D = UIManager.getInstance().getContext2D($rec.pixelWitdh, $rec.pixelHeight, false);
        //     if (addStr != "") {
        //         UiDraw.cxtDrawImg(ctx, PuiData.ARROW_TOP, new Rectangle(0, 3, 12, 16), UIData.publicUi);
        //     }
        //     LabelTextFont.writeSingleLabelToCtx(ctx, addStr, 14, 15, 0, TextAlign.LEFT, ColorType.Green2ca937);
        //     $ui.uiRender.uiAtlas.updateCtx(ctx, $rec.pixelX, $rec.pixelY);
        // }
        /**绘制增加属性 向右箭头 $align只接受左右对齐*/
        // static drawAddValRight($ui: UICompenent, $val: number, $needadd: boolean = false, $align: string = TextAlign.RIGHT): void {
        //     // var addStr: string = "";
        //     if ($val >= 0) {
        //         // addStr = Snum($val);
        //         var $rec: UIRectangle = $ui.uiRender.uiAtlas.getRec($ui.skinName);
        //         var ctx: CanvasRenderingContext2D = UIManager.getInstance().getContext2D($rec.pixelWitdh, $rec.pixelHeight, false);
        //         UiDraw.cxtDrawImg(ctx, PuiData.ARROW_RIGHT, new Rectangle(0, 3, 16, 12), UIData.publicUi);
        //         var addStr: string = Snum(Math.floor($val / 100));
        //         if ($needadd) {
        //             addStr = "+" + addStr;
        //         }
        //         var tx: number = 0;
        //         if ($align == TextAlign.LEFT) {
        //             tx = 22;
        //         }
        //         //console.log("-----addStr----",addStr,tx);
        //         LabelTextFont.writeSingleLabelToCtx(ctx, addStr, 14, tx, 0, $align, ColorType.Green2ca937);
        //         $ui.uiRender.uiAtlas.updateCtx(ctx, $rec.pixelX, $rec.pixelY);
        //     } else {
        //         UiDraw.clearUI($ui);
        //     }
        // }
        /**
         * 绘制需 自身有某id的道具多少个和需要多少数量的道具  a/b
         * @param
         * @param
         * @param
         */
        UiDraw.drawResHasNumAndAllNum = function ($ui, $CostAry, $txt) {
            if ($txt === void 0) { $txt = ""; }
            var costnum;
            var flag;
            return false;
        };
        /**
         * 在ctx上指定位置绘制一个小图标
         * @param
         * @param
         */
        // static drawCost($cxt: CanvasRenderingContext2D, $tx: number, $ty: number, $type: number): void {
        //     UiDraw.cxtDrawImg($cxt, UIuitl.getInstance().costtype($type), new Rectangle($tx, $ty, 35, 35), UIData.publicUi);
        // }
        // static drawCostUI($ui: UICompenent, $tx: number, $ty: number, $type: number): void {
        //     var $goldtxtrec: UIRectangle = $ui.uiRender.uiAtlas.getRec($ui.skinName);
        //     var $ctx: CanvasRenderingContext2D = UIManager.getInstance().getContext2D($goldtxtrec.pixelWitdh, $goldtxtrec.pixelHeight, false);
        //     UiDraw.cxtDrawImg($ctx, UIuitl.getInstance().costtype($type), new Rectangle($tx, $ty, 35, 35), UIData.publicUi);
        //     $ui.uiRender.uiAtlas.updateCtx($ctx, $goldtxtrec.pixelX, $goldtxtrec.pixelY);
        // }
        //将目标的图绘制到CXT对象中，
        UiDraw.cxtDrawImg = function ($cxt, $name, $rect, $key) {
            var obj = UIData.getUiByName($key, $name);
            if (obj) {
                if ($rect.width == 0 || $rect.height == 0) {
                    $rect.width = obj.ow;
                    $rect.height = obj.oh;
                }
                if (obj.type == 0) {
                    $cxt.drawImage(UIData.getImgByKey($key), obj.ox, obj.oy, obj.ow, obj.oh, $rect.x, $rect.y, $rect.width, $rect.height);
                }
                else if (obj.type == 1) {
                    $cxt.drawImage(UIData.getImgByKey($key), obj.ox, obj.oy, obj.uow, obj.uoh, $rect.x, $rect.y, obj.uow, obj.uoh);
                    $cxt.drawImage(UIData.getImgByKey($key), obj.ox + obj.uow, obj.oy, obj.ow - obj.uow * 2, obj.uoh, $rect.x + obj.uow, $rect.y, $rect.width - obj.uow * 2, obj.uoh);
                    $cxt.drawImage(UIData.getImgByKey($key), obj.ox + obj.ow - obj.uow, obj.oy, obj.uow, obj.uoh, $rect.x + $rect.width - obj.uow, $rect.y, obj.uow, obj.uoh);
                    $cxt.drawImage(UIData.getImgByKey($key), obj.ox, obj.oy + obj.uoh, obj.uow, obj.oh - obj.uoh * 2, $rect.x, $rect.y + obj.uoh, obj.uow, $rect.height - obj.uoh * 2);
                    $cxt.drawImage(UIData.getImgByKey($key), obj.ox + obj.uow, obj.oy + obj.uoh, obj.ow - obj.uow * 2, obj.oh - obj.uoh * 2, $rect.x + obj.uow, $rect.y + obj.uoh, $rect.width - obj.uow * 2, $rect.height - obj.uoh * 2);
                    $cxt.drawImage(UIData.getImgByKey($key), obj.ox + obj.ow - obj.uow, obj.oy + obj.uoh, obj.uow, obj.uoh, $rect.x + $rect.width - obj.uow, $rect.y + obj.uoh, obj.uow, $rect.height - obj.uoh * 2);
                    $cxt.drawImage(UIData.getImgByKey($key), obj.ox, obj.oy + obj.oh - obj.uoh, obj.uow, obj.uoh, $rect.x, $rect.y + $rect.height - obj.uoh, obj.uow, obj.uoh);
                    $cxt.drawImage(UIData.getImgByKey($key), obj.ox + obj.uow, obj.oy + obj.oh - obj.uoh, obj.ow - obj.uow * 2, obj.uoh, $rect.x + obj.uow, $rect.y + $rect.height - obj.uoh, $rect.width - obj.uow * 2, obj.uoh);
                    $cxt.drawImage(UIData.getImgByKey($key), obj.ox + obj.ow - obj.uow, obj.oy + obj.oh - obj.uoh, obj.uow, obj.uoh, $rect.x + $rect.width - obj.uow, $rect.y + $rect.height - obj.uoh, obj.uow, obj.uoh);
                }
                else {
                    alert("UiDraw没有绘制成功  " + obj.type);
                }
            }
        };
        //将目标的图绘制到$uiAtlas纹理对象中，
        UiDraw.uiAtlasDrawImg = function ($uiAtlas, $skinName, $key, $shareName) {
            var $uiRectangle = $uiAtlas.getRec($skinName);
            $uiAtlas.ctx = tl3d.UIManager.getInstance().getContext2D($uiRectangle.pixelWitdh, $uiRectangle.pixelHeight, false);
            var obj = UIData.getUiByName($key, $shareName);
            ////console.log("obj", obj)
            if (obj) {
                if (obj.type == 0) {
                    $uiAtlas.ctx.drawImage(UIData.getImgByKey($key), obj.ox, obj.oy, obj.ow, obj.oh, 0, 0, $uiRectangle.pixelWitdh, $uiRectangle.pixelHeight);
                }
                else if (obj.type == 1) {
                    $uiAtlas.ctx.drawImage(UIData.getImgByKey($key), obj.ox, obj.oy, obj.uow, obj.uoh, 0, 0, obj.uow, obj.uoh);
                    $uiAtlas.ctx.drawImage(UIData.getImgByKey($key), obj.ox + obj.uow, obj.oy, obj.ow - obj.uow * 2, obj.uoh, obj.uow, 0, $uiRectangle.pixelWitdh - obj.uow * 2, obj.uoh);
                    $uiAtlas.ctx.drawImage(UIData.getImgByKey($key), obj.ox + obj.ow - obj.uow, obj.oy, obj.uow, obj.uoh, $uiRectangle.pixelWitdh - obj.uow, 0, obj.uow, obj.uoh);
                    $uiAtlas.ctx.drawImage(UIData.getImgByKey($key), obj.ox, obj.oy + obj.uoh, obj.uow, obj.oh - obj.uoh * 2, 0, obj.uoh, obj.uow, $uiRectangle.pixelHeight - obj.uoh * 2);
                    $uiAtlas.ctx.drawImage(UIData.getImgByKey($key), obj.ox + obj.uow, obj.oy + obj.uoh, obj.ow - obj.uow * 2, obj.oh - obj.uoh * 2, obj.uow, obj.uoh, $uiRectangle.pixelWitdh - obj.uow * 2, $uiRectangle.pixelHeight - obj.uoh * 2);
                    $uiAtlas.ctx.drawImage(UIData.getImgByKey($key), obj.ox + obj.ow - obj.uow, obj.oy + obj.uoh, obj.uow, obj.uoh, $uiRectangle.pixelWitdh - obj.uow, obj.uoh, obj.uow, $uiRectangle.pixelHeight - obj.uoh * 2);
                    $uiAtlas.ctx.drawImage(UIData.getImgByKey($key), obj.ox, obj.oy + obj.oh - obj.uoh, obj.uow, obj.uoh, 0, $uiRectangle.pixelHeight - obj.uoh, obj.uow, obj.uoh);
                    $uiAtlas.ctx.drawImage(UIData.getImgByKey($key), obj.ox + obj.uow, obj.oy + obj.oh - obj.uoh, obj.ow - obj.uow * 2, obj.uoh, obj.uow, $uiRectangle.pixelHeight - obj.uoh, $uiRectangle.pixelWitdh - obj.uow * 2, obj.uoh);
                    $uiAtlas.ctx.drawImage(UIData.getImgByKey($key), obj.ox + obj.ow - obj.uow, obj.oy + obj.oh - obj.uoh, obj.uow, obj.uoh, $uiRectangle.pixelWitdh - obj.uow, $uiRectangle.pixelHeight - obj.uoh, obj.uow, obj.uoh);
                }
                else {
                    //console.log("11");
                }
                tl3d.TextureManager.getInstance().updateTexture($uiAtlas.texture, $uiRectangle.pixelX, $uiRectangle.pixelY, $uiAtlas.ctx);
            }
            else {
                alert("uiAtlasDrawImg错误");
            }
        };
        /**
         * 将共享资源图绘制到$uiAtlas纹理对象中
         * $touiAtlas：绘制到的uiAtlas对象
         * $fromuiAtlas: 资源来源的uiAtlas对象
         * $skinName: 绘制对象名
         * $shareName：资源名
         * $tx：偏移量x
         * $ty：偏移量y
         * $fillflag：是否填充整个对象，若填充，则考虑偏移量，否则反之
         */
        UiDraw.SharedDrawImg = function ($touiAtlas, $fromuiAtlas, $skinName, $shareName, $tx, $ty, $fillflag) {
            if ($tx === void 0) { $tx = 0; }
            if ($ty === void 0) { $ty = 0; }
            if ($fillflag === void 0) { $fillflag = true; }
            var $uiRectangle = $touiAtlas.getRec($skinName);
            $touiAtlas.ctx = tl3d.UIManager.getInstance().getContext2D($uiRectangle.pixelWitdh, $uiRectangle.pixelHeight, false);
            var imgUseRect = $fromuiAtlas.getRec($shareName);
            var posx = $fillflag ? 0 : $tx;
            var posy = $fillflag ? 0 : $ty;
            var pwitdh = $fillflag ? $uiRectangle.pixelWitdh : imgUseRect.pixelWitdh;
            var phight = $fillflag ? $uiRectangle.pixelHeight : imgUseRect.pixelHeight;
            $touiAtlas.ctx.drawImage($fromuiAtlas.useImg, imgUseRect.pixelX, imgUseRect.pixelY, imgUseRect.pixelWitdh, imgUseRect.pixelHeight, posx, posy, pwitdh, phight);
            tl3d.TextureManager.getInstance().updateTexture($touiAtlas.texture, $uiRectangle.pixelX, $uiRectangle.pixelY, $touiAtlas.ctx);
        };
        UiDraw.drawToUiAtlasToCtx = function ($ctx, $fromuiAtlas, $shareName, $posRect) {
            var imgUseRect = $fromuiAtlas.getRec($shareName);
            if (!$posRect) {
                $posRect = new tl3d.Rectangle(0, 0, 0, 0);
            }
            if ($posRect.width > 1 && $posRect.height > 1) {
                $ctx.drawImage($fromuiAtlas.useImg, imgUseRect.pixelX, imgUseRect.pixelY, imgUseRect.pixelWitdh, imgUseRect.pixelHeight, $posRect.x, $posRect.y, $posRect.width, $posRect.height);
            }
            else {
                $ctx.drawImage($fromuiAtlas.useImg, imgUseRect.pixelX, imgUseRect.pixelY, imgUseRect.pixelWitdh, imgUseRect.pixelHeight, $posRect.x, $posRect.y, imgUseRect.pixelWitdh, imgUseRect.pixelHeight);
            }
        };
        UiDraw.RepeatLoadImg = function ($url1, $url2, $backFuc) {
            if ($backFuc === void 0) { $backFuc = null; }
            var imgA = new Image();
            imgA.onload = function () {
                tl3d.LoadManager.getInstance().load($url2, tl3d.LoadManager.IMG_TYPE, function ($imgB) {
                    if ($backFuc) {
                        $backFuc(imgA, $imgB);
                    }
                });
            };
            imgA.src = $url1;
        };
        return UiDraw;
    }());
    tl3d.UiDraw = UiDraw;
    var UIuitl = /** @class */ (function () {
        function UIuitl() {
        }
        UIuitl.getInstance = function () {
            if (!this._instance) {
                this._instance = new UIuitl();
            }
            return this._instance;
        };
        /**
         * 绘制背景图+资源icon+资源数目
         */
        // public drawCostUI($uiAtlas: UIAtlas, $skinName: string, $costary: Array<any>, $fontcolor: string = "#000000", $bgwidth: number = 0, $bgheight: number = 0): void {
        //     if ($fontcolor.indexOf("[") != -1) {  //[00ff00]
        //         $fontcolor = "#" + $fontcolor.substr(1, 6);
        //     }
        //     var $rec: UIRectangle = $uiAtlas.getRec($skinName);
        //     var ctx: CanvasRenderingContext2D = UIManager.getInstance().getContext2D($rec.pixelWitdh, $rec.pixelHeight, false);
        //     if ($bgwidth == 0) {
        //         $bgwidth = $rec.pixelWitdh;
        //         $bgheight = $rec.pixelHeight;
        //     }
        //     UiDraw.cxtDrawImg(ctx, PuiData.TXTBG, new Rectangle($rec.pixelWitdh - $bgwidth, $rec.pixelHeight - $bgheight - 3, $bgwidth, $bgheight + 3), UIData.publicUi);
        //     var posx: number
        //     var posy: number
        //     if (Number($costary[0]) > -1) {
        //         UiDraw.cxtDrawImg(ctx, this.costtype(Number($costary[0])), new Rectangle(0, 0, 35, 35), UIData.publicUi);
        //         posx = ($bgwidth - 35) / 2 + 35;
        //         if ($bgheight >= 35) {
        //             posy = 2
        //         } else {
        //             posy = 35 - $bgheight
        //         }
        //     } else {
        //         posx = $bgwidth / 2 + ($rec.pixelWitdh - $bgwidth)
        //         posy = $rec.pixelHeight - $bgheight
        //     }
        //     LabelTextFont.writeSingleLabelToCtxSetAnchor(ctx, String($costary[1]), 16, posx, posy, TextAlign.CENTER, $fontcolor);
        //     ArtFont.getInstance()
        //     $uiAtlas.updateCtx(ctx, $rec.pixelX, $rec.pixelY);
        // }
        UIuitl.prototype.costtype = function ($costid) {
            switch ($costid) {
                case 1:
                    //元宝
                    return tl3d.PuiData.A_YUANBAO;
                case 2:
                    //绑定元宝
                    return tl3d.PuiData.A_BANGYUAN;
                case 3:
                    //身上的银子
                    return tl3d.PuiData.A_YINBI;
                case 101:
                    //真气
                    return tl3d.PuiData.A_ZHENQI;
                case 102:
                    //兽灵
                    return tl3d.PuiData.A_SHOULING;
                case 103:
                    //宝石精华
                    return tl3d.PuiData.A_JINGHUA;
                case 6:
                    //帮贡
                    return tl3d.PuiData.A_BANGGONG;
                case 7:
                    //荣誉
                    return tl3d.PuiData.A_HONOR;
                case 8:
                    //斗魂
                    return tl3d.PuiData.A_DOUHUN;
                case 9:
                    //历练值
                    return tl3d.PuiData.A_DOUHUN;
                case 10:
                    //怪物令牌
                    return tl3d.PuiData.A_CARD_G;
                case 11:
                    //采集令牌
                    return tl3d.PuiData.A_CARD_C;
                case 12:
                    //押镖令牌
                    return tl3d.PuiData.A_CARD_B;
                case 104:
                    //经验
                    return tl3d.PuiData.A_EXP;
                default:
                    break;
            }
        };
        return UIuitl;
    }());
    tl3d.UIuitl = UIuitl;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UIRectangle = /** @class */ (function (_super) {
        __extends(UIRectangle, _super);
        function UIRectangle() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.pixelWitdh = 1;
            _this.pixelHeight = 1;
            _this.pixelX = 0;
            _this.pixelY = 0;
            _this.cellX = 0;
            _this.cellY = 0;
            _this.type = 0;
            return _this;
        }
        return UIRectangle;
    }(tl3d.Rectangle));
    tl3d.UIRectangle = UIRectangle;
})(tl3d || (tl3d = {}));
/// <reference path="UIRectangle.ts" />

(function (tl3d) {
    var UIGridRentangle = /** @class */ (function (_super) {
        __extends(UIGridRentangle, _super);
        function UIGridRentangle() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.ogw = 0;
            _this.ogh = 0;
            return _this;
        }
        return UIGridRentangle;
    }(tl3d.UIRectangle));
    tl3d.UIGridRentangle = UIGridRentangle;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UIMask = /** @class */ (function () {
        function UIMask() {
            //设定相对坐标
            this._x = 0;
            this._y = 0;
            this._width = 0;
            this._height = 0;
            //设定绝对坐标
            this.absoluteX = 0;
            this.absoluteY = 0;
            this.absoluteWidth = 0;
            this.absoluteHeight = 0;
            this.scale = 1;
            this.level = 2;
            this._hasDisposed = false;
            this.initData();
            this.renderData = [0, 0, 0, 0];
        }
        UIMask.prototype.initData = function () {
            this.objData = new tl3d.ObjData();
            this.shader = tl3d.ProgrmaManager.getInstance().getProgram(tl3d.UIMaskShader.UI_MASK_SHADER);
            this.program = this.shader.program;
            this.applyObjData();
        };
        UIMask.prototype.applyAbsolutePoint = function () {
            if (this.parent) {
                this.absoluteX = this._x * this.scale * tl3d.UIData.Scale + this.parent.x;
                this.absoluteY = this._y * this.scale * tl3d.UIData.Scale + this.parent.y;
                this.absoluteWidth = this._width * tl3d.UIData.Scale * this.scale;
                this.absoluteHeight = this._height * tl3d.UIData.Scale * this.scale;
                this.applyRenderSize();
            }
        };
        UIMask.prototype.testPoint = function ($x, $y) {
            if ($x > this.absoluteX && $x < (this.absoluteX + this.absoluteWidth) && $y > this.absoluteY && $y < (this.absoluteY + this.absoluteHeight)) {
                return true;
            }
            else {
                return false;
            }
        };
        UIMask.prototype.applyRenderSize = function () {
            if (!this.parent) {
                return;
            }
            this.renderData[0] = this.absoluteX / tl3d.Scene_data.stageWidth;
            this.renderData[1] = this.absoluteY / tl3d.Scene_data.stageHeight;
            this.renderData[2] = this.absoluteWidth / tl3d.Scene_data.stageWidth;
            this.renderData[3] = this.absoluteHeight / tl3d.Scene_data.stageHeight;
        };
        UIMask.prototype.applyObjData = function () {
            this.objData.vertices.length = 0;
            this.objData.uvs.length = 0;
            this.objData.indexs.length = 0;
            this.objData.vertices.push(0, 0, 0, 1, 0, 0, 1, -1, 0, 0, -1, 0);
            this.objData.indexs.push(0, 1, 2, 0, 2, 3);
            this.objData.treNum = this.objData.indexs.length;
            this.objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.vertices);
            this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
        };
        UIMask.prototype.update = function () {
            tl3d.Scene_data.context3D.setBlendParticleFactors(0);
            tl3d.Scene_data.context3D.setProgram(this.program);
            //for (var i: number = 0; i < this._uiList.length; i++) {
            //    this._uiList[i].update();
            //    this._uiList[i].setVc(this.program, i);
            //}
            tl3d.Scene_data.context3D.setVc4fv(this.shader, "ui", this.renderData);
            tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
            tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
        };
        Object.defineProperty(UIMask.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIMask.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIMask.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (value) {
                this._width = value;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIMask.prototype, "height", {
            get: function () {
                return this._height;
            },
            set: function (value) {
                this._height = value;
                this.applyAbsolutePoint();
            },
            enumerable: true,
            configurable: true
        });
        UIMask.prototype.dispose = function () {
            if (this._hasDisposed) {
                return;
            }
            this.objData.destory();
            this.objData = null;
            this.program = null;
            this.shader = null;
            this.renderData = null;
            this.parent = null;
            this._hasDisposed = true;
        };
        return UIMask;
    }());
    tl3d.UIMask = UIMask;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var UIVirtualContainer = /** @class */ (function (_super) {
        __extends(UIVirtualContainer, _super);
        function UIVirtualContainer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.visible = true;
            return _this;
        }
        return UIVirtualContainer;
    }(tl3d.UIConatiner));
    tl3d.UIVirtualContainer = UIVirtualContainer;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var FrameCompenent = /** @class */ (function (_super) {
        __extends(FrameCompenent, _super);
        function FrameCompenent() {
            var _this = _super.call(this) || this;
            _this.isTrue = false;
            _this.current = 0;
            _this.totalcurrent = 0;
            _this.speed = 6;
            _this.endFlag = false;
            _this.stopStatic = 0;
            _this.speedNum = 0;
            return _this;
        }
        FrameCompenent.prototype.setFrameData = function ($rect) {
            this._frameData = $rect;
            this.totalcurrent = this._frameData.cellX * this._frameData.cellY;
        };
        FrameCompenent.prototype.applyRenderSize = function () {
            if (!this.parent) {
                return;
            }
            this.renderX = this.absoluteX / tl3d.Scene_data.stageWidth;
            this.renderY = this.absoluteY / tl3d.Scene_data.stageHeight;
            this.renderWidth = this.absoluteWidth / tl3d.Scene_data.stageWidth;
            this.renderHeight = this.absoluteHeight / tl3d.Scene_data.stageHeight;
            this.renderData[0] = this.renderX;
            this.renderData[1] = this.renderY;
            this.renderData[2] = this.renderWidth * this._uvScale;
            this.renderData[3] = this.renderHeight;
            var cellX = this._frameData.cellX;
            var cellY = this._frameData.cellY;
            var tw = (this._frameData.width / cellX);
            var th = (this._frameData.height / cellY);
            var rect = new tl3d.Rectangle(0, 0, tw, th);
            var tempNum = this.current % (cellX * cellY);
            rect.x = (tempNum % cellX * tw);
            rect.y = (tl3d.Util.float2int(tempNum / cellX) * th);
            this.renderData2[0] = rect.width * this._uvScale;
            this.renderData2[1] = rect.height;
            this.renderData2[2] = rect.x + this._frameData.x;
            this.renderData2[3] = rect.y + this._frameData.y;
            this.uiRender.makeRenderDataVc(this.vcId);
        };
        FrameCompenent.prototype.getSkinCtxRect = function () {
            var $uiRec = this._frameData;
            var $toRect = new tl3d.Rectangle;
            $toRect.width = $uiRec.pixelWitdh / $uiRec.cellX;
            $toRect.height = $uiRec.pixelHeight / $uiRec.cellY;
            $toRect.x = ((this.current) % $uiRec.cellX) * $toRect.width;
            $toRect.y = Math.floor((this.current) / $uiRec.cellX) * $toRect.height;
            return $toRect;
        };
        FrameCompenent.prototype.drawToCtx = function ($uiAtlas, $ctx) {
            var $uiRec = this._frameData;
            ;
            var $toRect = this.getSkinCtxRect();
            $uiAtlas.updateCtx($ctx, $uiRec.pixelX + $toRect.x, $uiRec.pixelY + $toRect.y);
        };
        FrameCompenent.prototype.update = function () {
            if (!this._frameData) {
                return;
            }
            if (this.stopStatic == 2) {
                return;
            }
            this.applyRenderSize();
            this.speedNum++;
            if (this.speedNum > this.speed) {
                this.current++;
                this.speedNum = 0;
            }
            var cellX = this._frameData.cellX;
            var cellY = this._frameData.cellY;
            if (this.current > (cellX * cellY - 1)) {
                if (this.stopStatic == 1) {
                    this.stopStatic = 2;
                    this.endFlag = true;
                }
                else {
                    this.current = 0;
                }
            }
        };
        FrameCompenent.prototype.goToAndPlay = function ($num) {
            this.stopStatic = 1;
            this.current = $num;
        };
        FrameCompenent.prototype.goToAndStop = function ($num) {
            this.stopEnd();
            this.current = $num;
            this.applyRenderSize();
        };
        FrameCompenent.prototype.Invisible = function () {
            if (this.renderData[2] != 0 && this.renderData[3] != 0) { //这里特殊规避重复设置 高宽不为0
                this.stopEnd();
                this.renderData[0] = 0;
                this.renderData[1] = 0;
                this.renderData[2] = 0;
                this.renderData[3] = 0;
                this.uiRender.makeRenderDataVc(this.vcId);
            }
        };
        FrameCompenent.prototype.play = function () {
            this.stopStatic = 0;
        };
        FrameCompenent.prototype.stopEnd = function () {
            this.stopStatic = 2;
            var cellX = this._frameData.cellX;
            var cellY = this._frameData.cellY;
            this.current = cellX * cellY - 1;
            this.applyRenderSize();
        };
        return FrameCompenent;
    }(tl3d.UICompenent));
    tl3d.FrameCompenent = FrameCompenent;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Grid9Compenent = /** @class */ (function (_super) {
        __extends(Grid9Compenent, _super);
        function Grid9Compenent() {
            return _super.call(this) || this;
        }
        Grid9Compenent.prototype.pushVaData = function (objData, i, beginIndex) {
            var vers = [
                0, 0, 0,
                this.ogw, 0, 0,
                this.width - this.ogw, 0, 0,
                this.width, 0, 0,
                0, -this.ogh, 0,
                this.ogw, -this.ogh, 0,
                this.width - this.ogw, -this.ogh, 0,
                this.width, -this.ogh, 0,
                0, this.ogh - this.height, 0,
                this.ogw, this.ogh - this.height, 0,
                this.width - this.ogw, this.ogh - this.height, 0,
                this.width, this.ogh - this.height, 0,
                0, -this.height, 0,
                this.ogw, -this.height, 0,
                this.width - this.ogw, -this.height, 0,
                this.width, -this.height, 0
            ];
            for (var j = 0; j < vers.length; j += 3) {
                objData.vertices.push(vers[j] / this.width, vers[j + 1] / this.height, vers[j + 2]);
            }
            //objData.vertices.push(
            //    0, 0, 0,
            //    this.gw, 0, 0,
            //    1 - this.gw, 0, 0,
            //    1, 0, 0,
            //    0, -this.gh, 0,
            //    this.gw, -this.gh, 0,
            //    1 - this.gw, -this.gh, 0,
            //    1, -this.gh, 0,
            //    0, this.gh - 1, 0,
            //    this.gw, this.gh - 1, 0,
            //    1 - this.gw, this.gh - 1, 0,
            //    1, this.gh - 1, 0,
            //    0, -1, 0,
            //    this.gw, -1, 0,
            //    1 - this.gw, -1, 0,
            //    1, -1, 0
            //    );
            objData.uvs.push(0, 0, i, this.gw, 0, i, 1 - this.gw, 0, i, 1, 0, i, 0, this.gh, i, this.gw, this.gh, i, 1 - this.gw, this.gh, i, 1, this.gh, i, 0, 1 - this.gh, i, this.gw, 1 - this.gh, i, 1 - this.gw, 1 - this.gh, i, 1, 1 - this.gh, i, 0, 1, i, this.gw, 1, i, 1 - this.gw, 1, i, 1, 1, i);
            var indexary = [
                0, 1, 5, 0, 5, 4,
                1, 2, 6, 1, 6, 5,
                2, 3, 7, 2, 7, 6,
                4, 5, 9, 4, 9, 8,
                5, 6, 10, 5, 10, 9,
                6, 7, 11, 6, 11, 10,
                8, 9, 13, 8, 13, 12,
                9, 10, 14, 9, 14, 13,
                10, 11, 15, 10, 15, 14
            ];
            for (var j = 0; j < indexary.length; j++) {
                objData.indexs.push(beginIndex + indexary[j]);
            }
            //objData.indexs.push(beginIndex, 1 + beginIndex, 2 + beginIndex, beginIndex, 2 + beginIndex, 3 + beginIndex);
            return beginIndex + 16;
        };
        return Grid9Compenent;
    }(tl3d.UICompenent));
    tl3d.Grid9Compenent = Grid9Compenent;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Disp2DBaseText = /** @class */ (function () {
        function Disp2DBaseText() {
            this.dtime = -1;
            this.time = 0;
            this.oldPos = new tl3d.Vector2D();
        }
        Disp2DBaseText.prototype.needUpData = function ($pos) {
            if (this.oldPos.x != $pos.x || this.oldPos.y != $pos.y || tl3d.Scene_data.cam3D.needChange) {
                this.oldPos.x = $pos.x;
                this.oldPos.y = $pos.y;
                return true;
            }
            return false;
        };
        Object.defineProperty(Disp2DBaseText.prototype, "data", {
            get: function () {
                return this._data;
            },
            set: function (value) {
                this._data = value;
                this.makeData();
                this.time = 0;
                this.update();
            },
            enumerable: true,
            configurable: true
        });
        Disp2DBaseText.prototype.makeData = function () {
        };
        Disp2DBaseText.prototype.update = function () {
        };
        //这需要优化矩阵不必要每次都更新
        Disp2DBaseText.prototype.Vector3DToVector2D = function ($pos) {
            var m = tl3d.Scene_data.cam3D.cameraMatrix.clone();
            m.append(tl3d.Scene_data.viewMatrx3D.clone());
            var p = m.transformVector($pos);
            var v2d = new tl3d.Vector2D();
            v2d.x = ((p.x / p.w) + 1) * (tl3d.Scene_data.stageWidth / 2) / tl3d.UIData.Scale - this.ui.width / 2;
            v2d.y = ((-p.y / p.w) + 1) * (tl3d.Scene_data.stageHeight / 2) / tl3d.UIData.Scale - this.ui.height / 2;
            return v2d;
        };
        Disp2DBaseText.prototype.isEqualLastKey = function (value) {
            return false;
        };
        return Disp2DBaseText;
    }());
    tl3d.Disp2DBaseText = Disp2DBaseText;
    //用于显示同屏2D容器，
    var Dis2DUIContianerPanel = /** @class */ (function (_super) {
        __extends(Dis2DUIContianerPanel, _super);
        function Dis2DUIContianerPanel($classVo, $rect, $num) {
            var _this = _super.call(this) || this;
            _this.width = tl3d.UIData.designWidth;
            _this.height = tl3d.UIData.designHeight;
            _this.creatBaseRender();
            _this.addRender(_this._baseRender);
            _this.initData($classVo, $rect, $num);
            return _this;
        }
        Dis2DUIContianerPanel.prototype.creatBaseRender = function () {
            this._baseRender = new tl3d.UIRenderComponent;
        };
        //显示单元类, 尺寸，数量
        Dis2DUIContianerPanel.prototype.initData = function ($classVo, $rect, $num) {
            this.voNum = Math.floor($num);
            this.voRect = $rect;
            this.textureRect = new tl3d.Rectangle(0, 0, Math.pow(2, Math.ceil(Math.log($rect.width) / Math.log(2))), Math.pow(2, Math.ceil(Math.log($rect.height * this.voNum) / Math.log(2))));
            this._baseRender.uiAtlas = new tl3d.UIAtlas();
            var $uiAtlas = this._baseRender.uiAtlas;
            $uiAtlas.configData = new Array();
            $uiAtlas.ctx = tl3d.UIManager.getInstance().getContext2D(this.textureRect.width, this.textureRect.height, false);
            $uiAtlas.textureRes = tl3d.TextureManager.getInstance().getCanvasTexture($uiAtlas.ctx);
            this.makeBaseUi($classVo);
        };
        //根据数量创建单元格UICompenent 并存在数组中，待需要时应用
        Dis2DUIContianerPanel.prototype.makeBaseUi = function ($classVo) {
            var $uiAtlas = this._baseRender.uiAtlas;
            this._uiItem = new Array();
            this._lostItem = new Array();
            for (var i = 0; i < this.voNum; i++) {
                var $disp2DBaseText = new $classVo();
                this._uiItem.push($disp2DBaseText);
                $disp2DBaseText.parent = this._baseRender;
                $disp2DBaseText.voRect = this.voRect;
                $disp2DBaseText.textureStr = "id" + i;
                $uiAtlas.configData.push($uiAtlas.getObject($disp2DBaseText.textureStr, 0, i * this.voRect.height, this.voRect.width, this.voRect.height, this.textureRect.width, this.textureRect.height));
                $disp2DBaseText.ui = this._baseRender.creatBaseComponent($disp2DBaseText.textureStr);
                $disp2DBaseText.ui.width *= 1.0;
                $disp2DBaseText.ui.height *= 1.0;
            }
        };
        //找到可用的单元 找到后赋值并添加ui到显示队列
        Dis2DUIContianerPanel.prototype.showTemp = function ($data) {
            this.clearLostItem();
            var empty;
            //找到上一个数据和现在是一样的对象.避免重复更新纹理
            for (var j = 0; j < this._uiItem.length; j++) {
                if (this._uiItem[j].data == null && this._uiItem[j].isEqualLastKey($data)) {
                    empty = this._uiItem[j];
                    break;
                }
            }
            if (!empty) {
                for (var i = 0; i < this._uiItem.length; i++) {
                    if (this._uiItem[i].data == null) {
                        empty = this._uiItem[i];
                        break;
                    }
                }
            }
            if (empty) {
                empty.data = $data;
                this.addChild(empty.ui);
            }
            else {
                this._lostItem.push($data);
            }
            return empty;
        };
        Dis2DUIContianerPanel.prototype.clearLostItem = function () {
            for (var i = (this._lostItem.length - 1); i > 0; i--) {
                if (this._lostItem[i].clear) {
                    this._lostItem.splice(i, 1);
                }
            }
        };
        Dis2DUIContianerPanel.prototype.playLost = function () {
            if (this._lostItem.length) {
                this.showTemp(this._lostItem.pop());
            }
        };
        Dis2DUIContianerPanel.prototype.clearOneTemp = function () {
            for (var i = 0; i < this._uiItem.length; i++) {
                if (!this._uiItem[i].data) {
                    return;
                }
            }
            this._lostItem.length = 0;
            this.clearTemp(this._uiItem[0].data);
        };
        //清理单元内的内容并需要将对象移出显示队例
        Dis2DUIContianerPanel.prototype.clearTemp = function ($data) {
            for (var i = 0; i < this._uiItem.length; i++) {
                if (this._uiItem[i].data == $data) {
                    this._uiItem[i].data = null;
                    this.removeChild(this._uiItem[i].ui);
                    break;
                }
            }
            this.playLost();
        };
        Dis2DUIContianerPanel.prototype.clearAll = function () {
            for (var i = 0; i < this._uiItem.length; i++) {
                if (this._uiItem[i].data) {
                    this.clearTemp(this._uiItem[i].data);
                }
            }
        };
        Dis2DUIContianerPanel.prototype.update = function (t) {
            for (var i = 0; i < this._uiItem.length; i++) {
                if (this._uiItem[i].data) {
                    this._uiItem[i].update();
                }
            }
            /*
            if (this.getUiItemLen() <( this._uiItem.length-1)) {
                this.playLost()
            }
            */
        };
        Dis2DUIContianerPanel.prototype.getUiItemLen = function () {
            var $num = 0;
            for (var i = 0; i < this._uiItem.length; i++) {
                if (this._uiItem[i].data) {
                    $num++;
                }
            }
            return $num;
        };
        return Dis2DUIContianerPanel;
    }(tl3d.Dis2DUIContianerBase));
    tl3d.Dis2DUIContianerPanel = Dis2DUIContianerPanel;
    var Dis2DUIFram = /** @class */ (function (_super) {
        __extends(Dis2DUIFram, _super);
        function Dis2DUIFram($classVo, $rect, $num) {
            return _super.call(this, $classVo, $rect, $num) || this;
        }
        //根据数量创建单元格UICompenent 并存在数组中，待需要时应用
        Dis2DUIFram.prototype.makeBaseUi = function ($classVo) {
            var $uiAtlas = this._baseRender.uiAtlas;
            this._uiItem = new Array();
            this._lostItem = new Array();
            for (var i = 0; i < this.voNum; i++) {
                var $disp2DBaseText = new $classVo();
                this._uiItem.push($disp2DBaseText);
                $disp2DBaseText.parent = this._baseRender;
                $disp2DBaseText.voRect = this.voRect;
                $disp2DBaseText.textureStr = "id" + i;
                $uiAtlas.configData.push($uiAtlas.getObject($disp2DBaseText.textureStr, 0, i * this.voRect.height, this.voRect.width, this.voRect.height, this.textureRect.width, this.textureRect.height));
                $disp2DBaseText.ui = this._baseRender.createFrame($disp2DBaseText.textureStr);
                $disp2DBaseText.ui.width *= 1.0;
                $disp2DBaseText.ui.height *= 1.0;
            }
        };
        return Dis2DUIFram;
    }(Dis2DUIContianerPanel));
    tl3d.Dis2DUIFram = Dis2DUIFram;
})(tl3d || (tl3d = {}));
/// <reference path="FrameCompenent.ts" />
/// <reference path="Grid9Compenent.ts" />
/// <reference path="Dis2DUIContianerPanel.ts" />

(function (tl3d) {
    var AlphaUIShader = /** @class */ (function (_super) {
        __extends(AlphaUIShader, _super);
        function AlphaUIShader() {
            return _super.call(this) || this;
        }
        AlphaUIShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Pos");
            $context.bindAttribLocation(this.program, 1, "v2uv");
        };
        AlphaUIShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Pos;" +
                "attribute vec3 v2uv;" +
                "uniform vec4 ui[40];" +
                "uniform vec4 ui2[40];" +
                "uniform float alpha[40];" +
                "varying vec2 v_texCoord;" +
                "varying float v_alpha;" +
                "void main(void)" +
                "{" +
                "   vec4 data = ui2[int(v2uv.z)];" +
                "   v_texCoord = vec2(v2uv.x * data.x + data.z, v2uv.y * data.y + data.w);" +
                "   v_alpha = alpha[int(v2uv.z)];" +
                "   data = ui[int(v2uv.z)];" +
                "   vec3 pos = vec3(0.0,0.0,0.0);" +
                "   pos.xy = v3Pos.xy * data.zw * 2.0;" +
                "   pos.x += data.x * 2.0 - 1.0;" +
                "   pos.y += -data.y * 2.0 + 1.0;" +
                "   vec4 vt0= vec4(pos, 1.0);" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        AlphaUIShader.prototype.getFragmentShaderString = function () {
            var $str = " precision mediump float;\n" +
                "uniform sampler2D s_texture;\n" +
                "varying vec2 v_texCoord;\n" +
                "varying float v_alpha;" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                "infoUv.xyz *= infoUv.w;\n" +
                "infoUv *=v_alpha;\n" +
                "gl_FragColor = infoUv;\n" +
                "}";
            return $str;
        };
        AlphaUIShader.AlphaUiShader = "AlphaUiShader";
        return AlphaUIShader;
    }(tl3d.Shader3D));
    tl3d.AlphaUIShader = AlphaUIShader;
    var AlphaUIRenderComponent = /** @class */ (function (_super) {
        __extends(AlphaUIRenderComponent, _super);
        function AlphaUIRenderComponent() {
            return _super.call(this) || this;
        }
        AlphaUIRenderComponent.prototype.update = function () {
            if (!this.visible || this._uiList.length == 0) {
                //  FpsMc.tipStr = "显示数:0";
                return;
            }
            tl3d.Scene_data.context3D.setBlendParticleFactors(0);
            tl3d.Scene_data.context3D.setProgram(this.program);
            for (var i = 0; i < this._uiList.length; i++) {
                this._uiList[i].update();
                this._uiList[i].setVc(this.shader, i);
            }
            //  FpsMc.tipStr = "显示数:" + (this._uiList.length)
            tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
            tl3d.Scene_data.context3D.setVa(1, 3, this.objData.uvBuffer);
            if (this.uiAtlas) {
                tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this.uiAtlas.texture, 0);
            }
            else {
                tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this.texture, 0);
            }
            tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
        };
        AlphaUIRenderComponent.prototype.initData = function () {
            this._uiList = new Array;
            this.objData = new tl3d.ObjData();
            tl3d.ProgrmaManager.getInstance().registe(AlphaUIShader.AlphaUiShader, new AlphaUIShader);
            this.shader = tl3d.ProgrmaManager.getInstance().getProgram(AlphaUIShader.AlphaUiShader);
            this.program = this.shader.program;
            this.uiProLocation = tl3d.Scene_data.context3D.getLocation(this.program, "ui");
            this.ui2ProLocation = tl3d.Scene_data.context3D.getLocation(this.program, "ui2");
            this.alphaLocation = tl3d.Scene_data.context3D.getLocation(this.program, "alpha");
        };
        AlphaUIRenderComponent.prototype.creatBaseComponent = function ($skinName) {
            var ui = new AlphaUICompenent();
            ui.skinName = $skinName;
            var rec = this.uiAtlas.getRec($skinName);
            ui.tr.setRec(rec);
            ui.width = rec.pixelWitdh;
            ui.height = rec.pixelHeight;
            ui.uiRender = this;
            return ui;
        };
        AlphaUIRenderComponent.prototype.creatGrid9Component = function ($skinName, $width, $height) {
            var ui = new AlphaGrid9UICompenent();
            ui.skinName = $skinName;
            var rec = this.uiAtlas.getGridRec($skinName);
            ui.tr.setRec(rec);
            ui.ogw = rec.ogw;
            ui.ogh = rec.ogh;
            ui.gw = ui.ogw / rec.pixelWitdh;
            ui.gh = ui.ogh / rec.pixelHeight;
            ui.width = $width;
            ui.height = $height;
            ui.uiRender = this;
            return ui;
        };
        AlphaUIRenderComponent.prototype.createFrame = function ($upskin) {
            var frameMc = new AlphaFrameCompenent;
            frameMc.skinName = $upskin;
            var rec = this.uiAtlas.getRec($upskin);
            frameMc.setFrameData(rec);
            frameMc.uiRender = this;
            return frameMc;
        };
        return AlphaUIRenderComponent;
    }(tl3d.UIRenderComponent));
    tl3d.AlphaUIRenderComponent = AlphaUIRenderComponent;
    var AlphaFrameCompenent = /** @class */ (function (_super) {
        __extends(AlphaFrameCompenent, _super);
        function AlphaFrameCompenent() {
            var _this = _super.call(this) || this;
            _this.alpha = 1;
            return _this;
        }
        AlphaFrameCompenent.prototype.setVc = function (program, index) {
            tl3d.Scene_data.context3D.setVc4fv(program, "ui[" + index + "]", this.renderData);
            tl3d.Scene_data.context3D.setVc4fv(program, "ui2[" + index + "]", this.renderData2);
            tl3d.Scene_data.context3D.setVc1fv(program, "alpha[" + index + "]", [this.alpha]);
        };
        return AlphaFrameCompenent;
    }(tl3d.FrameCompenent));
    tl3d.AlphaFrameCompenent = AlphaFrameCompenent;
    var AlphaGrid9UICompenent = /** @class */ (function (_super) {
        __extends(AlphaGrid9UICompenent, _super);
        function AlphaGrid9UICompenent() {
            var _this = _super.call(this) || this;
            _this.alpha = 1;
            return _this;
        }
        AlphaGrid9UICompenent.prototype.setVc = function (program, index) {
            tl3d.Scene_data.context3D.setVc4fv(program, "ui[" + index + "]", this.renderData);
            tl3d.Scene_data.context3D.setVc4fv(program, "ui2[" + index + "]", this.renderData2);
            tl3d.Scene_data.context3D.setVc1fv(program, "alpha[" + index + "]", [this.alpha]);
        };
        return AlphaGrid9UICompenent;
    }(tl3d.Grid9Compenent));
    tl3d.AlphaGrid9UICompenent = AlphaGrid9UICompenent;
    var AlphaUICompenent = /** @class */ (function (_super) {
        __extends(AlphaUICompenent, _super);
        function AlphaUICompenent() {
            var _this = _super.call(this) || this;
            _this.alpha = 1;
            return _this;
        }
        AlphaUICompenent.prototype.setVc = function (program, index) {
            tl3d.Scene_data.context3D.setVc4fv(program, "ui[" + index + "]", this.renderData);
            tl3d.Scene_data.context3D.setVc4fv(program, "ui2[" + index + "]", this.renderData2);
            tl3d.Scene_data.context3D.setVc1fv(program, "alpha[" + index + "]", [this.alpha]);
        };
        return AlphaUICompenent;
    }(tl3d.UICompenent));
    tl3d.AlphaUICompenent = AlphaUICompenent;
    var AlphaUiContianer = /** @class */ (function (_super) {
        __extends(AlphaUiContianer, _super);
        function AlphaUiContianer($classVo, $rect, $num) {
            return _super.call(this, $classVo, $rect, $num) || this;
        }
        AlphaUiContianer.prototype.creatBaseRender = function () {
            this._baseRender = new AlphaUIRenderComponent;
        };
        return AlphaUiContianer;
    }(tl3d.Dis2DUIContianerPanel));
    tl3d.AlphaUiContianer = AlphaUiContianer;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var AnimManager = /** @class */ (function () {
        function AnimManager() {
            this._dic = new Object();
        }
        AnimManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new AnimManager();
            }
            return this._instance;
        };
        AnimManager.prototype.getAnimData = function ($url, $fun) {
            var _this = this;
            if (this._dic[$url]) {
                $fun(this._dic[$url]);
                return;
            }
            tl3d.LoadManager.getInstance().load($url, tl3d.LoadManager.BYTE_TYPE, function ($byte, _fun) {
                //this.loadObjCom($byte, _fun, $url);
                var animData = _this.readData(new tl3d.TLByteArray($byte), $url);
                _fun(animData);
            }, $fun);
        };
        AnimManager.prototype.getAnimDataImmediate = function ($url) {
            return this._dic[$url];
        };
        AnimManager.prototype.clearAnim = function ($url) {
            delete this._dic[$url];
        };
        AnimManager.prototype.readData = function (byte, $url) {
            var hierarchyList = new Array;
            var frameAry = new Array;
            var animData = new tl3d.AnimData();
            animData.inLoop = byte.readInt();
            var numLength = byte.readInt();
            for (var i = 0; i < numLength; i++) {
                animData.inter.push(byte.readInt());
            }
            numLength = byte.readInt();
            for (var i = 0; i < numLength; i++) {
                animData.bounds.push(byte.readVector3D());
            }
            animData.nameHeight = byte.readInt();
            numLength = byte.readInt();
            for (var i = 0; i < numLength; i++) {
                var objBone = new ObjectBone();
                objBone.father = byte.readInt();
                objBone.changtype = byte.readInt();
                objBone.startIndex = byte.readInt();
                objBone.tx = byte.readFloat();
                objBone.ty = byte.readFloat();
                objBone.tz = byte.readFloat();
                objBone.qx = byte.readFloat();
                objBone.qy = byte.readFloat();
                objBone.qz = byte.readFloat();
                hierarchyList.push(objBone);
            }
            this.readFrameData(byte, frameAry);
            numLength = byte.readInt();
            for (var i = 0; i < numLength; i++) {
                animData.posAry.push(byte.readVector3D());
            }
            animData.matrixAry = this.processFrame(frameAry, hierarchyList);
            this._dic[$url] = animData;
            return animData;
        };
        AnimManager.prototype.readFrameData = function (byte, frameAry) {
            var $frameTyeArr = this.readFrameTypeData(byte);
            var $isStand = byte.readBoolean(); //是否为站立，这里特殊给站立的旋转设置其权重值不压缩
            var $scaleNum = byte.readFloat();
            var numLength = byte.readInt();
            for (var i = 0; i < numLength; i++) {
                var frameItemAryLength = byte.readInt();
                var frameItemAry = new Array;
                frameAry.push(frameItemAry);
                for (var j = 0; j < frameItemAryLength; j++) {
                    if ($frameTyeArr[j]) {
                        frameItemAry.push(byte.readFloatTwoByte($scaleNum));
                    }
                    else {
                        if ($isStand) { //注意这里的特殊，针对站立时的旋转精度用浮点
                            frameItemAry.push(byte.readFloat());
                        }
                        else {
                            frameItemAry.push(byte.readShort() / 32767);
                        }
                    }
                }
            }
        };
        AnimManager.prototype.readFrameTypeData = function (byte) {
            var $arr = new Array;
            var numLength = byte.readInt();
            for (var i = 0; i < numLength; i++) {
                $arr.push(byte.readBoolean());
            }
            return $arr;
        };
        AnimManager.prototype.processFrame = function (frameAry, hierarchyList) {
            var newFrameAry = new Array;
            for (var i = 0; i < frameAry.length; i++) {
                newFrameAry.push(this.frameToBone(frameAry[i], hierarchyList));
            }
            return this.setFrameToMatrix(newFrameAry);
        };
        AnimManager.prototype.frameToBone = function (frameData, hierarchyList) {
            var _arr = new Array;
            for (var i = 0; i < hierarchyList.length; i++) {
                var _temp = new ObjectBaseBone();
                _temp.father = hierarchyList[i].father;
                var k = 0;
                if (hierarchyList[i].changtype & 1) {
                    _temp.tx = frameData[hierarchyList[i].startIndex + k];
                    ++k;
                }
                else {
                    _temp.tx = hierarchyList[i].tx;
                }
                if (hierarchyList[i].changtype & 2) {
                    _temp.ty = frameData[hierarchyList[i].startIndex + k];
                    ++k;
                }
                else {
                    _temp.ty = hierarchyList[i].ty;
                }
                if (hierarchyList[i].changtype & 4) {
                    _temp.tz = frameData[hierarchyList[i].startIndex + k];
                    ++k;
                }
                else {
                    _temp.tz = hierarchyList[i].tz;
                }
                if (hierarchyList[i].changtype & 8) {
                    _temp.qx = frameData[hierarchyList[i].startIndex + k];
                    ++k;
                }
                else {
                    _temp.qx = hierarchyList[i].qx;
                }
                if (hierarchyList[i].changtype & 16) {
                    _temp.qy = frameData[hierarchyList[i].startIndex + k];
                    ++k;
                }
                else {
                    _temp.qy = hierarchyList[i].qy;
                }
                if (hierarchyList[i].changtype & 32) {
                    _temp.qz = frameData[hierarchyList[i].startIndex + k];
                    ++k;
                }
                else {
                    _temp.qz = hierarchyList[i].qz;
                }
                _arr.push(_temp);
            }
            return _arr;
        };
        AnimManager.prototype.setFrameToMatrix = function (frameAry) {
            var matrixAry = new Array;
            for (var j = 0; j < frameAry.length; j++) {
                var boneAry = frameAry[j];
                var Q0 = new tl3d.Quaternion();
                var newM = new tl3d.Matrix3D();
                var frameMatrixAry = new Array;
                matrixAry.push(frameMatrixAry);
                for (var i = 0; i < boneAry.length; i++) {
                    var xyzfarme0 = boneAry[i];
                    Q0 = new tl3d.Quaternion(xyzfarme0.qx, xyzfarme0.qy, xyzfarme0.qz);
                    Q0.w = this.getW(Q0.x, Q0.y, Q0.z);
                    if (xyzfarme0.father == -1) {
                        newM = Q0.toMatrix3D();
                        newM.appendTranslation(xyzfarme0.tx, xyzfarme0.ty, xyzfarme0.tz);
                        newM.appendRotation(-90, tl3d.Vector3D.X_AXIS);
                        //xyzfarme0.matrix = newM;
                        frameMatrixAry.push(newM);
                    }
                    else {
                        var fatherBone = boneAry[xyzfarme0.father];
                        newM = Q0.toMatrix3D();
                        newM.appendTranslation(xyzfarme0.tx, xyzfarme0.ty, xyzfarme0.tz);
                        //newM.append(fatherBone.matrix);
                        newM.append(frameMatrixAry[xyzfarme0.father]);
                        frameMatrixAry.push(newM);
                        //xyzfarme0.matrix = newM;
                    }
                }
                for (i = 0; i < frameMatrixAry.length; i++) {
                    frameMatrixAry[i].appendScale(-1, 1, 1); //特别标记，因为四元数和矩阵运算结果不一  先存正确的矩阵
                    //xyzfarme0.matrix.appendScale(-1, 1, 1);
                }
            }
            return matrixAry;
        };
        AnimManager.prototype.getW = function (x, y, z) {
            var t = 1 - (x * x + y * y + z * z);
            if (t < 0) {
                t = 0;
            }
            else {
                t = -Math.sqrt(t);
            }
            return t;
        };
        return AnimManager;
    }());
    tl3d.AnimManager = AnimManager;
    var ObjectBaseBone = /** @class */ (function () {
        function ObjectBaseBone() {
        }
        return ObjectBaseBone;
    }());
    var ObjectBone = /** @class */ (function (_super) {
        __extends(ObjectBone, _super);
        function ObjectBone() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ObjectBone.prototype.clone = function () {
            var newBone = new ObjectBone;
            newBone.tx = this.tx;
            newBone.ty = this.ty;
            newBone.tz = this.tz;
            newBone.tw = this.tw;
            newBone.qx = this.qx;
            newBone.qy = this.qy;
            newBone.qz = this.qz;
            newBone.qw = this.qw;
            newBone.changtype = this.changtype;
            newBone.name = this.name;
            newBone.father = this.father;
            newBone.startIndex = this.startIndex;
            newBone.matrix = this.matrix;
            return newBone;
        };
        return ObjectBone;
    }(ObjectBaseBone));
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ArtFont = /** @class */ (function () {
        function ArtFont() {
            this.fontData = new tl3d.Dictionary([]);
            this.fontData_Unit = new tl3d.Dictionary([]);
            this.makeFontRect();
        }
        ArtFont.getInstance = function () {
            if (!this._instance) {
                this._instance = new ArtFont();
            }
            return this._instance;
        };
        ArtFont.prototype.makeFontRect = function () {
            // this.fontData["Red"] = this.makeBase12pxNum(new Vector2D(0, 0));
            // this.fontData["Green"] = this.makeBase12pxNum(new Vector2D(0, 15));
            // this.fontData["Blue"] = this.makeBase12pxNum(new Vector2D(0, 30));
            // this.fontData["White"] = this.makeBase12pxNum(new Vector2D(0, 45));
            // this.fontData["Yellow"] = this.makeBase12pxNum(new Vector2D(0, 75));
            // this.getXmlData(UIData.textlist);
            this.getXmlData(tl3d.UIData.flytext);
            // console.log(this.fontData);
        };
        ArtFont.prototype.getXmlData = function ($key) {
            // var obj: any = UIData.getUiByName(UIData.textlist, "A_txt1");
            var $uiList = tl3d.UIData.getUiArrByKey($key);
            for (var i = 0; i < $uiList.length; i++) {
                var $skinName = String($uiList[i].name);
                if ($skinName.search("A_") != -1) {
                    var $id = Number($skinName.substring(5, $skinName.length));
                    var $uiRect = new tl3d.UIRectangle();
                    $uiRect.pixelX = Number($uiList[i].ox);
                    $uiRect.pixelY = Number($uiList[i].oy);
                    $uiRect.pixelWitdh = Number($uiList[i].ow);
                    $uiRect.pixelHeight = Number($uiList[i].oh);
                    $uiRect.cellX = Number($uiList[i].cellX);
                    $uiRect.cellY = Number($uiList[i].cellY);
                    var $rectFont = new tl3d.Rectangle(0, 0, $uiRect.pixelWitdh / $uiRect.cellX, $uiRect.pixelHeight);
                    var $arr = new Array;
                    for (var j = 0; j < $uiRect.cellX; j++) {
                        $arr.push(new tl3d.Rectangle($uiRect.pixelX + j * $rectFont.width, $uiRect.pixelY, $rectFont.width, $rectFont.height));
                    }
                    this.fontData["NUM" + $id] = $arr;
                    //  //console.log("NUM" + $id, $arr)
                }
                //万、亿
                if ($skinName.search("B_") != -1) {
                    var $id = Number($skinName.substring(5, $skinName.length));
                    var $uiRect = new tl3d.UIRectangle();
                    $uiRect.pixelX = Number($uiList[i].ox);
                    $uiRect.pixelY = Number($uiList[i].oy);
                    $uiRect.pixelWitdh = Number($uiList[i].ow);
                    $uiRect.pixelHeight = Number($uiList[i].oh);
                    $uiRect.cellX = Number($uiList[i].cellX);
                    $uiRect.cellY = Number($uiList[i].cellY);
                    var $rectFont = new tl3d.Rectangle(0, 0, $uiRect.pixelWitdh / $uiRect.cellX, $uiRect.pixelHeight);
                    var $arr = new Array;
                    for (var j = 0; j < $uiRect.cellX; j++) {
                        $arr.push(new tl3d.Rectangle($uiRect.pixelX + j * $rectFont.width, $uiRect.pixelY, $rectFont.width, $rectFont.height));
                    }
                    this.fontData_Unit["BNUM" + $id] = $arr;
                    //  //console.log("NUM" + $id, $arr)
                }
            }
        };
        // private makeBase12pxNum($pos: Vector2D): Array<Rectangle> {
        //     var $arr: Array<Rectangle> = new Array;
        //     $arr.push(new Rectangle(3, 0, 9, 14))//0
        //     $arr.push(new Rectangle(14, 0, 9, 14))//1
        //     $arr.push(new Rectangle(25, 0, 9, 14))//2
        //     $arr.push(new Rectangle(36, 0, 9, 14))//3
        //     $arr.push(new Rectangle(47, 0, 9, 14))//4
        //     $arr.push(new Rectangle(59, 0, 9, 14))//5
        //     $arr.push(new Rectangle(70, 0, 9, 14))//6
        //     $arr.push(new Rectangle(81, 0, 9, 14))//7
        //     $arr.push(new Rectangle(92.5, 0, 9, 14))//8
        //     $arr.push(new Rectangle(104, 0, 9, 14))//9
        //     $arr.push(new Rectangle(116, 0, 9, 14))//<+>
        //     $arr.push(new Rectangle(126, 0, 9, 14))//<->
        //     $arr.push(new Rectangle(136, 0, 9, 14))//</>
        //     $arr.push(new Rectangle(144, 0, 9, 13))//<:>
        //     $arr.push(new Rectangle(154, 0, 9, 13))//<.>
        //     for (var i: number = 0; i < $arr.length; i++) {
        //         $arr[i].x = $arr[i].x + $pos.x;
        //         $arr[i].y = $arr[i].y + $pos.y;
        //     }
        //     return $arr;
        // }
        // public txtInterval: number = 0;
        //将美术字写到ctx上 左对齐的
        ArtFont.prototype.writeFontToCtxLeft = function ($ctx, $str, $color, $tx, $ty, $txtInterval) {
            if ($color === void 0) { $color = ArtFont.num1; }
            if ($tx === void 0) { $tx = 0; }
            if ($ty === void 0) { $ty = 0; }
            if ($txtInterval === void 0) { $txtInterval = 0; }
            var $textItem = this.fontData[$color];
            var totalW = 0;
            var numId;
            for (var i = 0; i < $str.length; i++) {
                numId = this.getCharId($str[i]);
                var txtNumRect = this.getRect(numId, $color, $textItem);
                if (!txtNumRect) {
                    //console.log("writeFontToCtxLeft有错")
                    return;
                }
                $ctx.drawImage(tl3d.UIData.textImg, txtNumRect.x, txtNumRect.y, txtNumRect.width, txtNumRect.height, totalW + $tx, $ty, txtNumRect.width, txtNumRect.height);
                totalW = totalW + (txtNumRect.width - $txtInterval);
            }
            return totalW;
        };
        /**
         * 将美术字写到ctx上 右对齐的
         * $tx:绘制的终点x
         * $ty:绘制的起点Y
         */
        ArtFont.prototype.writeFontToCtxRight = function ($ctx, $str, $color, $tx, $ty, $txtInterval) {
            if ($color === void 0) { $color = ArtFont.White; }
            if ($tx === void 0) { $tx = 0; }
            if ($ty === void 0) { $ty = 0; }
            if ($txtInterval === void 0) { $txtInterval = 0; }
            var $textItem = this.fontData[$color];
            var totalW = 0;
            var $txtWidth = this.getAirFontWidth($ctx, $str, $color, $txtInterval);
            var numId;
            for (var i = 0; i < $str.length; i++) {
                numId = this.getCharId($str[i]);
                var txtNumRect = this.getRect(numId, $color, $textItem);
                $ctx.drawImage(tl3d.UIData.textImg, txtNumRect.x, txtNumRect.y, txtNumRect.width, txtNumRect.height, totalW + $tx - $txtWidth, $ty, txtNumRect.width, txtNumRect.height);
                totalW = totalW + (txtNumRect.width - $txtInterval);
            }
            return $txtWidth;
        };
        /**
         * 绘制数字到ctx  居中对齐
         * @param ctx
         * @param str
         * @param pw ctx的宽度
         * @param color
         * @param tx x偏移
         * @param ty y偏移
         * @param txtInterval
         */
        ArtFont.prototype.writeFontToCtxCenten = function ($ctx, $str, pw, $color, $tx, $ty, $txtInterval) {
            if ($color === void 0) { $color = ArtFont.White; }
            if ($tx === void 0) { $tx = 0; }
            if ($ty === void 0) { $ty = 0; }
            if ($txtInterval === void 0) { $txtInterval = 0; }
            var $textItem = this.fontData[$color];
            var totalW = 0;
            var $txtWidth = this.getAirFontWidth($ctx, $str, $color, $txtInterval);
            //居中位置
            var startX = (pw - $txtWidth) >> 1;
            //x偏移
            startX += $tx;
            var numId;
            if ($str == undefined) {
                //console.log("有错的")
            }
            for (var i = 0; i < $str.length; i++) {
                numId = this.getCharId($str[i]);
                var txtNumRect = this.getRect(numId, $color, $textItem);
                $ctx.drawImage(tl3d.UIData.textImg, txtNumRect.x, txtNumRect.y, txtNumRect.width, txtNumRect.height, totalW + startX, $ty, txtNumRect.width, txtNumRect.height);
                totalW = totalW + (txtNumRect.width - $txtInterval);
            }
            return $txtWidth;
        };
        ArtFont.prototype.writeFontToSkinName = function ($UIAtlas, $iconName, $str, $color, $textAlign, $txtInterval, $py) {
            if ($color === void 0) { $color = ArtFont.ORANGE_TXT; }
            if ($textAlign === void 0) { $textAlign = tl3d.TextAlign.LEFT; }
            if ($txtInterval === void 0) { $txtInterval = 0; }
            if ($py === void 0) { $py = 0; }
            var rec = $UIAtlas.getRec($iconName);
            $UIAtlas.ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
            var $txtnum;
            if ($textAlign == tl3d.TextAlign.LEFT) {
                $txtnum = this.writeFontToCtxLeft($UIAtlas.ctx, $str, $color, 0, $py, $txtInterval);
            }
            else if ($textAlign == tl3d.TextAlign.RIGHT) {
                $txtnum = this.writeFontToCtxRight($UIAtlas.ctx, $str, $color, rec.pixelWitdh, $py, $txtInterval);
            }
            else if ($textAlign == tl3d.TextAlign.CENTER) {
                $txtnum = this.writeFontToCtxCenten($UIAtlas.ctx, $str, rec.pixelWitdh, $color, 0, $py, $txtInterval);
            }
            tl3d.TextureManager.getInstance().updateTexture($UIAtlas.texture, rec.pixelX, rec.pixelY, $UIAtlas.ctx);
            return $txtnum;
        };
        ArtFont.prototype.writeFontToSkinNameCenter = function ($UIAtlas, $iconName, $str, $color, $txtInterval) {
            if ($color === void 0) { $color = ArtFont.ORANGE_TXT; }
            if ($txtInterval === void 0) { $txtInterval = 0; }
            var rec = $UIAtlas.getRec($iconName);
            $UIAtlas.ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
            var $tx = rec.pixelWitdh / 2;
            var $ty = rec.pixelHeight / 2;
            var $textItem = this.fontData[$color];
            var totalW = 0;
            var $txtWidth = this.getAirFontWidth($UIAtlas.ctx, $str, $color, $txtInterval) / 2;
            var numId;
            for (var i = 0; i < $str.length; i++) {
                numId = this.getCharId($str[i]);
                var txtNumRect = this.getRect(numId, $color, $textItem);
                $UIAtlas.ctx.drawImage(tl3d.UIData.textImg, txtNumRect.x, txtNumRect.y, txtNumRect.width, txtNumRect.height, totalW + $tx - $txtWidth, $ty - (txtNumRect.height / 2), txtNumRect.width, txtNumRect.height);
                totalW = totalW + (txtNumRect.width - $txtInterval);
            }
            tl3d.TextureManager.getInstance().updateTexture($UIAtlas.texture, rec.pixelX, rec.pixelY, $UIAtlas.ctx);
        };
        //统计美术字文本的宽度
        ArtFont.prototype.getAirFontWidth = function ($ctx, $str, $color, $txtInterval) {
            if ($color === void 0) { $color = ArtFont.White; }
            if ($txtInterval === void 0) { $txtInterval = 0; }
            if ($str == undefined) {
                return 0;
            }
            var $textItem = this.fontData[$color];
            var totalW = 0;
            var numId;
            for (var i = 0; i < $str.length; i++) {
                numId = this.getCharId($str[i]);
                var txtNumRect = this.getRect(numId, $color, $textItem);
                if (!txtNumRect) {
                    console.error("---$str---", $str);
                }
                totalW = totalW + (txtNumRect.width - $txtInterval);
            }
            return totalW;
        };
        ArtFont.prototype.getRect = function (numId, $color, $textItem) {
            var txtNumRect;
            if (numId > 15) {
                //亿万处理
                txtNumRect = this.fontData_Unit["B" + $color][numId - 16];
            }
            else {
                txtNumRect = $textItem[numId];
            }
            return txtNumRect;
        };
        ArtFont.prototype.upArtFont = function ($UIAtlas, $iconName, $str, $size, $color, $textAlign) {
            if ($size === void 0) { $size = 12; }
            if ($color === void 0) { $color = ArtFont.White; }
            if ($textAlign === void 0) { $textAlign = tl3d.TextAlign.LEFT; }
            //var $str:string="5689556"
            var scale = $size / 12;
            var textItem = this.fontData[$color];
            var rec = $UIAtlas.getRec($iconName);
            $UIAtlas.ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
            //计算totalW
            var totalW = this.getTotalWandDraw(rec, $str, textItem, scale, $UIAtlas.ctx, false);
            //选择左中右排布
            var xpos = this.getXpos($textAlign, totalW, new tl3d.Rectangle(0, 0, rec.pixelWitdh, rec.pixelHeight));
            //绘制
            this.getTotalWandDraw(rec, $str, textItem, scale, $UIAtlas.ctx, true, xpos);
            tl3d.TextureManager.getInstance().updateTexture($UIAtlas.texture, rec.pixelX, rec.pixelY, $UIAtlas.ctx);
        };
        ArtFont.prototype.upArtBase = function ($UIAtlas, $iconName, $str, $color, $textAlign) {
            if ($color === void 0) { $color = ArtFont.White; }
            if ($textAlign === void 0) { $textAlign = tl3d.TextAlign.LEFT; }
            //var $str:string="5689556"
            var scale = 1;
            var textItem = this.fontData[$color];
            var rec = $UIAtlas.getRec($iconName);
            $UIAtlas.ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
            //计算totalW
            var totalW = this.getTotalWandDraw(rec, $str, textItem, scale, $UIAtlas.ctx, false);
            //选择左中右排布
            var xpos = this.getXpos($textAlign, totalW, new tl3d.Rectangle(0, 0, rec.pixelWitdh, rec.pixelHeight));
            //绘制
            this.getTotalWandDraw(rec, $str, textItem, scale, $UIAtlas.ctx, true, xpos);
            tl3d.TextureManager.getInstance().updateTexture($UIAtlas.texture, rec.pixelX, rec.pixelY, $UIAtlas.ctx);
        };
        ArtFont.prototype.getXpos = function ($textAlign, $totalW, $rect) {
            var xpos = 0;
            var ypos = 0;
            if ($textAlign == tl3d.TextAlign.LEFT) {
                xpos = 0;
            }
            else if ($textAlign == tl3d.TextAlign.RIGHT) {
                xpos = $totalW - $rect.width;
            }
            else if ($textAlign == tl3d.TextAlign.CENTER) {
                xpos = ($rect.width - $totalW) / 2;
            }
            return xpos;
        };
        /**
         *计算总宽度和是否绘制
         */
        ArtFont.prototype.getTotalWandDraw = function ($rect, $str, $textItem, $scale, $ctx, $isCtx, $xpos, $txtInterval) {
            if ($xpos === void 0) { $xpos = 0; }
            if ($txtInterval === void 0) { $txtInterval = 0; }
            var totalW = 0;
            var numId;
            for (var i = 0; i < $str.length; i++) {
                numId = this.getCharId($str[i]);
                var txtNumRect = $textItem[numId];
                if (!txtNumRect) {
                    //console.log("没有这个字")
                }
                if ($isCtx) {
                    $ctx.drawImage(tl3d.UIData.textImg, txtNumRect.x, txtNumRect.y, txtNumRect.width, txtNumRect.height, $rect.x + totalW + $xpos, $rect.y, txtNumRect.width * $scale, txtNumRect.height * $scale);
                }
                totalW = totalW + (txtNumRect.width - $txtInterval) * $scale;
            }
            return totalW;
        };
        ArtFont.prototype.getCharId = function (str) {
            if (str == "+" || str == "x" || str == "X") {
                return 10;
            }
            if (str == "-") {
                return 11;
            }
            if (str == "/") {
                return 12;
            }
            if (str == ":") {
                return 13;
            }
            if (str == ".") {
                return 14;
            }
            if (str == "%") {
                return 15;
            }
            if (str == "万") {
                return 16;
            }
            if (str == "亿") {
                return 17;
            }
            if (str == "[") {
                return 18;
            }
            if (str == "]") {
                return 19;
            }
            if ((Number(str) == NaN)) {
                alert("MeshVo,GetCharId error:" + str);
            }
            return Number(str);
        };
        ArtFont.Red = "Red";
        ArtFont.Green = "Green";
        ArtFont.Blue = "Blue";
        ArtFont.White = "White";
        ArtFont.Yellow = "Yellow";
        ArtFont.BOSSBIGTXT = "NUM99";
        ArtFont.CN1 = "NUM100";
        ArtFont.num101 = "NUM101";
        ArtFont.num102 = "NUM102";
        ArtFont.BigYellow = "NUM12";
        ArtFont.num99 = "NUM99";
        ArtFont.GARY_TXT = "NUM1"; //NUM1.PNG
        ArtFont.ORANGE_TXT = "NUM19"; //NUM2
        ArtFont.num1 = "NUM1"; //NUM1
        ArtFont.num2 = "NUM2"; //NUM2
        ArtFont.num3 = "NUM3"; //NUM3
        ArtFont.num4 = "NUM4"; //NUM4
        ArtFont.num5 = "NUM5"; //NUM5
        ArtFont.num6 = "NUM6"; //NUM6
        ArtFont.num7 = "NUM7"; //NUM7
        ArtFont.num10 = "NUM10"; //NUM10
        ArtFont.num8 = "NUM8"; //NUM8
        ArtFont.num9 = "NUM9"; //NUM9
        ArtFont.num11 = "NUM11"; //NUM11
        ArtFont.num12 = "NUM12"; //NUM
        ArtFont.num13 = "NUM13"; //NUM13
        ArtFont.num14 = "NUM14"; //NUM
        ArtFont.num15 = "NUM15"; //NUM
        ArtFont.num16 = "NUM16"; //NUM
        ArtFont.num17 = "NUM17"; //NUM
        ArtFont.num18 = "NUM18"; //NUM
        ArtFont.num19 = "NUM19"; //NUM
        ArtFont.num20 = "NUM20"; //NUM
        ArtFont.num21 = "NUM21"; //NUM
        ArtFont.num22 = "NUM22"; //NUM
        ArtFont.num23 = "NUM23"; //NUM
        ArtFont.num24 = "NUM24"; //NUM
        ArtFont.num25 = "NUM24"; //NUM
        ArtFont.num26 = "NUM26"; //NUM
        ArtFont.num27 = "NUM27"; //NUM
        ArtFont.num28 = "NUM28"; //NUM
        ArtFont.num30 = "NUM30"; //NUM
        ArtFont.num51 = "NUM51"; //NUM
        ArtFont.num52 = "NUM52"; //NUM
        ArtFont.num53 = "NUM53"; //NUM
        ArtFont.num54 = "NUM54"; //NUM
        ArtFont.num55 = "NUM55"; //NUM
        ArtFont.num56 = "NUM56"; //NUM
        ArtFont.num57 = "NUM57"; //NUM
        ArtFont.num58 = "NUM58"; //NUM
        ArtFont.num59 = "NUM59"; //NUM
        ArtFont.num60 = "NUM60"; //NUM
        ArtFont.num61 = "NUM61"; //NUM
        ArtFont.numVip = "NUM62"; //NUM
        ArtFont.num63 = "NUM63"; //NUM
        ArtFont.num64 = "NUM64"; //NUM
        ArtFont.num65 = "NUM65"; //NUM
        ArtFont.num66 = "NUM66"; //NUM
        //英雄召唤新增
        ArtFont.num76 = "NUM76"; //NUM
        ArtFont.num77 = "NUM77"; //NUM
        ArtFont.num81 = "NUM81"; //NUM
        return ArtFont;
    }());
    tl3d.ArtFont = ArtFont;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SoundManager = Laya.SoundManager;
    var AudioMgr = /** @class */ (function () {
        function AudioMgr() {
        }
        //播放音乐
        AudioMgr.playMusic = function (path) {
            if (path === void 0) { path = "sound/battle_bgm3.mp3"; }
            if (!AudioMgr.MUSICPAUSE) {
                try {
                    if (AudioMgr._curbgm != path) {
                        if (AudioMgr._soundChannel) {
                            AudioMgr._soundChannel.stop();
                        }
                        AudioMgr._curbgm = path;
                        AudioMgr._soundChannel = SoundManager.playMusic(path, 0);
                        // SoundManager.setMusicVolume(0.8);
                    }
                }
                catch (error) {
                }
            }
        };
        AudioMgr.setPlayRate = function (val) {
            try {
                SoundManager.playbackRate = val;
            }
            catch (error) {
            }
        };
        //暂停背景音乐
        AudioMgr.pauseMusic = function () {
            if (AudioMgr._soundChannel) {
                AudioMgr._soundChannel.pause();
                AudioMgr.MUSICPAUSE = true;
            }
        };
        //停止背景音乐
        AudioMgr.stopMusic = function () {
            if (AudioMgr._soundChannel) {
                AudioMgr._soundChannel.stop();
            }
        };
        //继续背景音乐
        AudioMgr.resumeMusic = function () {
            if (AudioMgr._soundChannel) {
                AudioMgr._soundChannel.resume();
            }
        };
        //播放音效
        AudioMgr.playSound = function (path) {
            if (path === void 0) { path = "sound/button.mp3"; }
            if (!AudioMgr.SOUNDSTOP) {
                try {
                    SoundManager.playSound(path, 1);
                }
                catch (error) {
                }
            }
        };
        //停止音效
        AudioMgr.StopSound = function (path) {
            if (!path || path == "")
                return;
            if (!AudioMgr.SOUNDSTOP) {
                try {
                    SoundManager.stopSound(path);
                }
                catch (error) {
                }
            }
        };
        AudioMgr.pauseSound = function () {
            SoundManager.stopAllSound();
            AudioMgr.SOUNDSTOP = true;
        };
        AudioMgr.MUSICPAUSE = false;
        AudioMgr.SOUNDSTOP = false;
        return AudioMgr;
    }());
    tl3d.AudioMgr = AudioMgr;
})(tl3d || (tl3d = {}));
/**
* base64-arraybuffer
*/

(function (tl3d) {
    var Base64 = /** @class */ (function () {
        function Base64() {
        }
        Base64.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        Base64.encode = function (arraybuffer) {
            var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
            for (i = 0; i < len; i += 3) {
                base64 += this.chars[bytes[i] >> 2];
                base64 += this.chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
                base64 += this.chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
                base64 += this.chars[bytes[i + 2] & 63];
            }
            if ((len % 3) === 2) {
                base64 = base64.substring(0, base64.length - 1) + "=";
            }
            else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2) + "==";
            }
            return base64;
        };
        Base64.decode = function (base64) {
            var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
            if (base64[base64.length - 1] === "=") {
                bufferLength--;
                if (base64[base64.length - 2] === "=") {
                    bufferLength--;
                }
            }
            var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
            for (i = 0; i < len; i += 4) {
                encoded1 = this.chars.indexOf(base64[i]);
                encoded2 = this.chars.indexOf(base64[i + 1]);
                encoded3 = this.chars.indexOf(base64[i + 2]);
                encoded4 = this.chars.indexOf(base64[i + 3]);
                bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
                bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
            }
            return arraybuffer;
        };
        return Base64;
    }());
    tl3d.Base64 = Base64;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TextJumpType = /** @class */ (function () {
        function TextJumpType() {
        }
        TextJumpType.NORMALDAMAGE = 1; //普通伤害
        TextJumpType.CRIT = 2; //暴击
        TextJumpType.DODGE = 3; //闪避
        TextJumpType.TREATMENT = 4; //治疗
        TextJumpType.VERTIGO = 5; //眩晕
        TextJumpType.FREEZE = 6; //定身
        TextJumpType.ATTACKADD = 7; //攻击增加
        TextJumpType.ATTACKREDUCE = 8; //攻击减少
        TextJumpType.EXPERIENCE = 9; //经验
        TextJumpType.NORMALDAMAGEUP = 11; //普通伤害上
        TextJumpType.CRITUP = 12; //暴击上
        TextJumpType.MYNORMALDAMAGE = 13; //自己受伤普通伤害
        TextJumpType.MYNORMALDAMAGEUP = 14; //自己受伤普通伤害上
        TextJumpType.MISS = 15; //未命中，对敌方
        TextJumpType.N_NORMALDAMAGE = 16; //普通伤害16+60 76
        TextJumpType.N_CRIT = 17; //暴击 17+60 77
        TextJumpType.N_RESISTANCE = 18; //抵抗 
        TextJumpType.N_RESISTANCES = 181; //抵抗 
        TextJumpType.N_IMMUNE = 19; //免疫
        TextJumpType.N_ONCEATTACK = 20; //追加回合
        TextJumpType.N_PASSIVE = 21; //被动技能 21+60 81
        TextJumpType.N_RESURGENCE = 22; //复活
        TextJumpType.N_UPHP = 23; //回血 23+60 83
        TextJumpType.N_BEATBACK = 24; //反击 
        TextJumpType.N_DOWNHP = 25; //无法回血 
        TextJumpType.N_BOMB = 26; //炸弹 
        TextJumpType.N_DIZZY = 27; //晕眩 
        TextJumpType.N_INVINCIBLE = 28; //无敌 
        TextJumpType.N_TARGET = 29; //标记
        TextJumpType.N_SARCASM = 30; //嘲讽
        TextJumpType.N_SILENCE = 31; //沉默
        TextJumpType.N_SHIELD = 32; //护盾
        TextJumpType.N_BLEED = 33; //流血
        TextJumpType.N_SLEEP = 34; //沉睡
        TextJumpType.N_CRIT_RATE_UP = 35; //暴击率+ 
        TextJumpType.N_RESIST_RATE_UP = 36; //抵抗+ 
        TextJumpType.N_ATTACK_UP = 37; //攻击+
        TextJumpType.N_DEFENSE_UP = 38; //防御+
        TextJumpType.N_SPEED_UP = 39; //攻速+
        TextJumpType.N_HIT_UP = 40; //命中+
        TextJumpType.N_CRIT_RATE_DOWN = 41; //暴击率- 
        TextJumpType.N_RESIST_RATE_DOWN = 42; //抵抗- 
        TextJumpType.N_ATTACK_DOWN = 43; //攻击-
        TextJumpType.N_DEFENSE_DOWN = 44; //防御-
        TextJumpType.N_SPEED_DOWN = 45; //攻速-
        TextJumpType.N_HIT_DOWN = 46; //命中-
        TextJumpType.N_SHIHUA = 47; //石化
        TextJumpType.N_MEIHUO = 48; //魅惑
        TextJumpType.N_SHUFU = 49; //束缚
        TextJumpType.N_BINGFENG = 50; //冰封
        TextJumpType.N_ZHONGDU = 51; //中毒
        TextJumpType.N_LEIDIAN = 52; //雷电
        TextJumpType.N_ANGER_DOWN = 53; //减怒
        TextJumpType.N_WANGLING = 54; //亡灵
        TextJumpType.N_MABI = 55; //麻痹
        TextJumpType.N_FENNU = 56; //愤怒
        TextJumpType.N_FANTAN = 57; //反弹
        TextJumpType.N_SHARE = 58; //分摊
        TextJumpType.N_ZHUOSHAO = 59; //灼烧
        return TextJumpType;
    }());
    tl3d.TextJumpType = TextJumpType;
    var TextJumpUiVo = /** @class */ (function () {
        function TextJumpUiVo() {
        }
        return TextJumpUiVo;
    }());
    tl3d.TextJumpUiVo = TextJumpUiVo;
    var ExpTextJumpUiDrawAndRefreash = /** @class */ (function (_super) {
        __extends(ExpTextJumpUiDrawAndRefreash, _super);
        function ExpTextJumpUiDrawAndRefreash() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /** [posx,posy,Scalex,Scaley,alpha] */
            _this._lastchange = [0, 0, 0, 0, 0];
            return _this;
        }
        ExpTextJumpUiDrawAndRefreash.prototype.makeData = function () {
            if (this._data) {
                var vo = this._data;
                this.dtime = vo.endtime;
                // this.dtime = 60;
                this.pos = vo.pos;
                switch (vo.type) {
                    case TextJumpType.EXPERIENCE:
                        //文字 + 数字类（最多显示4位数字）
                        this._width = this.drawTxtBydigitalAndtext(vo);
                        break;
                    default:
                        break;
                }
            }
        };
        ExpTextJumpUiDrawAndRefreash.prototype.drawTxtBydigitalAndtext = function ($vo) {
            var rec = this.parent.uiAtlas.getRec(this.textureStr);
            var ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
            var picid = $vo.type;
            var $width = 50;
            var $height = 25;
            var txtcolor;
            if ($vo.type == TextJumpType.EXPERIENCE) {
                txtcolor = tl3d.ArtFont.num54;
            }
            var distion = tl3d.ArtFont.getInstance().getAirFontWidth(ctx, String(this._data.str), txtcolor);
            distion += $width;
            tl3d.UiDraw.cxtDrawImg(ctx, "TYPE" + picid, new tl3d.Rectangle(rec.pixelWitdh - distion, rec.pixelHeight - $height, $width, $height), tl3d.UIData.publicUi);
            tl3d.ArtFont.getInstance().writeFontToCtxLeft(ctx, String(this._data.str), txtcolor, rec.pixelWitdh - distion + $width + 2, rec.pixelHeight - $height);
            tl3d.TextureManager.getInstance().updateTexture(this.parent.uiAtlas.texture, rec.pixelX, rec.pixelY, ctx);
            return distion;
        };
        ExpTextJumpUiDrawAndRefreash.prototype.update = function () {
            if (this._data) {
                this.time = tl3d.TimeUtil.getTimer();
                if (this.time >= this.dtime) {
                    if (this.ui && this.ui.parent) {
                        this.ui.parent.removeChild(this.ui);
                    }
                    this._data = null;
                    return;
                }
                var vo = this._data;
                //变化
                var $ary = this.changerules(this.time);
                this.ui.width = 256 * ($ary[2] || 0); //缩放
                this.ui.height = 50 * ($ary[3] || 0); //缩放
                this.ui.y = ($ary[1] || 0) - this.ui.height; //起始点
                this.ui.x = ($ary[0] || 0) - this.ui.width / 2 + 25; //起始点
                this.ui.alpha = $ary[4] || 0; //alpha
            }
        };
        ExpTextJumpUiDrawAndRefreash.prototype.changerules = function (t) {
            var changevo = new Array();
            var vo = this._data;
            t = (t - vo.starttime) / 1000 * 60;
            // console.log("---t---",t);
            var posx = 0;
            var posy = 0;
            var scalex = 0;
            var scaley = 0;
            var alpha = 0;
            //当前处于哪一帧
            if (vo.type == tl3d.TextJumpType.EXPERIENCE) {
                var v2d = new tl3d.Vector2D;
                if (t < 0) {
                    v2d.x = -9999;
                }
                else {
                    v2d.x = 300 / tl3d.UIData.Scale;
                    v2d.y = tl3d.Scene_data.stageHeight / tl3d.UIData.Scale - 50;
                }
                //玩家名
                posy = v2d.y -= 15;
                posy = posy - (t * 0.5);
                if (t < 40) {
                    posx = v2d.x;
                    scalex = 1.8;
                    scaley = 1.8;
                    alpha = 1;
                }
                else if (t < 60) {
                    posx = v2d.x;
                    scalex = 1.8;
                    scaley = 1.8;
                    alpha = 1 - ((t - 39) / 20);
                }
            }
            changevo.push(posx);
            changevo.push(posy);
            changevo.push(scalex);
            changevo.push(scaley);
            changevo.push(alpha);
            changevo.push(v2d.x);
            changevo.push(v2d.y);
            //保存上一次变化
            this._lastchange = changevo;
            return changevo;
        };
        return ExpTextJumpUiDrawAndRefreash;
    }(tl3d.Disp2DBaseText));
    tl3d.ExpTextJumpUiDrawAndRefreash = ExpTextJumpUiDrawAndRefreash;
    var TextJumpUiDrawAndRefreash = /** @class */ (function (_super) {
        __extends(TextJumpUiDrawAndRefreash, _super);
        function TextJumpUiDrawAndRefreash() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /** [posx,posy,Scalex,Scaley,alpha] */
            _this._lastchange = [0, 0, 0, 0, 0];
            return _this;
        }
        TextJumpUiDrawAndRefreash.prototype.makeData = function () {
            if (this._data) {
                var vo = this._data;
                this.dtime = vo.endtime;
                // this.dtime = 60;
                this.pos = vo.pos;
                switch (vo.type) {
                    case TextJumpType.NORMALDAMAGE:
                    case TextJumpType.TREATMENT:
                        //数字类
                        this._width = tl3d.ArtFont.getInstance().writeFontToSkinName(this.parent.uiAtlas, this.textureStr, String(vo.str), "NUM" + (vo.type + 50), tl3d.TextAlign.RIGHT);
                        break;
                    case TextJumpType.MYNORMALDAMAGEUP:
                    case TextJumpType.MYNORMALDAMAGE:
                        this._width = tl3d.ArtFont.getInstance().writeFontToSkinName(this.parent.uiAtlas, this.textureStr, String(vo.str), tl3d.ArtFont.num53, tl3d.TextAlign.RIGHT);
                        break;
                    case TextJumpType.NORMALDAMAGEUP:
                        this._width = tl3d.ArtFont.getInstance().writeFontToSkinName(this.parent.uiAtlas, this.textureStr, String(vo.str), "NUM" + (vo.type + 40), tl3d.TextAlign.RIGHT);
                        break;
                    case TextJumpType.DODGE:
                    case TextJumpType.VERTIGO:
                    case TextJumpType.FREEZE:
                    case TextJumpType.MISS:
                        //文字类
                        this._width = this.drawTxtBytext(vo);
                        break;
                    case TextJumpType.ATTACKADD:
                    case TextJumpType.ATTACKREDUCE:
                    case TextJumpType.EXPERIENCE:
                    case TextJumpType.CRIT:
                    case TextJumpType.CRITUP:
                        //文字 + 数字类（最多显示4位数字）
                        this._width = this.drawTxtBydigitalAndtext(vo);
                        break;
                    case TextJumpType.N_IMMUNE:
                    case TextJumpType.N_ONCEATTACK:
                    case TextJumpType.N_RESURGENCE:
                    case TextJumpType.N_RESISTANCES:
                        //文字类
                        this._width = this.drawTxtBytext(vo, tl3d.UIData.publicsUi);
                        break;
                    case TextJumpType.N_NORMALDAMAGE:
                    case TextJumpType.N_UPHP:
                        //数字类
                        var color = vo.type == TextJumpType.N_NORMALDAMAGE ? "NUM81" : "NUM76";
                        this._width = tl3d.ArtFont.getInstance().writeFontToSkinName(this.parent.uiAtlas, this.textureStr, String(vo.str), color, tl3d.TextAlign.RIGHT, 0, 64 - 35);
                        break;
                    case TextJumpType.N_PASSIVE:
                        //文字 + 数字类（最多显示4位数字）
                        this._width = this.drawTxtBydigitalAndtext(vo);
                        break;
                    case TextJumpType.N_CRIT:
                    case TextJumpType.N_RESISTANCE:
                        this._width = this.drawCritTxt(vo);
                        break;
                    default:
                        break;
                }
                if (vo.type >= TextJumpType.N_BEATBACK && vo.type <= TextJumpType.N_ZHUOSHAO) {
                    this._width = this.drawTxtBytext(vo, tl3d.UIData.publicsUi);
                }
            }
        };
        TextJumpUiDrawAndRefreash.prototype.drawCritTxt = function ($vo) {
            var rec = this.parent.uiAtlas.getRec(this.textureStr);
            var ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
            var picid = $vo.type;
            var $width = 50;
            var $height = 25;
            var txtcolor;
            if ($vo.type == TextJumpType.N_CRIT) {
                txtcolor = tl3d.ArtFont.num77;
                $width = 68;
                $height = 36;
            }
            if ($vo.type == TextJumpType.N_RESISTANCE) {
                txtcolor = tl3d.ArtFont.num81;
                $width = 68;
                $height = 36;
            }
            var distion = tl3d.ArtFont.getInstance().getAirFontWidth(ctx, String(this._data.str), txtcolor);
            var maxh = Math.max(distion, $width);
            var sx = rec.pixelWitdh - (maxh / 2) - ($width / 2);
            var sxtxt = rec.pixelWitdh - (maxh / 2) - (distion / 2);
            var sy = 0;
            tl3d.UiDraw.cxtDrawImg(ctx, "TYPE" + picid, new tl3d.Rectangle(sx, sy, $width, $height), tl3d.UIData.publicsUi);
            sy = rec.pixelHeight - 35;
            tl3d.ArtFont.getInstance().writeFontToCtxLeft(ctx, String(this._data.str), txtcolor, sxtxt, sy);
            tl3d.TextureManager.getInstance().updateTexture(this.parent.uiAtlas.texture, rec.pixelX, rec.pixelY, ctx);
            return maxh;
        };
        TextJumpUiDrawAndRefreash.prototype.drawTxtBytext = function ($vo, $key) {
            if ($key === void 0) { $key = tl3d.UIData.publicUi; }
            var rec = this.parent.uiAtlas.getRec(this.textureStr);
            var ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
            var $length = 84;
            var sheight = 44;
            if ($vo.type == TextJumpType.N_ONCEATTACK || $vo.type == TextJumpType.N_DOWNHP) {
                $length = 167;
            }
            else if ($vo.type == TextJumpType.N_CRIT_RATE_UP || $vo.type == TextJumpType.N_CRIT_RATE_DOWN) {
                $length = 156;
            }
            else if ($vo.type == TextJumpType.N_RESIST_RATE_UP || $vo.type == TextJumpType.N_RESIST_RATE_DOWN
                || $vo.type == TextJumpType.N_ATTACK_UP || $vo.type == TextJumpType.N_ATTACK_DOWN
                || $vo.type == TextJumpType.N_SPEED_UP || $vo.type == TextJumpType.N_SPEED_DOWN
                || $vo.type == TextJumpType.N_HIT_UP || $vo.type == TextJumpType.N_HIT_UP
                || $vo.type == TextJumpType.N_DEFENSE_UP || $vo.type == TextJumpType.N_DEFENSE_DOWN) {
                $length = 115;
            }
            tl3d.UiDraw.cxtDrawImg(ctx, "TYPE" + $vo.type, new tl3d.Rectangle(rec.pixelWitdh - $length, rec.pixelHeight - sheight, $length, sheight), $key);
            tl3d.TextureManager.getInstance().updateTexture(this.parent.uiAtlas.texture, rec.pixelX, rec.pixelY, ctx);
            return $length;
        };
        TextJumpUiDrawAndRefreash.prototype.drawTxtBydigitalAndtext = function ($vo) {
            var rec = this.parent.uiAtlas.getRec(this.textureStr);
            var ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
            var picid = $vo.type;
            var $width = 50;
            var $height = 25;
            var txtcolor;
            if ($vo.type == TextJumpType.ATTACKREDUCE) {
                picid = TextJumpType.ATTACKADD;
                txtcolor = tl3d.ArtFont.num53;
            }
            else if ($vo.type == TextJumpType.ATTACKADD) {
                txtcolor = tl3d.ArtFont.num54;
            }
            else if ($vo.type == TextJumpType.EXPERIENCE) {
                txtcolor = tl3d.ArtFont.num54;
            }
            else if ($vo.type == TextJumpType.CRIT) {
                txtcolor = tl3d.ArtFont.num55;
                $width = 78;
                $height = 50;
            }
            else if ($vo.type == TextJumpType.CRITUP) {
                picid -= 10;
                $width = 78;
                $height = 50;
                txtcolor = tl3d.ArtFont.num55;
            }
            if ($vo.type == TextJumpType.N_PASSIVE) {
                txtcolor = tl3d.ArtFont.num76;
                $width = 84;
                $height = 44;
            }
            var distion = tl3d.ArtFont.getInstance().getAirFontWidth(ctx, String(this._data.str), txtcolor);
            distion += $width;
            var sx = rec.pixelWitdh - distion;
            // let sy: number = 0;
            var sy = rec.pixelHeight - $height;
            tl3d.UiDraw.cxtDrawImg(ctx, "TYPE" + picid, new tl3d.Rectangle(sx, sy, $width, $height), $vo.type >= TextJumpType.N_NORMALDAMAGE ? tl3d.UIData.publicsUi : tl3d.UIData.publicUi);
            tl3d.ArtFont.getInstance().writeFontToCtxLeft(ctx, String(this._data.str), txtcolor, sx + $width + 2, sy + 6);
            tl3d.TextureManager.getInstance().updateTexture(this.parent.uiAtlas.texture, rec.pixelX, rec.pixelY, ctx);
            return distion;
        };
        TextJumpUiDrawAndRefreash.prototype.update = function () {
            if (this._data) {
                this.time = tl3d.TimeUtil.getTimer();
                if (this.time >= this.dtime) {
                    if (this.ui && this.ui.parent) {
                        this.ui.parent.removeChild(this.ui);
                    }
                    this._data = null;
                    return;
                }
                // if (this.time > this.dtime) {
                //     this.ui.parent.removeChild(this.ui);
                //     this._data = null;
                //     return;
                // }
                // this.time++;
                var vo = this._data;
                // var $ty: number = MathClass.easeInOut(this.time / this.dtime, 0, 20, 1)
                //变化
                var $ary = this.changerules(this.time);
                this.ui.width = 256 * ($ary[2] || 0);
                this.ui.height = 64 * ($ary[3] || 0);
                this.ui.y = ($ary[1] || 0) - this.ui.height;
                // let w1 = this.ui.width >> 1;
                // let posx: number = $ary[0]
                // if (posx < 0 && (vo.type == TextJumpType.N_UPHP || vo.type == TextJumpType.N_CRIT || vo.type == TextJumpType.N_PASSIVE)) {
                //     let x1 = w1 + posx;
                //     let x2 = this._width >> 1;
                //     if (x2 > x1) {
                //         posx += x2 - x1;
                //     }
                // }
                // let cx = $ary[0] + this.ui.width
                // let w1 = Math.max(cx,0);
                // w1 = w1 + (this._width * $ary[2]) - this.ui.width;
                // let maxh = Laya.stage.width - this.ui.width;
                // // let w1 = Math.max($ary[0],0);
                // // let maxh = Laya.stage.width - this._width;
                // w1 = Math.min(w1,maxh);
                this.ui.x = ($ary[0] || 0);
                this.ui.alpha = ($ary[4] || 0);
            }
        };
        TextJumpUiDrawAndRefreash.prototype.changerules = function (t) {
            var vo = this._data;
            //当前处于哪一帧
            // let totalt = (vo.endtime - vo.starttime)/ 1000 * 60;
            t = (t - vo.starttime) / 1000 * 60;
            var changevo = new Array();
            var v2d = this.Vector3DToVector2D(new tl3d.Vector3D(this.pos.x, this.pos.y, this.pos.z));
            // if (t < 0) {
            //     v2d.x = -9999
            // }
            if (vo.type == tl3d.TextJumpType.EXPERIENCE) {
                v2d.x = 300 / tl3d.UIData.Scale;
                v2d.y = tl3d.Scene_data.stageHeight / tl3d.UIData.Scale - 50;
            }
            var posx = 0;
            var posy = 0;
            var scalex = 0;
            var scaley = 0;
            var alpha = 0;
            //选定初始化飘字位置 
            switch (vo.type) {
                case tl3d.TextJumpType.NORMALDAMAGE:
                case tl3d.TextJumpType.MYNORMALDAMAGE:
                    //头顶
                    posx = v2d.x;
                    if (t < 4) {
                        posy = v2d.y - (t * 4);
                        scalex = (t / 4) * 1.3 + 0.2;
                        if (scalex > 1.5) {
                            scalex = 1.5;
                        }
                        scaley = scalex;
                        alpha = (t / 3) * 0.8 + 0.2;
                        if (alpha > 1) {
                            alpha = 1;
                        }
                    }
                    else if (t < 8) {
                        posy = this._lastchange[1] - 2;
                        scalex = this._lastchange[2] - 1 / 6;
                        scaley = scalex;
                        alpha = (t / 3) * 0.8 + 0.2;
                        if (alpha > 1) {
                            alpha = 1;
                        }
                    }
                    else if (t < 15) {
                        posy = this._lastchange[1] - 2;
                        scalex = this._lastchange[2] + 1 / 6;
                        scaley = scalex;
                        alpha = (t / 3) * 0.8 + 0.2;
                        if (alpha > 1) {
                            alpha = 1;
                        }
                    }
                    else if (t < 30) {
                        posy = this._lastchange[1] - 2;
                        scalex = this._lastchange[2] - 1 / 20;
                        scaley = scalex;
                        alpha = (t / 3) * 0.8 + 0.2;
                        if (alpha > 1) {
                            alpha = 1;
                        }
                    }
                    else if (t < 72) {
                        if (t < 50) {
                            posy = this._lastchange[1] - 2;
                        }
                        else {
                            posy = this._lastchange[1] + 2;
                        }
                        posx = this._lastchange[0] - 1.5;
                        scalex = this._lastchange[2];
                        scaley = scalex;
                        alpha = this._lastchange[4] - 1 / 100;
                        if (alpha < 0) {
                            alpha = 0;
                        }
                    }
                    break;
                case tl3d.TextJumpType.CRIT:
                    //暴击
                    posx = v2d.x;
                    if (t < 4) {
                        posy = v2d.y - (t * 4);
                        scalex = (t / 4) * 1.3 + 0.2;
                        if (scalex > 1.5) {
                            scalex = 1.5;
                        }
                        scaley = scalex;
                        alpha = (t / 3) * 0.8 + 0.2;
                        if (alpha > 1) {
                            alpha = 1;
                        }
                    }
                    else if (t < 8) {
                        posy = this._lastchange[1] - 2;
                        scalex = this._lastchange[2] - 1 / 6;
                        scaley = scalex;
                        alpha = (t / 3) * 0.8 + 0.2;
                        if (alpha > 1) {
                            alpha = 1;
                        }
                    }
                    else if (t < 15) {
                        posy = this._lastchange[1] - 2;
                        scalex = this._lastchange[2] + 1 / 4;
                        scaley = scalex;
                        alpha = (t / 3) * 0.8 + 0.2;
                        if (alpha > 1) {
                            alpha = 1;
                        }
                    }
                    else if (t < 30) {
                        posy = this._lastchange[1] - 2;
                        scalex = this._lastchange[2] - 1 / 20;
                        scaley = scalex;
                        alpha = (t / 3) * 0.8 + 0.2;
                        if (alpha > 1) {
                            alpha = 1;
                        }
                    }
                    else if (t < 100) {
                        if (t < 50) {
                            posy = this._lastchange[1] - 2;
                        }
                        else {
                            posy = this._lastchange[1] + 2;
                        }
                        posx = this._lastchange[0] - 1.5;
                        scalex = this._lastchange[2];
                        scaley = scalex;
                        alpha = this._lastchange[4] - 1 / 100;
                        if (alpha < 0) {
                            alpha = 0;
                        }
                    }
                    break;
                case tl3d.TextJumpType.NORMALDAMAGEUP:
                case tl3d.TextJumpType.CRITUP:
                case tl3d.TextJumpType.MYNORMALDAMAGEUP:
                    //头顶
                    posx = v2d.x;
                    if (t < 4) {
                        posy = v2d.y - (t * 4);
                        scalex = (t / 4) * 1.5 + 0.2;
                        if (scalex > 1.7) {
                            scalex = 1.7;
                        }
                        scaley = scalex;
                        alpha = (t / 3) * 0.3 + 0.2;
                        if (alpha > 0.5) {
                            alpha = 0.5;
                        }
                    }
                    else if (t < 8) {
                        posy = this._lastchange[1] - 2;
                        scalex = this._lastchange[2] - 1 / 4;
                        scaley = scalex;
                        alpha = (t / 3) * 0.3 + 0.2;
                        if (alpha > 0.5) {
                            alpha = 0.5;
                        }
                    }
                    else if (t < 15) {
                        posy = this._lastchange[1] - 2;
                        scalex = this._lastchange[2] + 1 / 4;
                        scaley = scalex;
                        alpha = (t / 3) * 0.3 + 0.2;
                        if (alpha > 0.5) {
                            alpha = 0.5;
                        }
                    }
                    else if (t < 30) {
                        posy = this._lastchange[1] - 2;
                        scalex = this._lastchange[2] - 1 / 15;
                        scaley = scalex;
                        alpha = this._lastchange[4] - 1 / 80;
                        if (alpha < 0) {
                            alpha = 0;
                        }
                    }
                    break;
                case tl3d.TextJumpType.TREATMENT:
                    //头顶
                    posx = v2d.x;
                    posy = v2d.y - (t * 1.5);
                    if (t < 12) {
                        scalex = (Math.ceil(t) / 12) * 0.8 + 0.2;
                        scaley = scalex;
                        alpha = (Math.ceil(t) / 12) * 0.8 + 0.2;
                    }
                    else if (t < 60) {
                        scalex = 1;
                        scaley = scalex;
                        alpha = 1 - ((t - 11) / 48);
                    }
                    break;
                case tl3d.TextJumpType.EXPERIENCE:
                    //玩家名
                    posy = v2d.y -= 15;
                    posy = posy - (t * 0.5);
                    if (t < 40) {
                        // posx = v2d.x - (t * 0.9);
                        // scalex = (Math.ceil(t) / 40) * 0.3 + 0.5;
                        // scaley = scalex;
                        posx = v2d.x;
                        scalex = 1.3;
                        scaley = 1.3;
                        alpha = 1;
                    }
                    else if (t < 60) {
                        // posx = v2d.x - (40 * 0.9);
                        // scalex = this._lastchange[2];
                        // scaley = scalex;
                        posx = v2d.x;
                        scalex = 1.3;
                        scaley = 1.3;
                        alpha = 1 - ((t - 39) / 20);
                    }
                    break;
                case tl3d.TextJumpType.ATTACKADD:
                case tl3d.TextJumpType.ATTACKREDUCE:
                    //右边
                    posx = v2d.x += 110;
                    posy = v2d.y - (t * 1.8);
                    if (t < 12) {
                        scalex = (Math.ceil(t) / 12) * 1.3 + 0.1;
                        scaley = scalex;
                        alpha = (Math.ceil(t) / 12) * 0.8 + 0.2;
                    }
                    else if (t < 24) {
                        scalex = 1.4 - ((t - 11) / 12) * 0.4;
                        scaley = scalex;
                        alpha = 1;
                    }
                    else if (t < 60) {
                        scalex = 1;
                        scaley = scalex;
                        alpha = 1 - ((t - 23) / 36);
                    }
                    break;
                case tl3d.TextJumpType.DODGE:
                case tl3d.TextJumpType.MISS:
                case tl3d.TextJumpType.VERTIGO:
                case tl3d.TextJumpType.FREEZE:
                    //左边
                    posx = v2d.x -= 50;
                    if (t < 12) {
                        posy = v2d.y - (t * 3);
                        scalex = 1;
                        scaley = scalex;
                        alpha = (Math.ceil(t) / 12);
                    }
                    else if (t < 36) {
                        posy = v2d.y - (33);
                        scalex = 1;
                        scaley = scalex;
                        alpha = 1;
                    }
                    else if (t < 72) {
                        posy = v2d.y - 33 - ((t - 36) * 1.5);
                        scalex = 1;
                        scaley = scalex;
                        alpha = 1 - ((t - 35) / 36);
                    }
                    break;
                //新增
                case TextJumpType.N_NORMALDAMAGE:
                case TextJumpType.N_UPHP:
                case TextJumpType.N_CRIT:
                case TextJumpType.N_RESISTANCE:
                    if (t < 12) {
                        scalex = (Math.ceil(t) / 12) * 1.1 + 0.1;
                        scaley = scalex;
                        alpha = (Math.ceil(t) / 12) * 0.8 + 0.2;
                    }
                    else if (t < 24) {
                        scalex = this._lastchange[2] - 0.008;
                        scaley = scalex;
                        alpha = 1;
                    }
                    else if (t < 60) {
                        scalex = this._lastchange[2];
                        scaley = scalex;
                        alpha = 1 - ((t - 23) / 36);
                    }
                    posy = v2d.y - (t * 1.5);
                    posx = v2d.x + 60 - (256 * scalex) / 2;
                    break;
                default:
                    break;
            }
            if (vo.type == TextJumpType.N_IMMUNE ||
                vo.type == TextJumpType.N_ONCEATTACK ||
                vo.type == TextJumpType.N_RESURGENCE ||
                vo.type == TextJumpType.N_RESISTANCES ||
                vo.type == TextJumpType.N_PASSIVE ||
                (vo.type >= TextJumpType.N_BEATBACK && vo.type <= TextJumpType.N_ZHUOSHAO)) {
                var down = vo.type >= TextJumpType.N_CRIT_RATE_DOWN && vo.type <= TextJumpType.N_HIT_DOWN;
                posx = v2d.x - 45;
                if (t < 12) {
                    posy = down ? v2d.y + (t * 3) : v2d.y - (t * 3);
                    scalex = 0.8;
                    scaley = scalex;
                    alpha = (Math.ceil(t) / 12);
                }
                else if (t < 36) {
                    posy = this._lastchange[1];
                    scalex = 0.8;
                    scaley = scalex;
                    alpha = 1;
                }
                else if (t < 72) {
                    posy = down ? this._lastchange[1] + 0.05 : this._lastchange[1] - 0.05;
                    scalex = 0.8;
                    scaley = scalex;
                    alpha = 1 - ((t - 35) / 36);
                }
            }
            changevo.push(posx);
            changevo.push(posy);
            changevo.push(scalex);
            changevo.push(scaley);
            changevo.push(alpha);
            changevo.push(v2d.x);
            changevo.push(v2d.y);
            //保存上一次变化
            this._lastchange = changevo;
            return changevo;
        };
        return TextJumpUiDrawAndRefreash;
    }(tl3d.Disp2DBaseText));
    tl3d.TextJumpUiDrawAndRefreash = TextJumpUiDrawAndRefreash;
    var CharNameUiVo = /** @class */ (function (_super) {
        __extends(CharNameUiVo, _super);
        function CharNameUiVo() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.tempMatrix = new tl3d.Matrix3D;
            return _this;
        }
        CharNameUiVo.prototype.makeData = function () {
            if (this._data) {
                this.charNameMeshVo = this.data;
                if (this.lastKey != this.charNameMeshVo.name) {
                    this.ui.width = 256 * 0.7;
                    this.ui.height = 22 * 0.7;
                    this.lastKey = this.charNameMeshVo.name;
                    tl3d.LabelTextFont.writeSingleLabel(this.parent.uiAtlas, this.textureStr, this.charNameMeshVo.name, this.charNameMeshVo.size, tl3d.TextAlign.CENTER, this.charNameMeshVo.color, this.charNameMeshVo.scolor);
                }
                this.charNameMeshVo.needDraw = false;
            }
        };
        CharNameUiVo.prototype.update = function () {
            if (this.charNameMeshVo) {
                if (this.charNameMeshVo.needDraw) {
                    this.makeData();
                }
                if (this.charNameMeshVo.pos) {
                    if (this.charNameMeshVo.visible) {
                        if (this.needUpData(this.charNameMeshVo.pos) || this.charNameMeshVo.visibleChange) {
                            var m = tl3d.Scene_data.cam3D.cameraMatrix.clone(this.tempMatrix);
                            m.append(tl3d.Scene_data.viewMatrx3D);
                            var p = m.transformVector(this.charNameMeshVo.pos);
                            this.ui.x = ((p.x / p.w) + 1) * (tl3d.Scene_data.stageWidth / 2) / tl3d.UIData.Scale - this.ui.width / 2;
                            this.ui.y = ((-p.y / p.w) + 1) * (tl3d.Scene_data.stageHeight / 2) / tl3d.UIData.Scale - this.ui.height / 2;
                            this.ui.x += this.charNameMeshVo.offsetx;
                            this.ui.y += this.charNameMeshVo.offsety;
                            this.oldPos.x = this.charNameMeshVo.pos.x;
                            this.oldPos.y = this.charNameMeshVo.pos.y;
                            this.charNameMeshVo.visibleChange = false;
                        }
                    }
                    else {
                        this.ui.x = 10000;
                    }
                }
                if (this.charNameMeshVo.clear) {
                    this.ui.parent.removeChild(this.ui);
                    this._data = null;
                }
            }
        };
        return CharNameUiVo;
    }(tl3d.Disp2DBaseText));
    tl3d.CharNameUiVo = CharNameUiVo;
    var CharTitleUiVo = /** @class */ (function (_super) {
        __extends(CharTitleUiVo, _super);
        function CharTitleUiVo() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.tempMatrix = new tl3d.Matrix3D;
            return _this;
        }
        CharTitleUiVo.prototype.makeData = function () {
            var _this = this;
            if (this._data) {
                this._charTitleMeshVo = this.data;
                //LabelTextFont.writeSingleLabel(this.parent.uiAtlas, this.textureStr, "ccav", 22, TextAlign.CENTER, "#ffffff");
                // this.parent.uiAtlas.upDataPicToTexture(getUItittleUrl(String(this._charTitleMeshVo.num)), this.textureStr)
                tl3d.LoadManager.getInstance().load(tl3d.Scene_data.fileRoot + tl3d.UnitFunction.getUItittleUrl(String(this._charTitleMeshVo.num)), tl3d.LoadManager.IMG_TYPE, function ($img) {
                    var $uiRec = _this.parent.uiAtlas.getRec(_this.textureStr);
                    _this.parent.uiAtlas.ctx = tl3d.UIManager.getInstance().getContext2D($uiRec.pixelWitdh, $uiRec.pixelHeight, false);
                    var $minScale = Math.min($uiRec.pixelWitdh / $img.width, $uiRec.pixelHeight / $img.height);
                    $minScale = Math.min($minScale, 1);
                    var $tw = $img.width * $minScale;
                    var $th = $img.height * $minScale;
                    _this.parent.uiAtlas.ctx.drawImage($img, ($uiRec.pixelWitdh - $tw) / 2, ($uiRec.pixelHeight - $th) / 2, $tw, $th);
                    tl3d.TextureManager.getInstance().updateTexture(_this.parent.uiAtlas.texture, $uiRec.pixelX, $uiRec.pixelY, _this.parent.uiAtlas.ctx);
                });
            }
        };
        CharTitleUiVo.prototype.update = function () {
            if (this._charTitleMeshVo) {
                if (this._charTitleMeshVo.needDraw) {
                    this.makeData();
                    this._charTitleMeshVo.needDraw = false;
                }
                if (this._charTitleMeshVo.pos) {
                    if (this._charTitleMeshVo.visible) {
                        if (this.needUpData(this._charTitleMeshVo.pos)) {
                            var m = tl3d.Scene_data.cam3D.cameraMatrix.clone(this.tempMatrix);
                            m.append(tl3d.Scene_data.viewMatrx3D);
                            var p = m.transformVector(this._charTitleMeshVo.pos);
                            this.ui.x = ((p.x / p.w) + 1) * (tl3d.Scene_data.stageWidth / 2) / tl3d.UIData.Scale - this.ui.width / 2;
                            this.ui.y = ((-p.y / p.w) + 1) * (tl3d.Scene_data.stageHeight / 2) / tl3d.UIData.Scale - this.ui.height / 2;
                            this.oldPos.x = this._charTitleMeshVo.pos.x;
                            this.oldPos.y = this._charTitleMeshVo.pos.y;
                        }
                    }
                    else {
                        this.ui.x = 10000;
                    }
                }
                if (this._charTitleMeshVo.clear) {
                    this.ui.parent.removeChild(this.ui);
                    this._data = null;
                }
            }
        };
        return CharTitleUiVo;
    }(tl3d.Disp2DBaseText));
    tl3d.CharTitleUiVo = CharTitleUiVo;
    var baseMeshVo = /** @class */ (function () {
        function baseMeshVo() {
            this._visible = true;
            this.visibleChange = false;
            this.offsetx = 0;
            this.offsety = 0;
            this.clear = false;
        }
        Object.defineProperty(baseMeshVo.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            set: function (value) {
                this._visible = value;
                this.visibleChange = true;
            },
            enumerable: true,
            configurable: true
        });
        return baseMeshVo;
    }());
    tl3d.baseMeshVo = baseMeshVo;
})(tl3d || (tl3d = {}));
// namespace Pan3d {
// export class BloodUIShader extends Shader3D {
//     static BloodUIShader: string = "BloodUIShader";
//     constructor() {
//         super();
//     }
//     binLocation($context: WebGLRenderingContext): void {
//         $context.bindAttribLocation(this.program, 0, "v3Pos");
//         $context.bindAttribLocation(this.program, 1, "v2uv");
//     }
//     getVertexShaderString(): string {
//         var $str: string =
//             "attribute vec3 v3Pos;" +
//             "attribute vec3 v2uv;" +
//             "uniform vec4 ui[30];" +
//             "uniform vec4 lifenum[30];" +
//             "varying vec2 v_texCoord;\n" +
//             "varying vec4 v_lifenum;\n" +
//             "void main(void)" +
//             "{" +
//             " v_lifenum = lifenum[int(v2uv.z)];" +
//             " v_texCoord = vec2(v2uv.x , v2uv.y );" +
//             " vec4  data = ui[int(v2uv.z)];" +
//             "   vec3 pos = vec3(0.0,0.0,0.0);" +
//             "   pos.xy = v3Pos.xy *data.zw * 2.0;" +
//             "   pos.x += data.x * 2.0 - 1.0;" +
//             "   pos.y += -data.y * 2.0 + 1.0;" +
//             "   vec4 vt0= vec4(pos, 1.0);" +
//             "   gl_Position = vt0;" +
//             "}"
//         return $str
//     }
//     getFragmentShaderString(): string {
//         var $str: string =
//             "precision mediump float;\n" +
//             "uniform sampler2D s_texture;\n" +
//             "varying vec2 v_texCoord;\n" +
//             "varying vec4 v_lifenum;\n" +
//             "void main(void)\n" +
//             "{\n" +
//             "vec2  v_uv = v_texCoord;" +
//             "if(v_texCoord.x<v_lifenum.x){;\n" +
//             "v_uv.y = v_uv.y+10.0/3.0;" +
//             "}else{;\n" +
//             "if(v_texCoord.x<v_lifenum.x+v_lifenum.z){;\n" +
//             "v_uv.y = v_uv.y+10.0/3.0+10.0/3.0;" +
//             "};\n" +
//             "};\n" +
//             "vec4 infoUv = texture2D(s_texture, v_uv.xy);\n" +
//             "infoUv.xyz *= infoUv.w;\n" +
//             "gl_FragColor = infoUv;\n" +
//             "}"
//         return $str
//     }
// }
// export class BloodUICompenent extends UICompenent {
//     public constructor() {
//         super();
//     }
//     public pushVaData(objData: ObjData, i: number, beginIndex: number): number {
//         objData.vertices.push(
//             0, 0, 0,
//             1, 0, 0,
//             1, -1, 0,
//             0, -1, 0);
//         objData.uvs.push(
//             0, 0, i,
//             1, 0, i,
//             1, 3 / 10, i,
//             0, 3 / 10, i);
//         objData.indexs.push(beginIndex, 1 + beginIndex, 2 + beginIndex, beginIndex, 2 + beginIndex, 3 + beginIndex);
//         return beginIndex + 4;
//     }
//     public lifeNum: number = 100;
//     public midNum: number = 0.3;
//     public colortype: number = 0;  //0,1,2;
// }
// export class BloodDisp2DBaseText extends Disp2DBaseText {
//     private bloodLineMeshVo: BloodLineMeshVo
//     public makeData(): void {
//         if (this._data) {
//             this.bloodLineMeshVo = <BloodLineMeshVo>this.data;
//         }
//     }
//     private tempMatrix: Matrix3D = new Matrix3D;
//     public update(): void {
//         if (this.bloodLineMeshVo) {
//             if (this.bloodLineMeshVo.pos) {
//                 if (this.bloodLineMeshVo.visible) {
//                     if (this.needUpData(this.bloodLineMeshVo.pos) || this.bloodLineMeshVo.visibleChange) {
//                         var m: Matrix3D = Scene_data.cam3D.cameraMatrix.clone(this.tempMatrix);
//                         m.append(Scene_data.viewMatrx3D);
//                         var p: Vector3D = m.transformVector(new Vector3D(this.bloodLineMeshVo.pos.x, this.bloodLineMeshVo.pos.y, this.bloodLineMeshVo.pos.z))
//                         this.ui.x = ((p.x / p.w) + 1) * (Scene_data.stageWidth / 2) / UIData.Scale - this.ui.width / 2;
//                         this.ui.y = ((-p.y / p.w) + 1) * (Scene_data.stageHeight / 2) / UIData.Scale - this.ui.height / 2 + this.bloodLineMeshVo.offsety;
//                         this.ui.x += this.bloodLineMeshVo.posx;
//                         this.bloodLineMeshVo.visibleChange = false
//                     }
//                     (<BloodUICompenent>this.ui).lifeNum = this.bloodLineMeshVo.num;
//                     (<BloodUICompenent>this.ui).midNum = this.bloodLineMeshVo.midNum;
//                     (<BloodUICompenent>this.ui).colortype = this.bloodLineMeshVo.colortype;
//                 } else {
//                     this.ui.x = 10000
//                 }
//             }
//             if (this.bloodLineMeshVo.clear) {
//                 this.ui.parent.removeChild(this.ui);
//                 this._data = null;
//             }
//         }
//     }
// }
// export class BloodUIRenderComponent extends UIRenderComponent {
//     public constructor() {
//         super();
//     }
//     protected initData(): void {
//         this._uiList = new Array;
//         this.objData = new ObjData();
//         ProgrmaManager.getInstance().registe(BloodUIShader.BloodUIShader, new BloodUIShader)
//         this.shader = ProgrmaManager.getInstance().getProgram(BloodUIShader.BloodUIShader);
//         this.program = this.shader.program;
//         this.uiProLocation = Scene_data.context3D.getLocation(this.program, "ui")
//         this.ui2ProLocation = Scene_data.context3D.getLocation(this.program, "lifenum")
//     }
//     private nextTime: number = 0
//     public update(): void {
//         if (!this.visible || this._uiList.length == 0) {
//             return;
//         }
//         // //console.log(this._uiList.length);
//         Scene_data.context3D.setBlendParticleFactors(this.blenderMode);
//         Scene_data.context3D.setProgram(this.program);
//         if (this.nextTime < TimeUtil.getTimer() || this.renderData2.length != this._uiList.length * 4) {
//             if (this.renderData2.length != this._uiList.length * 4) {
//                 this.renderData2 = new Float32Array(this._uiList.length * 4);
//             }
//             for (var i: number = 0; i < this._uiList.length; i++) {
//                 var $bloodUICompenent: BloodUICompenent = <BloodUICompenent>this._uiList[i];
//                 var a: number = $bloodUICompenent.lifeNum / 100;
//                 var b: number = ($bloodUICompenent.colortype + 1) * 8 / 32;
//                 this.renderData2[i * 4 + 0] = a;
//                 this.renderData2[i * 4 + 1] = b;
//                 this.renderData2[i * 4 + 2] = $bloodUICompenent.midNum;
//                 this.renderData2[i * 4 + 3] = 0.8;
//             }
//             this.nextTime = TimeUtil.getTimer()
//         }
//         Scene_data.context3D.setVc4fvLocation(this.uiProLocation, this.renderData);
//         Scene_data.context3D.setVc4fvLocation(this.ui2ProLocation, this.renderData2);
//         Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
//         Scene_data.context3D.setVa(1, 3, this.objData.uvBuffer);
//         if (this.uiAtlas) {
//             Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this.uiAtlas.texture, 0);
//         }
//         Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
//         if (this.modelRenderList) {
//             for (var i: number = 0; i < this.modelRenderList.length; i++) {
//                 this.modelRenderList[i].update();
//             }
//         }
//     }
//     public creatBaseComponent($skinName: string): BloodUICompenent {
//         var ui: BloodUICompenent = new BloodUICompenent();
//         ui.tr.setRec(new UIRectangle(0, 0, 1, 1));
//         ui.width = 64;
//         ui.height = 10;
//         ui.uiRender = this;
//         ui.lifeNum = 100
//         return ui;
//     }
//     public makeRenderDataVc($vcId: number): void {
//         if (!this.renderData || (this.renderData && this.renderData.length != this._uiList.length * 4)) {
//             this.renderData = new Float32Array(this._uiList.length * 4);
//         }
//         if ($vcId == -1) {
//             for (var i: number = 0; this._uiList && i < this._uiList.length; i++) {
//                 this._uiList[i].vcId = i;
//                 this.renderData[i * 4 + 0] = this._uiList[i].renderData[0];
//                 this.renderData[i * 4 + 1] = this._uiList[i].renderData[1];
//                 this.renderData[i * 4 + 2] = this._uiList[i].renderData[2];
//                 this.renderData[i * 4 + 3] = this._uiList[i].renderData[3];
//             }
//         } else {
//             if ($vcId < this._uiList.length) {
//                 this.renderData[$vcId * 4 + 0] = this._uiList[$vcId].renderData[0];
//                 this.renderData[$vcId * 4 + 1] = this._uiList[$vcId].renderData[1];
//                 this.renderData[$vcId * 4 + 2] = this._uiList[$vcId].renderData[2];
//                 this.renderData[$vcId * 4 + 3] = this._uiList[$vcId].renderData[3];
//             }
//         }
//     }
// }
// export class BloodLineUIConatiner extends UIConatiner {
//     private _baseRender: BloodUIRenderComponent;
//     public constructor() {
//         super();
//         this.width = UIData.designWidth;
//         this.height = UIData.designHeight;
//         this._baseRender = new BloodUIRenderComponent();
//         this.addRender(this._baseRender);
//         this._baseRender.uiAtlas = new UIAtlas
//         this._baseRender.uiAtlas.configData = new Array;
//         this._uiItem = new Array();
//         this.loadBloodTexture()
//     }
//     private loadBloodTexture(): void {
//         TextureManager.getInstance().getTexture(Scene_data.fileRoot + "ui/load/blood.png", ($textureRes: TextureRes) => {
//             this._baseRender.uiAtlas.textureRes = $textureRes
//         });
//     }
//     protected _uiItem: Array<BloodDisp2DBaseText>;
//     public update(t: number): void {
//         if (this._baseRender.uiAtlas.textureRes) {
//             for (var i: number = 0; i < this._uiItem.length; i++) {
//                 if (this._uiItem[i].data) {
//                     this._uiItem[i].update();
//                 }
//             }
//         }
//     }
//     public removeChild($ui: UICompenent): void {
//         for (var i: number = 0; i < this._uiItem.length; i++) {
//             if (this._uiItem[i].ui == $ui) {
//                 this._uiItem.splice(i, 1);
//                 break;
//             }
//         }
//         super.removeChild($ui);
//     }
//     public clearOneTemp(): void {
//         while (this._uiItem.length > 25) {
//             this.removeChild(this._uiItem[0].ui)
//         }
//     }
//     public showTemp($data: any): void {
//         if (this._uiItem.length >= 40) {
//             //console.log("超过50。暂时设置不可再添加");
//             return
//         }
//         var $BloodDisp2DBaseText: BloodDisp2DBaseText = new BloodDisp2DBaseText;
//         $BloodDisp2DBaseText.parent = this._baseRender;
//         $BloodDisp2DBaseText.ui = <UICompenent>this._baseRender.creatBaseComponent("test");
//         $BloodDisp2DBaseText.data = $data;
//         this.addChild($BloodDisp2DBaseText.ui);
//         this._uiItem.push($BloodDisp2DBaseText);
//     }
//     //清理单元内的内容并需要将对象移出显示队例
//     public clearTemp($data: any): void {
//         for (var i: number = 0; i < this._uiItem.length; i++) {
//             if (this._uiItem[i].data == $data) {
//                 this._uiItem[i].data = null
//                 this.removeChild(this._uiItem[i].ui);
//                 break
//             }
//         }
//     }
// }
// }
(function (tl3d) {
    var CharTitleMeshVo = /** @class */ (function (_super) {
        __extends(CharTitleMeshVo, _super);
        function CharTitleMeshVo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CharTitleMeshVo.prototype.destory = function () {
            this.pos = null;
            this._num = null;
            this.clear = true;
        };
        Object.defineProperty(CharTitleMeshVo.prototype, "num", {
            get: function () {
                return this._num;
            },
            set: function (value) {
                this._num = value;
                this.needDraw = true;
            },
            enumerable: true,
            configurable: true
        });
        return CharTitleMeshVo;
    }(tl3d.baseMeshVo));
    tl3d.CharTitleMeshVo = CharTitleMeshVo;
    var CharNameMeshVo = /** @class */ (function (_super) {
        __extends(CharNameMeshVo, _super);
        function CharNameMeshVo() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.color = '#ffffff'; //字体颜色
            _this.scolor = ''; //描边颜色
            _this.size = 20; //字号大小
            return _this;
        }
        Object.defineProperty(CharNameMeshVo.prototype, "name", {
            get: function () {
                return this._name;
            },
            set: function (value) {
                this._name = value;
                this.needDraw = true;
            },
            enumerable: true,
            configurable: true
        });
        CharNameMeshVo.prototype.destory = function () {
            this.pos = null;
            this._name = null;
            this.needDraw = null;
            this.clear = true;
        };
        return CharNameMeshVo;
    }(tl3d.baseMeshVo));
    tl3d.CharNameMeshVo = CharNameMeshVo;
    var BloodLineMeshVo = /** @class */ (function (_super) {
        __extends(BloodLineMeshVo, _super);
        function BloodLineMeshVo() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.posx = -5;
            return _this;
        }
        BloodLineMeshVo.prototype.destory = function () {
            this.pos = null;
            this.num = null;
            this.colortype = null;
            // this.clear = true
        };
        return BloodLineMeshVo;
    }(tl3d.baseMeshVo));
    tl3d.BloodLineMeshVo = BloodLineMeshVo;
    var JumpTextMeshVo = /** @class */ (function (_super) {
        __extends(JumpTextMeshVo, _super);
        function JumpTextMeshVo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        JumpTextMeshVo.prototype.destory = function () {
            this.pos = null;
            this.clear = true;
        };
        return JumpTextMeshVo;
    }(tl3d.baseMeshVo));
    tl3d.JumpTextMeshVo = JumpTextMeshVo;
    var JumpTxtContianerPanel = /** @class */ (function (_super) {
        __extends(JumpTxtContianerPanel, _super);
        function JumpTxtContianerPanel($classVo, $rect, $num) {
            return _super.call(this, $classVo, $rect, $num) || this;
        }
        return JumpTxtContianerPanel;
    }(tl3d.Dis2DUIContianerPanel));
    tl3d.JumpTxtContianerPanel = JumpTxtContianerPanel;
    var BloodManager = /** @class */ (function () {
        function BloodManager() {
            this.uiContianerItem = new Array();
            // this._charTitleContianerPanel = new Dis2DUIContianerPanel(Pan3d.CharTitleUiVo, new Rectangle(0, 0, 131, 69), 10);
            this._charNameContianerPanel = new tl3d.Dis2DUIContianerPanel(tl3d.CharNameUiVo, new tl3d.Rectangle(0, 0, 256, 22), 10);
            this._jumpTxtContianerPanel = new tl3d.AlphaUiContianer(tl3d.TextJumpUiDrawAndRefreash, new tl3d.Rectangle(0, 0, 256, 64), 16);
            // this._expjumpTxtContianerPanel = new AlphaUiContianer(Pan3d.ExpTextJumpUiDrawAndRefreash, new Rectangle(0, 0, 512, 100), 5);
            // this._bloodLineUIConatiner = new Pan3d.BloodLineUIConatiner();
            // this.uiContianerItem.push(this._charTitleContianerPanel)
            // this.uiContianerItem.push(this._bloodLineUIConatiner);
            this.uiContianerItem.push(this._charNameContianerPanel);
            this.uiContianerItem.push(this._jumpTxtContianerPanel);
            // this.uiContianerItem.push(this._expjumpTxtContianerPanel);
            this.resize();
        }
        BloodManager.prototype.clearOneTemp = function () {
            for (var i = 0; i < this.uiContianerItem.length; i++) {
                this.uiContianerItem[i].clearOneTemp();
            }
        };
        // public getCharTitleMeshVo(value: number = 0): CharTitleMeshVo {
        //     var $vo: CharTitleMeshVo = new CharTitleMeshVo;
        //     $vo.num = value;
        //     $vo.pos = new Vector3D(0, 50, 0);
        //     this._charTitleContianerPanel.showTemp($vo);
        //     return $vo;
        // }
        BloodManager.prototype.getCharNameMeshVo = function (value) {
            if (value === void 0) { value = "测试名"; }
            var $vo = new CharNameMeshVo;
            $vo.name = value;
            $vo.pos = new tl3d.Vector3D(0, 50, 0);
            this._charNameContianerPanel.showTemp($vo);
            return $vo;
        };
        //获取mesh对象
        BloodManager.prototype.getBloodExtMeshVo = function () {
            return null;
        };
        //显示飘字
        BloodManager.prototype.showFlyText = function (jumpvo) {
        };
        // public getBloodLineMeshVo(): BloodLineMeshVo {
        //     var $vo: BloodLineMeshVo = new BloodLineMeshVo;
        //     $vo.num = 100;
        //     $vo.midNum = 0;
        //     $vo.colortype = 0
        //     $vo.pos = new Vector3D(0, 50, 0);
        //     // this._bloodLineUIConatiner.showTemp($vo);
        //     return $vo;
        // }
        // public clearBloodLineMeshVo($vo: BloodLineMeshVo) {
        //     // this._bloodLineUIConatiner.clearTemp($vo);
        // }
        BloodManager.prototype.setJumpNum = function ($textJumpUiVo) {
            // if (!$color) {
            //     $color = $num > 0 ? ArtFont.Green : ArtFont.Red
            // }
            // var $str: string = String($num)
            // if ($num > 0) {
            //     $str = "+" + $str
            // }
            // //console.log("---111");
            this._jumpTxtContianerPanel.showTemp($textJumpUiVo);
        };
        // public setExpJumpNum($textJumpUiVo: Pan3d.TextJumpUiVo): void {
        //     this._expjumpTxtContianerPanel.showTemp($textJumpUiVo);
        // }
        BloodManager.prototype.update = function () {
            for (var i = 0; i < this.uiContianerItem.length; i++) {
                this.uiContianerItem[i].update(0);
                for (var j = 0; j < this.uiContianerItem[i].renderList.length; j++) {
                    this.uiContianerItem[i].renderList[j].update();
                }
            }
        };
        BloodManager.prototype.resize = function () {
            this._jumpTxtContianerPanel.resize();
            for (var j = 0; j < this.uiContianerItem.length; j++) {
                this.uiContianerItem[j].resize();
            }
            tl3d.Scene_data.cam3D.needChange = true;
            //this.update();
        };
        return BloodManager;
    }());
    tl3d.BloodManager = BloodManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ColorTransition = /** @class */ (function () {
        function ColorTransition() {
            this._canvas = document.createElement("canvas");
            this._cxt = this._canvas.getContext("2d");
            this._gnt = this._cxt.createLinearGradient(0, 0, 128, 0);
            this._canvas.style.zIndex = "1";
            //document.body.appendChild(this._canvas);
        }
        ColorTransition.getInstance = function () {
            if (!this._instance) {
                this._instance = new ColorTransition();
            }
            return this._instance;
        };
        ColorTransition.prototype.getImageData = function ($data) {
            var length = $data.pos.length;
            var color = new tl3d.Vector3D();
            for (var i = 0; i < length; i++) {
                tl3d.Util.hexToArgb($data.color[i], false, color);
                this._gnt.addColorStop($data.pos[i] / 255, 'rgba(' + color.x + ',' + color.y + ',' + color.z + ',' + $data.alpha[i] + ')');
            }
            this._cxt.fillStyle = this._gnt;
            this._cxt.fillRect(0, 0, 128, 2);
            return this._cxt.getImageData(0, 0, 128, 2);
        };
        ColorTransition.prototype.getImageDataByVec = function ($data, $lenght) {
            var imgData = this._cxt.createImageData(64, 1);
            var index;
            var baseindex;
            for (var i = 0; i < 64; i++) {
                index = i * 4;
                baseindex = tl3d.Util.float2int(i / 64 * $lenght) * 4;
                imgData.data[index] = $data[baseindex];
                imgData.data[index + 1] = $data[baseindex + 1];
                imgData.data[index + 2] = $data[baseindex + 2];
                imgData.data[index + 3] = $data[baseindex + 3];
            }
            return imgData;
            //Scene_data.context3D.getTexture(imgData);
        };
        ColorTransition.prototype.setData = function () {
        };
        return ColorTransition;
    }());
    tl3d.ColorTransition = ColorTransition;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var GroupDataManager = /** @class */ (function (_super) {
        __extends(GroupDataManager, _super);
        function GroupDataManager(scene) {
            var _this = _super.call(this) || this;
            _this._loadDic = new Object;
            _this.scene = scene;
            return _this;
        }
        GroupDataManager.prototype.getGroupData = function ($url, $fun) {
            var _this = this;
            if (this._dic[$url]) {
                var gr = this._dic[$url];
                gr.useNum++;
                $fun(gr);
                return;
            }
            if (this._loadDic[$url]) {
                this._loadDic[$url].push($fun);
                return;
            }
            this._loadDic[$url] = new Array;
            this._loadDic[$url].push($fun);
            var group = new tl3d.GroupRes();
            group.load($url, function () {
                var ary = _this._loadDic[$url];
                for (var i = 0; i < ary.length; i++) {
                    var fun = ary[i];
                    fun(group);
                }
                _this._dic[$url] = group;
                delete _this._loadDic[$url];
                group.initReg();
            });
        };
        GroupDataManager.prototype.perLoadData = function ($url, $fun) {
            var _this = this;
            if (this._dic[$url]) {
                if ($fun) {
                    $fun();
                }
                return;
            }
            if (this._loadDic[$url]) {
                this._loadDic[$url].push($fun);
                return;
            }
            this._loadDic[$url] = new Array;
            this._loadDic[$url].push($fun);
            var group = new tl3d.GroupRes();
            group.scene = this.scene;
            group.load($url, function () {
                _this._dic[$url] = group;
                delete _this._loadDic[$url];
                group.initReg();
                if ($fun) {
                    $fun();
                }
            });
        };
        return GroupDataManager;
    }(tl3d.ResGC));
    tl3d.GroupDataManager = GroupDataManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MouseType = /** @class */ (function () {
        function MouseType() {
        }
        MouseType.MouseDown = "mousedown";
        MouseType.MouseUp = "mouseup";
        MouseType.MouseMove = "mousemove";
        MouseType.MouseClick = "mouseclick";
        MouseType.KeyDown = "keydown";
        MouseType.KeyUp = "keyup";
        MouseType.MouseWheel = "mousewheel";
        //static TouchMown = "panstart";   
        //static TouchMove = "panmove";
        //static TouchUp = "panend";
        //static TouchClick = "tap";
        MouseType.TouchStart = "touchstart";
        MouseType.TouchMove = "touchmove";
        MouseType.TouchEnd = "touchend";
        MouseType.TouchClick = "touchstart";
        return MouseType;
    }());
    tl3d.MouseType = MouseType;
    var KeyControl = /** @class */ (function () {
        function KeyControl() {
            var _this = this;
            this._isUpData = true;
            this.speedNum = 10;
            this._keyDic = new Object;
            this._lostMousePos = new tl3d.Object3D;
            this._lastFousce = new tl3d.Object3D;
            this._isMouseDown = false;
            setInterval(function () { _this.upData(); }, 1000 / 60);
        }
        Object.defineProperty(KeyControl, "instance", {
            get: function () {
                if (!this._instance) {
                    this._instance = new KeyControl();
                }
                return this._instance;
            },
            enumerable: true,
            configurable: true
        });
        KeyControl.getInstance = function () {
            if (!this._instance) {
                this._instance = new KeyControl();
            }
            return this._instance;
        };
        KeyControl.prototype.init = function () {
            document.addEventListener(MouseType.MouseDown, this.onMouseDown);
            document.addEventListener(MouseType.MouseUp, this.onMouseUp);
            document.addEventListener(MouseType.MouseMove, this.onMouseMove);
            document.addEventListener(MouseType.KeyDown, this.onKeyDown);
            document.addEventListener(MouseType.KeyUp, this.onKeyUp);
        };
        KeyControl.prototype.clearAllEvet = function () {
            document.removeEventListener(MouseType.MouseDown, this.onMouseDown);
            document.removeEventListener(MouseType.MouseUp, this.onMouseUp);
            document.removeEventListener(MouseType.MouseMove, this.onMouseMove);
            document.removeEventListener(MouseType.KeyDown, this.onKeyDown);
            document.removeEventListener(MouseType.KeyUp, this.onKeyUp);
        };
        KeyControl.prototype.clearMouseEvent = function () {
            document.removeEventListener(MouseType.MouseDown, this.onMouseDown);
            document.removeEventListener(MouseType.MouseUp, this.onMouseUp);
            document.removeEventListener(MouseType.MouseMove, this.onMouseMove);
            this._isUpData = false;
        };
        KeyControl.prototype.onMouseMove = function ($evt) {
            var $keyControl = KeyControl.instance;
            var $nowPos = new tl3d.Object3D;
            $nowPos.x = $evt.pageX;
            $nowPos.y = $evt.pageY;
            if ($keyControl._isMouseDown) {
                tl3d.Scene_data.cam3D.rotationY = $keyControl._lastFousce.rotationY - ($nowPos.x - $keyControl._lostMousePos.x) / 10;
                tl3d.Scene_data.cam3D.rotationX = $keyControl._lastFousce.rotationX - ($nowPos.y - $keyControl._lostMousePos.y) / 10;
            }
        };
        KeyControl.prototype.onMouseDown = function ($evt) {
            var $keyControl = KeyControl.instance;
            $keyControl._isMouseDown = true;
            $keyControl._lostMousePos.x = $evt.pageX;
            $keyControl._lostMousePos.y = $evt.pageY;
            $keyControl._lastFousce.rotationX = tl3d.Scene_data.cam3D.rotationX;
            $keyControl._lastFousce.rotationY = tl3d.Scene_data.cam3D.rotationY;
        };
        KeyControl.prototype.onMouseUp = function ($evt) {
            var $keyControl = KeyControl.instance;
            $keyControl._isMouseDown = false;
            // FpsMc.tipStr = $evt.layerX + ":" + $evt.layerY;
        };
        KeyControl.prototype.upData = function () {
            if (!this._isUpData) {
                return;
            }
            var _keyDic = this._keyDic;
            if (_keyDic[65]) { //A
                this.tureLeft();
            }
            if (_keyDic[83]) { //S
                // FpsMc.tipStr = "S"
                this.tureDown();
            }
            if (_keyDic[68]) { //D
                this.tureRight();
            }
            if (_keyDic[87]) { //W
                this.tureUp();
            }
            if (_keyDic[81]) { //Q
                tl3d.Scene_data.cam3D.y -= this.speedNum;
            }
            if (_keyDic[69]) { //E
                tl3d.Scene_data.cam3D.y += this.speedNum;
            }
            tl3d.MathClass.MathCam(tl3d.Scene_data.cam3D);
        };
        KeyControl.prototype.tureLeft = function () {
            var $p = new tl3d.Vector3D(-this.speedNum, 0, 0, 1); //dis
            var $m = new tl3d.Matrix3D;
            this.mathFocus3D($p);
        };
        KeyControl.prototype.tureRight = function () {
            var $p = new tl3d.Vector3D(this.speedNum, 0, 0, 1); //dis
            this.mathFocus3D($p);
        };
        KeyControl.prototype.tureUp = function () {
            var $p = new tl3d.Vector3D(0, 0, this.speedNum, 1); //dis
            this.mathFocus3D($p);
        };
        KeyControl.prototype.tureDown = function () {
            var $p = new tl3d.Vector3D(0, 0, -this.speedNum, 1); //dis
            this.mathFocus3D($p);
        };
        KeyControl.prototype.mathFocus3D = function ($p) {
            var $m = new tl3d.Matrix3D;
            $m.prependRotation(-tl3d.Scene_data.cam3D.rotationY, tl3d.Vector3D.Y_AXIS);
            $m.prependRotation(-tl3d.Scene_data.cam3D.rotationX, tl3d.Vector3D.X_AXIS);
            $p = $m.transformVector($p);
            tl3d.Scene_data.cam3D.x += $p.x;
            tl3d.Scene_data.cam3D.y += $p.y;
            tl3d.Scene_data.cam3D.z += $p.z;
        };
        KeyControl.prototype.onKeyDown = function ($evt) {
            var _keyDic = KeyControl.instance._keyDic;
            _keyDic[$evt.keyCode] = true;
            if ($evt.keyCode == 0) {
            }
        };
        KeyControl.prototype.onKeyUp = function ($evt) {
            var _keyDic = KeyControl.instance._keyDic;
            _keyDic[$evt.keyCode] = false;
        };
        return KeyControl;
    }());
    tl3d.KeyControl = KeyControl;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var KeyboardType = /** @class */ (function () {
        function KeyboardType() {
        }
        KeyboardType.A = 65;
        KeyboardType.B = 66;
        KeyboardType.C = 67;
        KeyboardType.D = 68;
        KeyboardType.E = 69;
        KeyboardType.F = 70;
        KeyboardType.G = 71;
        KeyboardType.H = 72;
        KeyboardType.I = 73;
        KeyboardType.J = 74;
        KeyboardType.K = 75;
        KeyboardType.L = 76;
        KeyboardType.M = 77;
        KeyboardType.N = 78;
        KeyboardType.O = 79;
        KeyboardType.P = 80;
        KeyboardType.Q = 81;
        KeyboardType.R = 82;
        KeyboardType.S = 83;
        KeyboardType.T = 84;
        KeyboardType.U = 85;
        KeyboardType.V = 86;
        KeyboardType.W = 87;
        KeyboardType.X = 88;
        KeyboardType.Y = 89;
        KeyboardType.Z = 90;
        KeyboardType.Left = 37;
        KeyboardType.Up = 38;
        KeyboardType.Right = 39;
        KeyboardType.Down = 40;
        KeyboardType.Delete = 46;
        KeyboardType.F1 = 112;
        KeyboardType.F2 = 113;
        return KeyboardType;
    }());
    tl3d.KeyboardType = KeyboardType;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TextRegVo = /** @class */ (function () {
        function TextRegVo() {
        }
        return TextRegVo;
    }());
    tl3d.TextRegVo = TextRegVo;
    var TextRegExp = /** @class */ (function () {
        function TextRegExp() {
        }
        TextRegExp.pushStr = function ($str) {
            this.item = new Array();
            var patt1 = /\[\]|\[[A-Za-z0-9]{6}\]/g;
            var arr;
            while ((arr = patt1.exec($str)) != null) {
                // //console.log(arr.index + "-" + patt1.lastIndex + ":" + arr);
                var $vo = new TextRegVo;
                $vo.begin = arr.index;
                $vo.end = patt1.lastIndex;
                $vo.color = arr.toString();
                $vo.color = $vo.color.replace("[", "");
                $vo.color = $vo.color.replace("]", "");
                //    //console.log($baseColor)
                if ($vo.color.length < 5) {
                    $vo.color = TextRegExp.defaultColor;
                }
                else {
                    $vo.color = "#" + $vo.color;
                }
                this.item.push($vo);
            }
        };
        /**
         * 将字符串中所有颜色替换为#号 并返回新的字符串
         * @param
         */
        TextRegExp.pushStrCopy = function ($str) {
            this.item = new Array();
            var patt1 = /\[\]|\[[A-Za-z0-9]{6}\]/g;
            var arr;
            var newstr = $str;
            while ((arr = patt1.exec($str)) != null) {
                // //console.log(arr.index + "-" + patt1.lastIndex + ":" + arr);
                var $vo = new TextRegVo;
                $vo.begin = arr.index;
                $vo.end = patt1.lastIndex;
                $vo.color = arr.toString();
                newstr = newstr.replace($vo.color, "#");
                $vo.color = $vo.color.replace("[", "");
                $vo.color = $vo.color.replace("]", "");
                //    //console.log($baseColor)
                if ($vo.color.length < 5) {
                    $vo.color = TextRegExp.defaultColor;
                }
                else {
                    $str.replace("[" + $vo.color + "]", "#");
                    $vo.color = "#" + $vo.color;
                }
                this.item.push($vo);
            }
            return newstr;
        };
        TextRegExp.isColor = function ($index, $ctx) {
            for (var i = 0; i < this.item.length; i++) {
                if ($index >= this.item[i].begin && $index < this.item[i].end) {
                    if ($ctx) {
                        $ctx.fillStyle = this.item[i].color;
                    }
                    return true;
                }
            }
            return false;
        };
        TextRegExp.getTextMetrics = function ($ctx, text) {
            if (!text) {
                text = "";
            }
            this.pushStr(text);
            var words = text;
            var line = "";
            var ty = 0;
            for (var n = 0; n < words.length; n++) {
                if (this.isColor(n, $ctx)) {
                    continue;
                }
                line += words[n];
            }
            var metrics = $ctx.measureText(line);
            return metrics;
        };
        TextRegExp.getTextOnlyTxt = function ($ctx, text) {
            if (!text) {
                text = "";
            }
            this.pushStr(text);
            var words = text;
            var line = "";
            var ty = 0;
            for (var n = 0; n < words.length; n++) {
                if (this.isColor(n, $ctx)) {
                    continue;
                }
                line += words[n];
            }
            return line;
        };
        TextRegExp.getNextWords = function ($str, indx) {
            var $iconId = -1;
            if ($str[indx] == "/" && $str.length > (indx + 2)) {
                var tempA = $str[indx + 0] + $str[indx + 1] + $str[indx + 2];
                for (var i = 0; i < tl3d.UIData.faceItem.length; i++) {
                    if (tl3d.UIData.faceItem[i] == tempA) {
                        return i + 1;
                    }
                }
            }
            return $iconId;
        };
        /**
         * 逐字符写入文本。兼容表情。返回行数
         * @param
         * @param text
         * @param baseColor
         * @param x
         * @param y
         * @param maxWidth
         * @param lineHeight
         * @param fontsize
         * @param
         * @param
         * @param
         */
        TextRegExp.wrapText = function ($ctx, text, baseColor, x, y, maxWidth, lineHeight, fontsize, $filterColor, $filterWidth, $gapScale) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (maxWidth === void 0) { maxWidth = 500; }
            if (lineHeight === void 0) { lineHeight = 10; }
            if (fontsize === void 0) { fontsize = 12; }
            if ($filterColor === void 0) { $filterColor = ""; }
            if ($filterWidth === void 0) { $filterWidth = 2; }
            if ($gapScale === void 0) { $gapScale = 1.0; }
            TextRegExp.defaultColor = baseColor;
            if (maxWidth > 300) {
            }
            maxWidth = maxWidth * 0.98; //特殊缩小
            if ($filterColor != "") {
                if ($filterColor.indexOf("[") != -1) { //[00ff00]
                    $filterColor = "#" + $filterColor.substr(1, 6);
                }
                $ctx.strokeStyle = $filterColor;
                $ctx.lineWidth = $filterWidth;
            }
            this.pushStr(text);
            var words = text;
            var line = "";
            var ty = 0; //特殊加上偏移， 还待测试调整
            var $lineNum = 1; //行数
            for (var n = 0; words && n < words.length; n++) {
                if (this.isColor(n, $ctx)) {
                    continue;
                }
                var metrics = $ctx.measureText(line.replace("\n", ""));
                var $faceId = this.getNextWords(words, n);
                if ($faceId == -1) {
                    //绘制文本
                    if (metrics.width > maxWidth || words[n] == "\n") {
                        //换行
                        ty += lineHeight;
                        line = "";
                        $lineNum++;
                        if (words[n] != "\n") {
                            if ($filterColor != "") {
                                $ctx.strokeText(words[n], x, y + ty);
                            }
                            $ctx.fillText(words[n], x, y + ty);
                        }
                    }
                    else {
                        //当前行
                        if ($filterColor != "") {
                            $ctx.strokeText(words[n], x + metrics.width * $gapScale, y + ty);
                        }
                        $ctx.fillText(words[n], x + metrics.width * $gapScale, y + ty);
                    }
                    if (words[n] != "\n") {
                        line += words[n];
                    }
                }
                else {
                    //绘制表情
                    var faceSize = fontsize * 1.4;
                    var $rect = new tl3d.Rectangle(x + metrics.width * 1.0 + 0, y + ty - faceSize / 10, faceSize, faceSize);
                    if (metrics.width > maxWidth) {
                        ty += lineHeight;
                        line = "";
                        $lineNum++;
                        $rect = new tl3d.Rectangle(x + 0, y + ty - faceSize / 10, faceSize, faceSize);
                    }
                    this.drawFaceIcon($ctx, $rect, $faceId);
                    n = n + 2;
                    line += "脸1";
                }
            }
            return $lineNum;
        };
        /**
         * 逐字符写入文本。兼容表情。返回行数 竖着写
         * @param
         * @param text
         * @param baseColor
         * @param x
         * @param y
         * @param maxWidth
         * @param lineHeight
         * @param fontsize
         * @param
         * @param
         * @param
         */
        TextRegExp.wrapTextVertical = function ($ctx, text, baseColor, x, y, maxWidth, lineWidth, fontsize, $filterColor, $filterWidth, $gapScale) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            if (maxWidth === void 0) { maxWidth = 500; }
            if (lineWidth === void 0) { lineWidth = 10; }
            if (fontsize === void 0) { fontsize = 12; }
            if ($filterColor === void 0) { $filterColor = ""; }
            if ($filterWidth === void 0) { $filterWidth = 4; }
            if ($gapScale === void 0) { $gapScale = 1.0; }
            TextRegExp.defaultColor = baseColor;
            if ($filterColor != "") {
                if ($filterColor.indexOf("[") != -1) { //[00ff00]
                    $filterColor = "#" + $filterColor.substr(1, 6);
                }
                $ctx.strokeStyle = $filterColor;
                $ctx.lineWidth = $filterWidth;
            }
            this.pushStr(text);
            var words = text;
            var line = "";
            var tx = 2; //特殊加上偏移， 还待测试调整
            var $lineNum = 1; //行数
            var ty = 0;
            for (var n = 0; words && n < words.length; n++) {
                if (this.isColor(n, $ctx)) {
                    continue;
                }
                // var metrics: TextMetrics = $ctx.measureText(line.replace("\n", ""));
                var $faceId = this.getNextWords(words, n);
                if ($faceId == -1) {
                    //绘制文本
                    if (ty > maxWidth || words[n] == "\n") {
                        //换行
                        tx += lineWidth;
                        line = "";
                        ty = 0;
                        if (words[n] != "\n") {
                            if ($filterColor != "") {
                                $ctx.strokeText(words[n], x + tx, ty);
                            }
                            $ctx.fillText(words[n], x + tx, ty);
                        }
                        $lineNum++;
                    }
                    else {
                        //当前行
                        ty += fontsize + 5;
                        if ($filterColor != "") {
                            $ctx.strokeText(words[n], x + tx, ty);
                        }
                        $ctx.fillText(words[n], x + tx, ty);
                    }
                    line += words[n];
                    // } else {
                    //     //绘制表情
                    //     var faceSize: number = fontsize * 1.4
                    //     var $rect: Rectangle = new Rectangle(x + metrics.width * 1.0 + 0, y + ty - faceSize / 10, faceSize, faceSize);
                    //     if (metrics.width > maxWidth) {
                    //         ty += lineHeight;
                    //         line = "";
                    //         $lineNum++
                    //         $rect = new Rectangle(x + 0, y + ty - faceSize / 10, faceSize, faceSize);
                    //     }
                    //     this.drawFaceIcon($ctx, $rect, $faceId)
                    //     n = n + 2;
                    //     line += "脸1"
                }
            }
            return $lineNum;
        };
        /**
         * 按行写入字符。暂不兼容表情。返回数组行宽行高
         * @param
         * @param text
         * @param baseColor
         * @param
         * @param
         * @param
         * @param lineHeight
         * @param fontsize
         * @param
         * @param
         * @param
         */
        TextRegExp.drawText = function ($ctx, text, baseColor, $maxWidth, lineHeight, fontsize) {
            if ($maxWidth === void 0) { $maxWidth = 500; }
            if (lineHeight === void 0) { lineHeight = 10; }
            if (fontsize === void 0) { fontsize = 12; }
            TextRegExp.defaultColor = baseColor;
            var newtext = this.pushStrCopy(text);
            var totalWidth = 0;
            var totalHeight = 0;
            var words = text;
            var line = "";
            var lastposx = 0;
            var textcellAry = new Array;
            var art = newtext.split("#");
            for (var i = 0; i < art.length; i++) {
                var nstr = art[i];
                if (nstr != "") {
                    $ctx.fillStyle = i > 0 ? this.item[i - 1].color : baseColor;
                    for (var n = 0; n < nstr.length; n++) {
                        if (nstr[n] == "\n") {
                            var aaa = new TextCell(line, totalHeight, $ctx.measureText(line).width, $ctx.fillStyle, $maxWidth);
                            textcellAry.push(aaa);
                            lastposx = 0;
                            line = "";
                            totalHeight += lineHeight;
                        }
                        else {
                            var testLine = line + nstr[n];
                            var metrics = $ctx.measureText(testLine);
                            var testWidth = metrics.width + lastposx;
                            totalWidth = Math.min($maxWidth, testWidth);
                            if (testWidth > $maxWidth) {
                                var aaa = new TextCell(line, totalHeight, $ctx.measureText(line).width, $ctx.fillStyle, $maxWidth);
                                textcellAry.push(aaa);
                                line = nstr[n] + "";
                                totalHeight += lineHeight;
                                lastposx = 0;
                            }
                            else {
                                line = testLine;
                            }
                        }
                    }
                    var cwidth = $ctx.measureText(line).width;
                    lastposx += cwidth;
                    var aaa = new TextCell(line, totalHeight, $ctx.measureText(line).width, $ctx.fillStyle, $maxWidth);
                    textcellAry.push(aaa);
                    line = "";
                }
            }
            var lastposy = -10000;
            var start_point;
            for (var k = 0; k < textcellAry.length; k++) {
                if (lastposy != textcellAry[k].posy) {
                    lastposy = textcellAry[k].posy;
                    start_point = this.getStartPoint(textcellAry[k], textcellAry);
                    start_point = Math.max(start_point, 0);
                }
                $ctx.fillStyle = textcellAry[k].color;
                $ctx.fillText(textcellAry[k].str, start_point, lastposy);
                start_point += textcellAry[k].width;
            }
            //计算高度
            totalHeight = totalHeight + lineHeight;
            return [totalWidth, totalHeight];
        };
        TextRegExp.getStartPoint = function (vo, $textcellary) {
            var ary = new Array;
            for (var k = 0; k < $textcellary.length; k++) {
                var element = $textcellary[k];
                if (vo.posy == element.posy) {
                    ary.push(element);
                }
            }
            var totalwidth = 0;
            for (var x = 0; x < ary.length; x++) {
                totalwidth += ary[x].width;
            }
            return (vo.maxwidth - totalwidth) / 2;
        };
        TextRegExp.drawFaceIcon = function (ctx, $rect, $faceId) {
            tl3d.UiDraw.cxtDrawImg(ctx, "F_FACE_" + $faceId, $rect, tl3d.UIData.publicUi);
        };
        TextRegExp.defaultColor = "#000000";
        return TextRegExp;
    }());
    tl3d.TextRegExp = TextRegExp;
    var TextCell = /** @class */ (function () {
        function TextCell($str, $posy, $width, $color, $maxWidth) {
            this.str = $str;
            this.posy = $posy;
            this.width = $width;
            this.color = $color;
            this.maxwidth = $maxWidth;
        }
        return TextCell;
    }());
    tl3d.TextCell = TextCell;
    var LabelTextFont = /** @class */ (function () {
        function LabelTextFont() {
        }
        /*
        *写入单行颜色字体，字号,对齐，基础颜色 并上传显卡
        */
        LabelTextFont.writeSingleLabel = function ($uiAtlas, $key, $str, fontsize, $align, $baseColor, $filterColor, $ty, $filterWidth, $bolder) {
            if (fontsize === void 0) { fontsize = 12; }
            if ($align === void 0) { $align = tl3d.TextAlign.CENTER; }
            if ($baseColor === void 0) { $baseColor = "#ffffff"; }
            if ($filterColor === void 0) { $filterColor = ""; }
            if ($ty === void 0) { $ty = 0; }
            if ($filterWidth === void 0) { $filterWidth = 4; }
            if ($bolder === void 0) { $bolder = true; }
            if ($baseColor.indexOf("[") != -1) { //[00ff00]
                $baseColor = "#" + $baseColor.substr(1, 6);
            }
            var $uiRect = $uiAtlas.getRec($key);
            var $ctx = tl3d.UIManager.getInstance().getContext2D($uiRect.pixelWitdh, $uiRect.pixelHeight, false);
            $ctx.fillStyle = $baseColor;
            $ctx.font = ($bolder ? "bolder " : "") + " " + fontsize + "px " + tl3d.UIData.font;
            var $textMetrics = TextRegExp.getTextMetrics($ctx, $str);
            var $tx = 0;
            if ($align == tl3d.TextAlign.CENTER) {
                $tx = ($uiRect.pixelWitdh - $textMetrics.width) / 2;
            }
            else if ($align == tl3d.TextAlign.RIGHT) {
                $tx = ($uiRect.pixelWitdh - $textMetrics.width);
            }
            TextRegExp.wrapText($ctx, $str, $baseColor, $tx, $ty, $uiRect.pixelWitdh - (fontsize / 2), 20, fontsize, $filterColor, $filterWidth);
            $uiAtlas.updateCtx($ctx, $uiRect.pixelX, $uiRect.pixelY);
            return $textMetrics.width;
        };
        /*
        *写入多行颜色字体，字号,对齐，基础颜色 并上传显卡
        */
        LabelTextFont.writeTextLabel = function ($uiAtlas, $key, $str, fontsize, $align, $maxWidth, $baseColor, $filterColor, $ty, $filterWidth, $bolder) {
            if (fontsize === void 0) { fontsize = 12; }
            if ($align === void 0) { $align = "center"; }
            if ($maxWidth === void 0) { $maxWidth = 500; }
            if ($baseColor === void 0) { $baseColor = "#ffffff"; }
            if ($filterColor === void 0) { $filterColor = ""; }
            if ($ty === void 0) { $ty = 0; }
            if ($filterWidth === void 0) { $filterWidth = 4; }
            if ($bolder === void 0) { $bolder = true; }
            if ($baseColor.indexOf("[") != -1) { //[00ff00]
                $baseColor = "#" + $baseColor.substr(1, 6);
            }
            var hight = fontsize + 4;
            var $uiRect = $uiAtlas.getRec($key);
            var $ctx = tl3d.UIManager.getInstance().getContext2D($uiRect.pixelWitdh, $uiRect.pixelHeight, false);
            $ctx.fillStyle = $baseColor;
            $ctx.textAlign = $align;
            $ctx.font = ($bolder ? "bolder " : "") + " " + fontsize + "px " + tl3d.UIData.font;
            var $textMetrics = TextRegExp.getTextMetrics($ctx, $str);
            // var $tx: number = 0
            // if ($align == TextAlign.CENTER) {
            //     $tx = ($uiRect.pixelWitdh - $textMetrics.width) / 2;
            // } else if ($align == TextAlign.RIGHT) {
            //     $tx = ($uiRect.pixelWitdh - $textMetrics.width);
            // }
            var linenum = TextRegExp.wrapText($ctx, $str, $baseColor, 0, $ty, $maxWidth, hight, fontsize, $filterColor, $filterWidth);
            $uiAtlas.updateCtx($ctx, $uiRect.pixelX, $uiRect.pixelY);
            return [$textMetrics.width, linenum * hight];
        };
        /*
         *将单行颜色字写到CTX中
         *
         */
        LabelTextFont.writeSingleLabelToCtx = function ($ctx, $str, fontsize, $tx, $ty, $align, $baseColor, $filterColor, $bolder) {
            if (fontsize === void 0) { fontsize = 12; }
            if ($tx === void 0) { $tx = 0; }
            if ($ty === void 0) { $ty = 0; }
            if ($align === void 0) { $align = tl3d.TextAlign.CENTER; }
            if ($baseColor === void 0) { $baseColor = "#ffffff"; }
            if ($filterColor === void 0) { $filterColor = ""; }
            if ($bolder === void 0) { $bolder = true; }
            if ($baseColor.indexOf("[") != -1) { //[00ff00]
                $baseColor = "#" + $baseColor.substr(1, 6);
            }
            $ctx.fillStyle = $baseColor;
            $ctx.font = ($bolder ? "bolder " : "") + " " + fontsize + "px " + tl3d.UIData.font;
            var $textMetrics = TextRegExp.getTextMetrics($ctx, $str);
            if ($align == tl3d.TextAlign.CENTER) {
                // $tx -= $textMetrics.width / 2;
                $tx += ($ctx.canvas.width - $textMetrics.width) / 2;
            }
            else if ($align == tl3d.TextAlign.RIGHT) {
                // $tx -= $textMetrics.width;
                $tx += ($ctx.canvas.width - $textMetrics.width);
            }
            TextRegExp.wrapText($ctx, $str, $baseColor, $tx, $ty, 9999, 20, fontsize, $filterColor);
            return $textMetrics.width;
        };
        /*
         *将单行颜色字写到CTX中
         *
         */
        LabelTextFont.writeSingleLabelToCtxByVertical = function ($ctx, $str, fontsize, $tx, $ty, $baseColor, $filterColor, $bolder) {
            if (fontsize === void 0) { fontsize = 12; }
            if ($tx === void 0) { $tx = 0; }
            if ($ty === void 0) { $ty = 0; }
            if ($baseColor === void 0) { $baseColor = "#ffffff"; }
            if ($filterColor === void 0) { $filterColor = ""; }
            if ($bolder === void 0) { $bolder = true; }
            if ($baseColor.indexOf("[") != -1) { //[00ff00]
                $baseColor = "#" + $baseColor.substr(1, 6);
            }
            $ctx.fillStyle = $baseColor;
            $ctx.font = ($bolder ? "bolder " : "") + " " + fontsize + "px " + tl3d.UIData.font;
            TextRegExp.wrapTextVertical($ctx, $str, $baseColor, $tx, $ty, 9999, 20, fontsize, $filterColor);
        };
        /*
         *将单行颜色字写到CTX中
         * $tx 为对齐点的坐标
         */
        LabelTextFont.writeSingleLabelToCtxSetAnchor = function ($ctx, $str, fontsize, $tx, $ty, $align, $baseColor, $filterColor, $bolder) {
            if (fontsize === void 0) { fontsize = 12; }
            if ($tx === void 0) { $tx = 0; }
            if ($ty === void 0) { $ty = 0; }
            if ($align === void 0) { $align = tl3d.TextAlign.CENTER; }
            if ($baseColor === void 0) { $baseColor = "#ffffff"; }
            if ($filterColor === void 0) { $filterColor = ""; }
            if ($bolder === void 0) { $bolder = true; }
            if ($baseColor.indexOf("[") != -1) { //[00ff00]
                $baseColor = "#" + $baseColor.substr(1, 6);
            }
            $ctx.fillStyle = $baseColor;
            $ctx.font = ($bolder ? "bolder " : "") + " " + fontsize + "px " + tl3d.UIData.font;
            var $textMetrics = TextRegExp.getTextMetrics($ctx, $str);
            if ($align == tl3d.TextAlign.CENTER) {
                $tx -= $textMetrics.width / 2;
            }
            else if ($align == tl3d.TextAlign.RIGHT) {
                $tx -= $textMetrics.width;
            }
            TextRegExp.wrapText($ctx, $str, $baseColor, $tx, $ty, 9999, 20, fontsize, $filterColor);
            return $textMetrics.width;
        };
        /**
         * 整行写入文本 不兼容处理颜色
         * @param $x 文本写入时光标所在x位置
         * @param $y 文本写入时光标所在y位置
         * @param fontsize
         * @param fontColor
         * @param bolder
         * @param  $textAlign 对齐方式
         * @readme 如果需要居中对齐显示，则光标所在位置需要传入中心点坐标，对齐方式也需要传入center
         */
        LabelTextFont.writeText = function ($uiAtlas, $key, $x, $y, $str, fontsize, fontColor, $maxWidth, bolder, $textAlign) {
            if ($maxWidth === void 0) { $maxWidth = 0; }
            if (bolder === void 0) { bolder = false; }
            if ($textAlign === void 0) { $textAlign = "left"; }
            if (fontColor.indexOf("[") != -1) { //[00ff00]
                fontColor = "#" + fontColor.substr(1, 6);
            }
            var totalwidthAndheight = [10, 10];
            var uiRect = $uiAtlas.getRec($key);
            var ctx = tl3d.UIManager.getInstance().getContext2D(uiRect.pixelWitdh, uiRect.pixelHeight, false);
            ctx.fillStyle = fontColor;
            ctx.font = (bolder ? "bolder " : "") + fontsize + "px " + tl3d.UIData.font;
            ctx.textAlign = $textAlign;
            var $xpos = this.getTextxpos($textAlign, ctx);
            totalwidthAndheight = this.wrapText(ctx, $str, $x, $y, $maxWidth, fontsize + 5);
            $uiAtlas.updateCtx(ctx, uiRect.pixelX, uiRect.pixelY);
            return totalwidthAndheight;
        };
        /**
         * 按行写入文本 带解析颜色。但只能居中对齐
         */
        LabelTextFont.writeTextAutoCenterByAnchor = function ($uiAtlas, $key, $str, fontsize, fontColor, $maxWidth, bolder, $filterColor) {
            if (bolder === void 0) { bolder = true; }
            if ($filterColor === void 0) { $filterColor = ""; }
            if (fontColor.indexOf("[") != -1) { //[00ff00]
                fontColor = "#" + fontColor.substr(1, 6);
            }
            var uiRect = $uiAtlas.getRec($key);
            var ctx = tl3d.UIManager.getInstance().getContext2D(uiRect.pixelWitdh, uiRect.pixelHeight, false);
            ctx.fillStyle = fontColor;
            ctx.font = (bolder ? "bolder " : "") + fontsize + "px " + tl3d.UIData.font;
            ctx.textAlign = "left";
            var totalwidthAndheight = TextRegExp.drawText(ctx, $str, fontColor, $maxWidth, fontsize + 5, fontsize);
            $uiAtlas.updateCtx(ctx, uiRect.pixelX, uiRect.pixelY);
            return totalwidthAndheight;
        };
        /*
        *写入普通文字,字数不满足换行时，自动纵向居中。
        */
        LabelTextFont.writeTextAutoVerticalCenter = function ($uiAtlas, $key, $str, fontsize, fontColor, $maxWidth, $filterColor, bolder) {
            if ($filterColor === void 0) { $filterColor = ""; }
            if (bolder === void 0) { bolder = false; }
            if (fontColor.indexOf("[") != -1) { //[00ff00]
                fontColor = "#" + fontColor.substr(1, 6);
            }
            var uiRect = $uiAtlas.getRec($key);
            var ctx = tl3d.UIManager.getInstance().getContext2D(uiRect.pixelWitdh, uiRect.pixelHeight, false);
            ctx.fillStyle = fontColor;
            ctx.font = (bolder ? "bolder " : "") + fontsize + "px " + tl3d.UIData.font;
            var $x = 0;
            var $y = 0;
            var $xpos = this.getTextxpos(tl3d.TextAlign.LEFT, ctx);
            if ($maxWidth > 0) {
                if (!this.isNewline(ctx, $str, $maxWidth)) {
                    $y = (uiRect.pixelHeight / 2) - (fontsize / 2);
                }
                // this.wrapText(ctx, $str, $x, $y, $maxWidth, fontsize + 3);
                TextRegExp.wrapText(ctx, $str, fontColor, $x, $y, $maxWidth, fontsize + 3, fontsize, $filterColor);
            }
            $uiAtlas.updateCtx(ctx, uiRect.pixelX, uiRect.pixelY);
        };
        /*
        *写入普通文字,字数不满足换行时，自动居中。
        */
        LabelTextFont.writeTextAutoCenter = function ($uiAtlas, $key, $str, fontsize, fontColor, $maxWidth, bolder) {
            if (bolder === void 0) { bolder = false; }
            if (fontColor.indexOf("[") != -1) { //[00ff00]
                fontColor = "#" + fontColor.substr(1, 6);
            }
            var uiRect = $uiAtlas.getRec($key);
            var ctx = tl3d.UIManager.getInstance().getContext2D(uiRect.pixelWitdh, uiRect.pixelHeight, false);
            ctx.fillStyle = fontColor;
            ctx.font = (bolder ? "bolder " : "") + fontsize + "px " + tl3d.UIData.font;
            var $x = 0;
            var $y = 0;
            var $xpos = this.getTextxpos(tl3d.TextAlign.LEFT, ctx);
            if ($maxWidth > 0) {
                if (!this.isNewline(ctx, $str, $maxWidth)) {
                    var metrics = ctx.measureText($str);
                    $y = (uiRect.pixelHeight / 2) - (fontsize / 2);
                    $x = (uiRect.pixelWitdh / 2) - (metrics.width / 2);
                }
                // this.wrapText(ctx, $str, $x, $y, $maxWidth, fontsize + 3);
                TextRegExp.wrapText(ctx, $str, fontColor, $x, $y, $maxWidth, fontsize + 3);
            }
            $uiAtlas.updateCtx(ctx, uiRect.pixelX, uiRect.pixelY);
        };
        LabelTextFont.isNewline = function (ctx, $text, $maxWidth) {
            var words = $text;
            var metrics = ctx.measureText(words);
            var testWidth = metrics.width;
            if (testWidth > $maxWidth) {
                return true;
            }
            return false;
        };
        // static writeTextToCtx(ctx: CanvasRenderingContext2D,
        //     $x: number, $y: number,
        //     $str: string, fontsize: number, fontColor: string, bolder: boolean = false, $maxWidth: number = 0): void {
        //     ctx.textBaseline = TextAlign.MIDDLE;
        //     ctx.textAlign = TextAlign.CENTER;
        //     ctx.fillStyle = fontColor;
        //     ctx.font = "bolder " + fontsize + "px " + UIData.font;
        //     var $xpos: number = this.getTextxpos(TextAlign.CENTER, ctx);
        //     if ($maxWidth > 0) {
        //         this.wrapText(ctx, $str, $x, $y, $maxWidth, fontsize + 3);
        //     } else {
        //         ctx.fillText($str, $x + $xpos, $y);
        //     }
        // }
        LabelTextFont.getTextxpos = function ($textAlign, $ctx) {
            var $xpos = 0;
            if ($textAlign == tl3d.TextAlign.LEFT) {
                $xpos = 0;
            }
            else if ($textAlign == tl3d.TextAlign.RIGHT) {
                $xpos = $ctx.canvas.width;
            }
            else if ($textAlign == tl3d.TextAlign.CENTER) {
                $xpos = $ctx.canvas.width / 2;
            }
            return $xpos;
        };
        LabelTextFont.wrapText = function ($ctx, text, $tx, $ty, maxWidth, $th) {
            var totalWidth = 0;
            var totalHeight = $ty;
            var words = text;
            var line = "";
            for (var n = 0; n < words.length; n++) {
                if (words[n] == "\n") {
                    $ctx.fillText(line, $tx, totalHeight);
                    line = "";
                    totalHeight += $th;
                }
                else {
                    var testLine = line + words[n];
                    var metrics = $ctx.measureText(testLine);
                    var testWidth = metrics.width;
                    totalWidth = Math.max(totalWidth, testWidth);
                    if (testWidth > maxWidth) {
                        $ctx.fillText(line, $tx, totalHeight);
                        line = words[n] + "";
                        totalHeight += $th;
                    }
                    else {
                        line = testLine;
                    }
                }
            }
            $ctx.fillText(line, $tx, totalHeight);
            //计算高度
            totalHeight = totalHeight - $ty + $th;
            return [totalWidth, totalHeight];
        };
        /**已弃用 请使用clearUI */
        LabelTextFont.clearLabel = function ($uiAtlas, $key) {
            var $uiRect = $uiAtlas.getRec($key);
            var $ctx = tl3d.UIManager.getInstance().getContext2D($uiRect.pixelWitdh, $uiRect.pixelHeight, false);
            $uiAtlas.updateCtx($ctx, $uiRect.pixelX, $uiRect.pixelY);
        };
        return LabelTextFont;
    }());
    tl3d.LabelTextFont = LabelTextFont;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var LightProbeManager = /** @class */ (function () {
        function LightProbeManager() {
            this._defaultVec = new Array;
            var ary = [0.4444730390920146, -0.3834955622240026, -0.33124467509627725, 0.09365654209093091,
                -0.05673310882817577, 0.2120523322966496, 0.02945768486978205, -0.04965996229802928, -0.1136529129285836];
            for (var i = 0; i < 9; i++) {
                this._defaultVec.push(new tl3d.Vector3D(ary[i], ary[i], ary[i]));
            }
        }
        LightProbeManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new LightProbeManager();
            }
            return this._instance;
        };
        LightProbeManager.prototype.setLightProbeData = function ($arr) {
            this._dataAry = $arr;
        };
        LightProbeManager.prototype.clear = function () {
            this._dataAry = null;
        };
        LightProbeManager.prototype.getData = function ($pos) {
            if (!this._dataAry) {
                return this._defaultVec;
            }
            for (var i = 0; i < this._dataAry.length; i++) {
                var lightArea = this._dataAry[i];
                if (this.testPoint(lightArea, $pos)) {
                    var baseV3d = lightArea.postion;
                    var bp = $pos.subtract(baseV3d);
                    return this.getResultData(lightArea.posItem, tl3d.Util.float2int(bp.x / lightArea.betweenNum), tl3d.Util.float2int(bp.z / lightArea.betweenNum), tl3d.Util.float2int(bp.y / lightArea.betweenNum), lightArea.betweenNum, bp);
                }
            }
            return this._defaultVec;
        };
        LightProbeManager.prototype.testPoint = function (lightArea, $pos) {
            var xNum = (lightArea.cubeVec.x - 1) * lightArea.betweenNum;
            var yNum = (lightArea.cubeVec.y - 1) * lightArea.betweenNum;
            var zNum = (lightArea.cubeVec.z - 1) * lightArea.betweenNum;
            var cx = $pos.x - lightArea.postion.x;
            var cy = $pos.y - lightArea.postion.y;
            var cz = $pos.z - lightArea.postion.z;
            if (cx >= 0 && cx < xNum && cy >= 0 && cy < yNum && cz >= 0 && cz < zNum) {
                return true;
            }
            else {
                return false;
            }
        };
        LightProbeManager.prototype.getResultData = function (ary, x, z, y, bNum, $pos) {
            var posAry = new Array;
            posAry.push(new PosItem(ary[x][z][y], $pos));
            posAry.push(new PosItem(ary[x + 1][z][y], $pos));
            posAry.push(new PosItem(ary[x][z + 1][y], $pos));
            posAry.push(new PosItem(ary[x + 1][z + 1][y], $pos));
            posAry.push(new PosItem(ary[x][z][y + 1], $pos));
            posAry.push(new PosItem(ary[x + 1][z][y + 1], $pos));
            posAry.push(new PosItem(ary[x][z + 1][y + 1], $pos));
            posAry.push(new PosItem(ary[x + 1][z + 1][y + 1], $pos));
            var allDis = 0;
            for (var i = 0; i < posAry.length; i++) {
                allDis += posAry[i].dis;
            }
            for (i = 0; i < posAry.length; i++) {
                posAry[i].setBais(allDis);
            }
            var allBais = 0;
            for (i = 0; i < posAry.length; i++) {
                allBais += posAry[i].bais;
            }
            for (i = 0; i < posAry.length; i++) {
                posAry[i].bais = posAry[i].bais / allBais;
            }
            var arr = new Array;
            for (i = 0; i < 9; i++) {
                var v3d = new tl3d.Vector3D;
                for (var j = 0; j < posAry.length; j++) {
                    var tempV3d = new tl3d.Vector3D(posAry[j].vecNum[i].x, posAry[j].vecNum[i].y, posAry[j].vecNum[i].z);
                    tempV3d.scaleBy(posAry[j].bais);
                    v3d = v3d.add(tempV3d);
                }
                arr.push(v3d);
            }
            return arr;
        };
        return LightProbeManager;
    }());
    tl3d.LightProbeManager = LightProbeManager;
    var PosItem = /** @class */ (function () {
        function PosItem(basePos, centerPos) {
            this.pos = new tl3d.Vector3D(basePos.x, basePos.y, basePos.z);
            this.vecNum = basePos.resultSHVec;
            this.dis = tl3d.Vector3D.distance(this.pos, centerPos);
        }
        PosItem.prototype.setBais = function (allDis) {
            this.bais = (this.dis / allDis) * (this.dis / allDis);
            this.bais = 1 / this.bais;
        };
        return PosItem;
    }());
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var LoadManager = /** @class */ (function () {
        function LoadManager() {
            this._loadThreadList = new Array;
            this._waitLoadList = new Array;
            for (var i = 0; i < 5; i++) {
                this._loadThreadList.push(new LoaderThread());
            }
        }
        LoadManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new LoadManager();
            }
            return this._instance;
        };
        LoadManager.prototype.getVersion = function (vkey) {
            vkey = tl3d.Scene_data.fileSub + vkey;
            if (this._versions) { //有版本管理
                return this._versions[vkey] || vkey;
            }
            return vkey; //没版本管理
        };
        LoadManager.prototype.load = function ($url, $type, $fun, $info, $progressFun) {
            if ($info === void 0) { $info = null; }
            if ($progressFun === void 0) { $progressFun = null; }
            //todo
            if (tl3d.Scene_data.fileRoot != "") { //原生版本优化
                $url = $url.replace(tl3d.Scene_data.fileRoot, "");
                $url = tl3d.Scene_data.fileRoot + this.getVersion($url);
            }
            var loadInfo = new LoadInfo($url, $type, $fun, $info, $progressFun);
            for (var i = 0; i < this._loadThreadList.length; i++) {
                if (this._loadThreadList[i].idle) {
                    this._loadThreadList[i].load(loadInfo);
                    return;
                }
            }
            this._waitLoadList.push(loadInfo);
        };
        LoadManager.prototype.loadWaitList = function () {
            if (this._waitLoadList.length <= 0) {
                return;
            }
            for (var i = 0; i < this._loadThreadList.length; i++) {
                if (this._loadThreadList[i].idle) {
                    this._loadThreadList[i].load(this._waitLoadList.shift());
                    return;
                }
            }
        };
        LoadManager.BYTE_TYPE = "BYTE_TYPE";
        LoadManager.IMG_TYPE = "IMG_TYPE";
        LoadManager.XML_TYPE = "XML_TYPE";
        return LoadManager;
    }());
    tl3d.LoadManager = LoadManager;
    var LoaderThread = /** @class */ (function () {
        function LoaderThread() {
            var _this = this;
            this._xhr = new XMLHttpRequest();
            this._xhr.onreadystatechange = function () {
                if (!_this._xhr || _this._xhr.readyState !== 4) {
                    return;
                }
                if (_this._xhr.status !== 0 && _this._xhr.status !== 200) {
                    _this.loadError();
                    return;
                }
                _this.loadByteXML();
            };
            this._xhr.onprogress = function (e) {
                if (_this._loadInfo.progressFun) {
                    _this._loadInfo.progressFun(e.loaded / e.total);
                }
            };
            this._xhr.onerror = function () {
                _this.loadError();
            };
            this._img = new Image();
            this._img.onload = function () {
                _this.loadImg();
            };
            this._img.onerror = function () {
                _this.loadError();
            };
            this.idle = true;
        }
        LoaderThread.prototype.load = function (loadInfo) {
            this._loadInfo = loadInfo;
            this.idle = false;
            this._url = loadInfo.url;
            if (this._loadInfo.type == LoadManager.BYTE_TYPE) {
                this._xhr.open("GET", loadInfo.vurl, true);
                this._xhr.responseType = "arraybuffer";
                this._xhr.send();
            }
            else if (this._loadInfo.type == LoadManager.XML_TYPE) {
                this._xhr.open("GET", loadInfo.vurl, true);
                this._xhr.responseType = "text";
                this._xhr.send();
            }
            else if (this._loadInfo.type == LoadManager.IMG_TYPE) {
                if (this._img.url == loadInfo.vurl) { //路径相同
                    this.loadImg();
                }
                else { //执行加载
                    this._img.url = loadInfo.vurl;
                    this._img.src = loadInfo.vurl;
                }
            }
        };
        LoaderThread.prototype.loadError = function () {
            this.idle = true;
            this._loadInfo = null;
            LoadManager.getInstance().loadWaitList();
        };
        LoaderThread.prototype.loadByteXML = function () {
            // if(this.idle){
            //     //console.log("加载完成*****************************"+this._url );
            // }
            if (this._loadInfo.info) {
                this._loadInfo.fun(this._xhr.response, this._loadInfo.info);
            }
            else {
                this._loadInfo.fun(this._xhr.response);
            }
            this.idle = true;
            this._loadInfo = null;
            LoadManager.getInstance().loadWaitList();
        };
        LoaderThread.prototype.loadByteImg = function () {
            this._img.src = 'data:image/png;base64,' + tl3d.Base64.encode(this._xhr.response);
        };
        LoaderThread.prototype.loadImg = function () {
            if (this._loadInfo.info) {
                this._loadInfo.fun(this._img, this._loadInfo.info);
            }
            else {
                this._loadInfo.fun(this._img);
            }
            this.idle = true;
            this._loadInfo = null;
            LoadManager.getInstance().loadWaitList();
        };
        return LoaderThread;
    }());
    tl3d.LoaderThread = LoaderThread;
    var LoadInfo = /** @class */ (function () {
        function LoadInfo($url, $type, $fun, $info, $progressFun) {
            if ($info === void 0) { $info = null; }
            if ($progressFun === void 0) { $progressFun = null; }
            this.url = $url;
            this.type = $type;
            this.fun = $fun;
            this.info = $info;
            this.progressFun = $progressFun;
        }
        Object.defineProperty(LoadInfo.prototype, "vurl", {
            get: function () {
                return this.url;
            },
            enumerable: true,
            configurable: true
        });
        return LoadInfo;
    }());
    tl3d.LoadInfo = LoadInfo;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var MeshDataManager = /** @class */ (function (_super) {
        __extends(MeshDataManager, _super);
        function MeshDataManager() {
            var _this = _super.call(this) || this;
            _this._loadDic = new Object();
            return _this;
        }
        MeshDataManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new MeshDataManager();
            }
            return this._instance;
        };
        MeshDataManager.prototype.getMeshData = function ($url, $fun, $batchNum) {
            var _this = this;
            if ($batchNum === void 0) { $batchNum = 1; }
            if (this._dic[$url] && this._dic[$url].ready) {
                $fun(this._dic[$url]);
                this._dic[$url].useNum++;
                return;
            }
            if (this._loadDic[$url]) {
                this._loadDic[$url].push($fun);
                return;
            }
            this._loadDic[$url] = new Array;
            this._loadDic[$url].push($fun);
            this.loadRoleRes(tl3d.Scene_data.fileRoot + $url, function ($roleRes) {
                _this.roleResCom($roleRes, $fun);
            }, $batchNum);
        };
        //加载角色
        MeshDataManager.prototype.loadRoleRes = function (url, $fun, $meshBatchNum) {
            var roleRes = new tl3d.RoleRes();
            roleRes.meshBatchNum = $meshBatchNum;
            roleRes.load(url, function () {
                $fun(roleRes);
            });
        };
        MeshDataManager.prototype.roleResCom = function ($roleRes, $fun) {
            var url = $roleRes.roleUrl;
            var skinMesh = this._dic[url];
            skinMesh.loadMaterial();
            //skinMesh.loadParticle();
            skinMesh.setAction($roleRes.actionAry, url);
            skinMesh.url = url;
            if ($roleRes.ambientLightColor) {
                skinMesh.lightData = [[$roleRes.ambientLightColor.x, $roleRes.ambientLightColor.y, $roleRes.ambientLightColor.z],
                    [$roleRes.nrmDircet.x, $roleRes.nrmDircet.y, $roleRes.nrmDircet.z],
                    [$roleRes.sunLigthColor.x, $roleRes.sunLigthColor.y, $roleRes.sunLigthColor.z]];
            }
            for (var i = 0; i < this._loadDic[url].length; i++) {
                this._loadDic[url][i](skinMesh);
                skinMesh.useNum++;
            }
            delete this._loadDic[url];
            skinMesh.ready = true;
            //this._dic[$roleRes.roleUrl] = skinMesh;
            //$fun(skinMesh);
            //var meshUrl: string = $roleRes.roleUrl;
            //MeshDataManager.getInstance().getMeshData(meshUrl, ($skinMesh: SkinMesh) => {
            //    if ($batchNum != 1) {
            //        $roleRes.type = 1;
            //    }
            //    for (var key in this._animDic) {
            //        this.processAnimByMesh(this._animDic[key]);
            //    }
            //    $skinMesh.loadMaterial(($m: Material) => { this.loadMaterialCom($m) });
            //    $skinMesh.loadParticle(this);
            //    this.fileScale = $skinMesh.fileScale;
            //}, $batchNum);
            //var actionAry: Array<string> = this._roleRes.actionAry;
            //for (var i: number = 0; i < actionAry.length; i++) {
            //    this.addAction(actionAry[i], this._roleRes.roleUrl + actionAry[i]);
            //}
        };
        MeshDataManager.prototype.readData = function (byte, $batchNum, $url, $version) {
            var $skinMesh = new tl3d.SkinMesh();
            $skinMesh.fileScale = byte.readFloat();
            if ($version >= 19) {
                $skinMesh.tittleHeight = byte.readFloat();
            }
            else {
                $skinMesh.tittleHeight = 50;
            }
            $skinMesh.hitBox = new tl3d.Vector2D(20, 20);
            if ($version >= 23) {
                $skinMesh.hitBox.x = byte.readFloat();
                $skinMesh.hitBox.y = byte.readFloat();
            }
            $skinMesh.makeHitBoxItem();
            var meshNum = byte.readInt();
            var allParticleDic = new Object;
            for (var i = 0; i < meshNum; i++) {
                var meshData = new tl3d.MeshData;
                if ($version >= 35) {
                    meshData.bindPosAry = this.readBindPosByte(byte);
                    meshData.getBindPosMatrix();
                }
                if ($version >= 21) {
                    this.readMesh2OneBuffer(byte, meshData);
                }
                else {
                    tl3d.BaseRes.readFloatTwoByte(byte, meshData.vertices);
                    tl3d.BaseRes.readFloatTwoByte(byte, meshData.tangents);
                    tl3d.BaseRes.readFloatTwoByte(byte, meshData.bitangents);
                    tl3d.BaseRes.readFloatTwoByte(byte, meshData.normals);
                    tl3d.BaseRes.readFloatTwoByte(byte, meshData.uvs);
                    tl3d.BaseRes.readIntForOneByte(byte, meshData.boneIDAry);
                    tl3d.BaseRes.readFloatOneByte(byte, meshData.boneWeightAry);
                    tl3d.BaseRes.readIntForTwoByte(byte, meshData.indexs);
                    tl3d.BaseRes.readIntForTwoByte(byte, meshData.boneNewIDAry);
                    this.uploadMesh(meshData);
                }
                meshData.treNum = meshData.indexs.length;
                // if ($batchNum != 1) {
                //     this.cloneMeshData(meshData, $batchNum);
                // }
                meshData.materialUrl = byte.readUTF();
                meshData.materialParamData = tl3d.BaseRes.readMaterialParamData(byte);
                var particleNum = byte.readInt();
                for (var j = 0; j < particleNum; j++) {
                    var bindParticle = new tl3d.BindParticle(byte.readUTF(), byte.readUTF());
                    meshData.particleAry.push(bindParticle);
                    allParticleDic[bindParticle.url] = true;
                }
                $skinMesh.addMesh(meshData);
            }
            for (var key in allParticleDic) {
                tl3d.ParticleManager.getInstance().registerUrl(key);
            }
            $skinMesh.allParticleDic = allParticleDic;
            if ($version < 35) { //多个MESH出错后情况
                var bindPosAry = this.readBindPosByte(byte);
                for (var w = 0; w < $skinMesh.meshAry.length; w++) {
                    $skinMesh.meshAry[w].bindPosAry = bindPosAry;
                    $skinMesh.meshAry[w].getBindPosMatrix();
                }
            }
            var sokcetLenght = byte.readInt();
            $skinMesh.boneSocketDic = new Object();
            for (var j = 0; j < sokcetLenght; j++) {
                var boneData = new tl3d.BoneSocketData();
                boneData.name = byte.readUTF();
                boneData.boneName = byte.readUTF();
                boneData.index = byte.readInt();
                boneData.x = byte.readFloat();
                boneData.y = byte.readFloat();
                boneData.z = byte.readFloat();
                boneData.rotationX = byte.readFloat();
                boneData.rotationY = byte.readFloat();
                boneData.rotationZ = byte.readFloat();
                $skinMesh.boneSocketDic[boneData.name] = boneData;
            }
            this._dic[$url] = $skinMesh;
            return $skinMesh;
        };
        MeshDataManager.prototype.readBindPosByte = function (byte) {
            var bindPosLength = byte.readInt();
            var bindPosAry = new Array;
            for (var j = 0; j < bindPosLength; j++) {
                var ary = new Array(byte.readFloat(), byte.readFloat(), byte.readFloat(), byte.readFloat(), byte.readFloat(), byte.readFloat());
                bindPosAry.push(ary);
            }
            return bindPosAry;
        };
        MeshDataManager.prototype.readMesh2OneBuffer = function (byte, meshData) {
            var len = byte.readInt();
            var typeItem = new Array;
            var dataWidth = 0;
            for (var i = 0; i < 5; i++) {
                var tf = byte.readBoolean();
                typeItem.push(tf);
                if (tf) {
                    if (i == 1) {
                        dataWidth += 2;
                    }
                    else {
                        dataWidth += 3;
                    }
                }
            }
            dataWidth += 8;
            len *= dataWidth * 4;
            var uvsOffsets = 3; // 1
            var normalsOffsets = uvsOffsets + 2; // 2
            var tangentsOffsets = normalsOffsets + 3; //3
            var bitangentsOffsets = tangentsOffsets + 3; //4
            var boneIDOffsets;
            if (typeItem[2]) { //normal
                if (typeItem[4]) {
                    boneIDOffsets = bitangentsOffsets + 3;
                }
                else {
                    boneIDOffsets = normalsOffsets + 3;
                }
            }
            else {
                boneIDOffsets = uvsOffsets + 2;
            }
            var boneWeightOffsets = boneIDOffsets + 4;
            var arybuff = new ArrayBuffer(len);
            var data = new DataView(arybuff);
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 3, 0, dataWidth); //vertices
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 2, uvsOffsets, dataWidth); //uvs
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 3, normalsOffsets, dataWidth); //normals
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 3, tangentsOffsets, dataWidth); //tangents
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 3, bitangentsOffsets, dataWidth); //bitangents
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 4, boneIDOffsets, dataWidth, 2); //boneIDAry
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 4, boneWeightOffsets, dataWidth, 1); //boneWeightAry
            // BaseRes.readFloatTwoByte(byte, meshData.vertices);
            // BaseRes.readFloatTwoByte(byte, meshData.uvs);
            // BaseRes.readFloatTwoByte(byte, meshData.normals);
            // BaseRes.readFloatTwoByte(byte, meshData.tangents);
            // BaseRes.readFloatTwoByte(byte, meshData.bitangents);
            // BaseRes.readIntForOneByte(byte, meshData.boneIDAry);
            // BaseRes.readFloatOneByte(byte, meshData.boneWeightAry);
            tl3d.BaseRes.readIntForTwoByte(byte, meshData.indexs);
            tl3d.BaseRes.readIntForTwoByte(byte, meshData.boneNewIDAry);
            meshData.compressBuffer = true;
            meshData.uvsOffsets = uvsOffsets * 4;
            meshData.normalsOffsets = normalsOffsets * 4;
            meshData.tangentsOffsets = tangentsOffsets * 4;
            meshData.bitangentsOffsets = bitangentsOffsets * 4;
            meshData.boneIDOffsets = boneIDOffsets * 4;
            meshData.boneWeightOffsets = boneWeightOffsets * 4;
            meshData.stride = dataWidth * 4;
            meshData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3DArrayBuffer(arybuff);
            meshData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(meshData.indexs);
        };
        MeshDataManager.prototype.cloneMeshData = function (meshData, num) {
            var vertices = meshData.vertices;
            var normals = meshData.normals;
            var uvs = meshData.uvs;
            var bonetIDAry = meshData.boneIDAry;
            var boneWeightAry = meshData.boneWeightAry;
            var indexs = meshData.indexs;
            meshData.vertices = new Array;
            meshData.normals = new Array;
            meshData.uvs = new Array;
            meshData.boneIDAry = new Array;
            meshData.boneWeightAry = new Array;
            meshData.indexs = new Array;
            var vesNum = vertices.length / 3;
            for (var i = 0; i < num; i++) {
                meshData.vertices = meshData.vertices.concat(vertices);
                meshData.normals = meshData.normals.concat(normals);
                meshData.boneIDAry = meshData.boneIDAry.concat(bonetIDAry);
                meshData.boneWeightAry = meshData.boneWeightAry.concat(boneWeightAry);
                for (var j = 0; j < uvs.length; j += 2) {
                    meshData.uvs.push(uvs[j], uvs[j + 1], i);
                }
                for (var j = 0; j < indexs.length; j++) {
                    meshData.indexs.push(indexs[j] + i * vesNum);
                }
            }
            meshData.treNum = meshData.indexs.length;
        };
        MeshDataManager.prototype.uploadMesh = function ($mesh) {
            $mesh.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.vertices);
            $mesh.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.uvs);
            $mesh.boneIdBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.boneIDAry);
            $mesh.boneWeightBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.boneWeightAry);
            $mesh.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D($mesh.indexs);
        };
        MeshDataManager.prototype.uploadPbrMesh = function ($mesh, $useNormal) {
            $mesh.normalsBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.normals);
            if ($useNormal) {
                $mesh.tangentBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.tangents);
                $mesh.bitangentBuffer = tl3d.Scene_data.context3D.uploadBuff3D($mesh.bitangents);
            }
        };
        MeshDataManager.prototype.preLoad = function ($url) {
            this.getMeshData($url, function ($skinMesh) {
                $skinMesh.loadMaterial();
            });
        };
        return MeshDataManager;
    }(tl3d.ResGC));
    tl3d.MeshDataManager = MeshDataManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ObjDataManager = /** @class */ (function (_super) {
        __extends(ObjDataManager, _super);
        function ObjDataManager() {
            var _this = 
            //this._dic = new Object();
            _super.call(this) || this;
            _this._loadList = new Object();
            return _this;
        }
        ObjDataManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new ObjDataManager();
            }
            return this._instance;
        };
        ObjDataManager.prototype.getObjData = function ($url, $fun) {
            var _this = this;
            if (this._dic[$url]) {
                $fun(this._dic[$url]);
                this._dic[$url].useNum++;
                return;
            }
            var ary;
            if (!this._loadList[$url]) {
                this._loadList[$url] = new Array;
                tl3d.LoadManager.getInstance().load($url, tl3d.LoadManager.BYTE_TYPE, function ($byte) {
                    _this.loadObjCom($byte, $url);
                });
            }
            ary = this._loadList[$url];
            ary.push($fun);
        };
        ObjDataManager.prototype.registerUrl = function ($url) {
            if (this._dic[$url]) {
                this._dic[$url].useNum++;
            }
        };
        ObjDataManager.prototype.releaseUrl = function ($url) {
            if (this._dic[$url]) {
                this._dic[$url].clearUseNum();
            }
        };
        ObjDataManager.prototype.readFloatNrm = function (byte, vertices) {
            var verLength = byte.readInt();
            if (verLength > 0) {
                for (var i = 0; i < verLength; i++) {
                    vertices.push(byte.readFloat());
                }
            }
        };
        ObjDataManager.prototype.readcollisionItem = function (byte, $objData) {
            //将碰撞体都写入对象的OBJ对象中
            var $len = byte.readInt();
            if ($len > 0) {
                $objData.collision = new tl3d.CollisionItemVo();
                $objData.collision.collisionItem = new Array;
                for (var i = 0; i < $len; i++) {
                    var $xmlcollisionVo = JSON.parse(byte.readUTF());
                    var $collisionVo = new tl3d.CollisionVo();
                    $collisionVo.scaleX = $xmlcollisionVo.scale_x;
                    $collisionVo.scaleY = $xmlcollisionVo.scale_y;
                    $collisionVo.scaleZ = $xmlcollisionVo.scale_z;
                    $collisionVo.x = $xmlcollisionVo.x;
                    $collisionVo.y = $xmlcollisionVo.y;
                    $collisionVo.z = $xmlcollisionVo.z;
                    $collisionVo.rotationX = $xmlcollisionVo.rotationX;
                    $collisionVo.rotationY = $xmlcollisionVo.rotationY;
                    $collisionVo.rotationZ = $xmlcollisionVo.rotationZ;
                    $collisionVo.scaleX = this.getFloadNum($collisionVo.scaleX);
                    $collisionVo.scaleY = this.getFloadNum($collisionVo.scaleY);
                    $collisionVo.scaleZ = this.getFloadNum($collisionVo.scaleZ);
                    $collisionVo.rotationX = this.getFloadNum($collisionVo.rotationX);
                    $collisionVo.rotationY = this.getFloadNum($collisionVo.rotationY);
                    $collisionVo.rotationZ = this.getFloadNum($collisionVo.rotationZ);
                    $collisionVo.type = $xmlcollisionVo.type;
                    $collisionVo.data = $xmlcollisionVo.data;
                    $objData.collision.collisionItem.push($collisionVo);
                }
            }
        };
        ObjDataManager.prototype.getFloadNum = function (value) {
            return Math.floor(value * 1000) / 1000;
        };
        ObjDataManager.prototype.loadObjCom = function ($byte, $url) {
            if (this._dic[$url]) {
                return;
            }
            ////console.log($objData);
            var $objData = new tl3d.ObjData();
            var byte = new tl3d.TLByteArray($byte);
            var version = byte.readInt();
            var str = byte.readUTF();
            if (version >= 20) {
                this.readObj2OneBuffer(byte, $objData);
                if (version >= 37 && byte.position < byte.length) { //加上碰撞体
                    this.readcollisionItem(byte, $objData);
                }
            }
            else {
                tl3d.BaseRes.readFloatTwoByte(byte, $objData.vertices);
                tl3d.BaseRes.readFloatTwoByte(byte, $objData.uvs);
                tl3d.BaseRes.readFloatOneByte(byte, $objData.lightuvs);
                tl3d.BaseRes.readFloatTwoByte(byte, $objData.normals);
                tl3d.BaseRes.readIntForTwoByte(byte, $objData.indexs);
                tl3d.BaseRes.readFloatTwoByte(byte, $objData.tangents);
                tl3d.BaseRes.readFloatTwoByte(byte, $objData.bitangents);
                $objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3D($objData.vertices);
                $objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D($objData.uvs);
                $objData.lightUvBuffer = tl3d.Scene_data.context3D.uploadBuff3D($objData.lightuvs);
                $objData.normalsBuffer = tl3d.Scene_data.context3D.uploadBuff3D($objData.normals);
            }
            $objData.treNum = $objData.indexs.length;
            $objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D($objData.indexs);
            this._dic[$url] = $objData;
            var ary = this._loadList[$url];
            if (ary) {
                for (var i = 0; i < ary.length; i++) {
                    ary[i]($objData);
                }
                delete this._loadList[$url];
            }
            return $objData;
        };
        ObjDataManager.prototype.readObj2OneBuffer = function (byte, $objData) {
            var typeItem = new Array;
            var len;
            var typeItem = new Array;
            var dataWidth = 0;
            for (var i = 0; i < 6; i++) {
                var tf = byte.readBoolean();
                typeItem.push(tf);
                if (tf) {
                    switch (i) {
                        case 1: //uv
                            dataWidth += 2;
                            break;
                        case 2: //lightuv
                            dataWidth += 2;
                            break;
                        default:
                            dataWidth += 3;
                            break;
                    }
                }
            }
            len = byte.readFloat();
            var baseLenght = len;
            len *= dataWidth * 4;
            var arybuff = new ArrayBuffer(len);
            var data = new DataView(arybuff);
            var uvsOffsets = 3;
            var lightuvsOffsets = uvsOffsets + 2;
            var normalsOffsets = typeItem[2] ? (lightuvsOffsets + 2) : (uvsOffsets + 2);
            var tangentsOffsets = normalsOffsets + 3;
            var bitangentsOffsets = tangentsOffsets + 3;
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 3, 0, dataWidth); //vertices
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 2, uvsOffsets, dataWidth); //uvs
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 2, lightuvsOffsets, dataWidth, 1); //lightuvs
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 3, normalsOffsets, dataWidth); //normals
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 3, tangentsOffsets, dataWidth); //tangents
            tl3d.BaseRes.readBytes2ArrayBuffer(byte, data, 3, bitangentsOffsets, dataWidth); //bitangents
            // BaseRes.readFloatTwoByte(byte, $objData.vertices);
            // BaseRes.readFloatTwoByte(byte, $objData.uvs);
            // BaseRes.readLightUvForByte(byte, $objData.lightuvs);
            // BaseRes.readFloatTwoByte(byte, $objData.normals);
            // BaseRes.readFloatTwoByte(byte, $objData.tangents);
            // BaseRes.readFloatTwoByte(byte, $objData.bitangents);
            tl3d.BaseRes.readIntForTwoByte(byte, $objData.indexs);
            // var dataAry: Array<number> = new Array;
            // for (var i: number = 0; i < baseLenght; i++) {
            //     dataAry.push($objData.vertices[i * 3]);
            //     dataAry.push($objData.vertices[i * 3 + 1]);
            //     dataAry.push($objData.vertices[i * 3 + 2]);
            //     dataAry.push($objData.uvs[i * 2]);
            //     dataAry.push($objData.uvs[i * 2 + 1]);
            //     dataAry.push($objData.lightuvs[i * 2]);
            //     dataAry.push($objData.lightuvs[i * 2 + 1]);
            // }
            ////console.log(dataAry);
            // $objData.vertexBuffer = Scene_data.context3D.uploadBuff3D($objData.vertices);
            // $objData.uvBuffer = Scene_data.context3D.uploadBuff3D($objData.uvs);
            // $objData.lightUvBuffer = Scene_data.context3D.uploadBuff3D($objData.lightuvs);
            // $objData.normalsBuffer = Scene_data.context3D.uploadBuff3D($objData.normals);
            $objData.vertexBuffer = tl3d.Scene_data.context3D.uploadBuff3DArrayBuffer(arybuff);
            $objData.compressBuffer = true;
            $objData.uvsOffsets = uvsOffsets * 4;
            $objData.lightuvsOffsets = lightuvsOffsets * 4;
            $objData.normalsOffsets = normalsOffsets * 4;
            $objData.tangentsOffsets = tangentsOffsets * 4;
            $objData.bitangentsOffsets = bitangentsOffsets * 4;
            $objData.stride = dataWidth * 4;
        };
        ObjDataManager.prototype.creatTBNBuffer = function ($objData) {
            $objData.tangentBuffer = tl3d.Scene_data.context3D.uploadBuff3D($objData.tangents);
            $objData.bitangentBuffer = tl3d.Scene_data.context3D.uploadBuff3D($objData.bitangents);
        };
        return ObjDataManager;
    }(tl3d.ResGC));
    tl3d.ObjDataManager = ObjDataManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SceneResManager = /** @class */ (function (_super) {
        __extends(SceneResManager, _super);
        function SceneResManager() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SceneResManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SceneResManager();
            }
            return this._instance;
        };
        //加载场景
        SceneResManager.prototype.loadSceneRes = function ($url, $completeFun, $progressFun, $readDataFun) {
            var sceneRes;
            if (this._dic[$url]) {
                sceneRes = this._dic[$url];
            }
            else {
                sceneRes = new tl3d.SceneRes();
                this._dic[$url] = sceneRes;
            }
            sceneRes.load($url, $completeFun, $progressFun, $readDataFun);
            this.clearSceneUse(sceneRes);
            return sceneRes;
        };
        //获取场景资源对象
        SceneResManager.prototype.getRes = function ($url) {
            return this._dic[$url];
        };
        //通过id清理引用
        SceneResManager.prototype.clearSceneUseById = function (id) {
            var sceneRes = this._dic[id];
            if (sceneRes) {
                sceneRes.clearUseNum();
            }
        };
        //清理场景使用
        SceneResManager.prototype.clearSceneUse = function (curRes) {
            for (var key in this._dic) {
                var rc = this._dic[key];
                if (rc.useNum > 0 && rc != curRes) {
                    rc.useNum = 0;
                }
            }
            curRes.useNum = 1;
        };
        return SceneResManager;
    }(tl3d.ResGC));
    tl3d.SceneResManager = SceneResManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var TimeUtil = /** @class */ (function () {
        function TimeUtil() {
        }
        TimeUtil.getTimer = function (startTime) {
            if (startTime === void 0) { startTime = TimeUtil.START_TIME; }
            return Date.now() - startTime;
        };
        TimeUtil.getTimerSecond = function () {
            return TimeUtil.getTimer() / 1000;
        };
        //标记现在时间
        TimeUtil.saveNowTime = function () {
            this.lastTime = this.getTimer();
        };
        //得到使用的时间
        TimeUtil.getUseTime = function () {
            return this.getTimer() - this.lastTime;
        };
        TimeUtil.getZeroTime = function (nS) {
            var timestamp4 = new Date(nS * 1000);
            timestamp4.setHours(0);
            timestamp4.setMinutes(0);
            timestamp4.setSeconds(0);
            return timestamp4.getTime() / 1000;
        };
        /**
        * YYYY-mm-DD HH:MM
        **/
        TimeUtil.getLocalTime = function (nS) {
            var timestamp4 = new Date(nS * 1000); //直接用 new Date(时间戳) 格式转化获得当前时间1-00
            return timestamp4.toLocaleDateString().replace(/\//g, "-") + " " + timestamp4.toTimeString().substr(0, 5);
        };
        /**
        * YYYY-mm-DD
        **/
        TimeUtil.getLocalTime0 = function (nS) {
            var timestamp4 = new Date(nS * 1000); //直接用 new Date(时间戳) 格式转化获得当前时间1-00
            return timestamp4.toLocaleDateString().replace(/\//g, "-");
        };
        /**
        * YYYY-mm-DD HH:MM:SS
        **/
        TimeUtil.getLocalTime1 = function (nS) {
            var timestamp4 = new Date(nS * 1000); //直接用 new Date(时间戳) 格式转化获得当前时间1-00
            return timestamp4.toLocaleDateString().replace(/\//g, "-") + " " + timestamp4.toTimeString().substr(0, 8);
        };
        /**
         * HH:MM:SS
        **/
        TimeUtil.getLocalTime2 = function (nS) {
            // var timestamp4 = new Date(nS * 1000 - 8 * 60 * 60 * 1000);//直接用 new Date(时间戳) 格式转化获得当前时间1-00
            var timestamp4 = new Date(nS * 1000); //直接用 new Date(时间戳) 格式转化获得当前时间1-00
            ////console.log("--time=",timestamp4.toTimeString());
            return timestamp4.toTimeString().substr(0, 8);
        };
        /**
         * HH:MM
        **/
        TimeUtil.getLocalTime6 = function (nS) {
            // var timestamp4 = new Date(nS * 1000 - 8 * 60 * 60 * 1000);//直接用 new Date(时间戳) 格式转化获得当前时间1-00
            var timestamp4 = new Date(nS * 1000); //直接用 new Date(时间戳) 格式转化获得当前时间1-00
            //console.log("--time=",timestamp4.toTimeString());
            return timestamp4.toTimeString().substr(0, 5);
        };
        /**
         * MM:SS
        **/
        TimeUtil.getLocalTime3 = function (nS) {
            var timestamp4 = new Date(nS * 1000); //直接用 new Date(时间戳) 格式转化获得当前时间1-00
            return timestamp4.toTimeString().substr(3, 5);
        };
        /**
         * MM分SS秒
         */
        TimeUtil.getLocalTime4 = function (nS) {
            return tl3d.Util.float2int(nS / 60) + "分" + (nS % 60) + "秒";
        };
        /**
         * HH时MM分SS秒
         */
        TimeUtil.getLocalTime5 = function (nS) {
            var timestamp4 = new Date(nS * 1000);
            var str = timestamp4.toTimeString().substr(0, 8);
            var strAry = str.split(":");
            return strAry[0] + "时" + strAry[1] + "分" + strAry[2] + "秒";
        };
        /**
         * 时间差转换
         * DD天HH时MM分SS秒
         */
        TimeUtil.getDiffTime1 = function (nS) {
            var day = tl3d.Util.float2int(nS / this.dayTime);
            nS -= day * this.dayTime;
            var hour = tl3d.Util.float2int(nS / this.HourTime);
            nS -= hour * this.HourTime;
            var minus = tl3d.Util.float2int(nS / this.MinuteTime);
            nS -= minus * this.MinuteTime;
            return day + "天" + hour + "时" + minus + "分" + nS + "秒";
        };
        /**
         * HH:MM:SS
        **/
        TimeUtil.getDiffTime2 = function (nS) {
            var hour = tl3d.Util.float2int(nS / this.HourTime);
            nS -= hour * this.HourTime;
            var minus = tl3d.Util.float2int(nS / this.MinuteTime);
            nS -= minus * this.MinuteTime;
            return this.zeroStr(hour) + ":" + this.zeroStr(minus) + ":" + this.zeroStr(nS);
        };
        TimeUtil.zeroStr = function (num) {
            if (num > 9) {
                return String(num);
            }
            else {
                return "0" + num;
            }
        };
        TimeUtil.getDelayTimeStr = function ($hourtime) {
            var hourtime = Math.floor($hourtime / 3600);
            var timeStr = "";
            if (hourtime > 24) {
                timeStr = Math.floor(hourtime / 24) + "天前";
            }
            else {
                if (hourtime >= 1) {
                    timeStr = hourtime + "小时前";
                }
                else {
                    timeStr = "刚刚";
                }
            }
            return timeStr;
        };
        TimeUtil.compareTime = function ($hour, $min) {
            //服务器当前标准时间
            return false;
        };
        TimeUtil.init = function () {
            TimeUtil.START_TIME = Date.now();
        };
        TimeUtil.removeAllTickOut = function () {
            TimeUtil.outTimeFunAry = [];
        };
        TimeUtil.addTimeTick = function ($time, $fun, $beginTime) {
            if ($beginTime === void 0) { $beginTime = 0; }
            var timeFunTick = new TimeFunTick();
            timeFunTick.alltime = $time;
            timeFunTick.fun = $fun;
            timeFunTick.time = $time - $beginTime;
            TimeUtil.timefunAry.push(timeFunTick);
        };
        TimeUtil.removeTimeTick = function ($fun) {
            for (var i = 0; i < TimeUtil.timefunAry.length; i++) {
                if (TimeUtil.timefunAry[i]) {
                    if (TimeUtil.timefunAry[i].fun == $fun) {
                        //TimeUtil.timefunAry.splice(i, 1);
                        TimeUtil.timefunAry[i] = null;
                        break;
                    }
                }
                else {
                    // throw Error("有重复移除嫌疑");	
                }
            }
        };
        TimeUtil.addTimeOut = function ($time, $fun, args) {
            if (this.hasTimeOut($fun)) {
                return;
            }
            var timeFunTick = new TimeFunOut();
            timeFunTick.alltime = $time;
            timeFunTick.fun = $fun;
            timeFunTick.args = args;
            timeFunTick.time = 0;
            TimeUtil.outTimeFunAry.push(timeFunTick);
        };
        TimeUtil.removeTimeOut = function ($fun) {
            for (var i = 0; i < TimeUtil.outTimeFunAry.length; i++) {
                if (TimeUtil.outTimeFunAry[i] && TimeUtil.outTimeFunAry[i].fun == $fun) {
                    //TimeUtil.outTimeFunAry.splice(i, 1);
                    TimeUtil.outTimeFunAry[i] = null;
                    break;
                }
            }
        };
        TimeUtil.hasTimeOut = function ($fun) {
            for (var i = 0; i < TimeUtil.outTimeFunAry.length; i++) {
                if (TimeUtil.outTimeFunAry[i] && TimeUtil.outTimeFunAry[i].fun == $fun) {
                    return true;
                }
            }
            return false;
        };
        TimeUtil.addFrameTick = function ($fun) {
            if (TimeUtil.funAry.indexOf($fun) == -1) {
                TimeUtil.funAry.push($fun);
            }
        };
        TimeUtil.hasFrameTick = function ($fun) {
            var index = TimeUtil.funAry.indexOf($fun);
            if (index != -1) {
                return true;
            }
            return false;
        };
        TimeUtil.removeFrameTick = function ($fun) {
            var index = TimeUtil.funAry.indexOf($fun);
            if (index != -1) {
                TimeUtil.funAry[index] = null;
                //TimeUtil.funAry.splice(index, 1);
            }
        };
        TimeUtil.update = function () {
            var dtime = TimeUtil.getTimer() - TimeUtil.time;
            for (var i = 0; i < TimeUtil.funAry.length; i++) {
                if (TimeUtil.funAry[i]) {
                    TimeUtil.funAry[i](dtime);
                }
            }
            for (var i = 0; i < TimeUtil.timefunAry.length; i++) {
                if (TimeUtil.timefunAry[i]) {
                    TimeUtil.timefunAry[i].update(dtime);
                }
            }
            for (var i = TimeUtil.outTimeFunAry.length - 1; i >= 0; i--) {
                if (TimeUtil.outTimeFunAry[i] && TimeUtil.outTimeFunAry[i].update(dtime)) {
                    TimeUtil.outTimeFunAry[i] = null;
                }
            }
            for (var i = TimeUtil.funAry.length - 1; i >= 0; i--) {
                if (!TimeUtil.funAry[i]) {
                    TimeUtil.funAry.splice(i, 1);
                }
            }
            for (var i = TimeUtil.timefunAry.length - 1; i >= 0; i--) {
                if (!TimeUtil.timefunAry[i]) {
                    TimeUtil.timefunAry.splice(i, 1);
                }
            }
            for (var i = TimeUtil.outTimeFunAry.length - 1; i >= 0; i--) {
                if (!TimeUtil.outTimeFunAry[i]) {
                    TimeUtil.outTimeFunAry.splice(i, 1);
                }
            }
            TimeUtil.time = TimeUtil.getTimer();
        };
        TimeUtil.START_TIME = 0;
        TimeUtil.funAry = new Array;
        TimeUtil.timefunAry = new Array;
        TimeUtil.outTimeFunAry = new Array;
        TimeUtil.time = 0;
        TimeUtil.lastTime = 0;
        TimeUtil.dayTime = 86400;
        TimeUtil.HourTime = 3600;
        TimeUtil.MinuteTime = 60;
        return TimeUtil;
    }());
    tl3d.TimeUtil = TimeUtil;
    var TimeFunTick = /** @class */ (function () {
        function TimeFunTick() {
            this.alltime = 0;
            this.time = 0;
        }
        TimeFunTick.prototype.update = function (t) {
            this.time += t;
            if (this.time >= this.alltime) {
                this.fun();
                this.time = 0;
            }
        };
        return TimeFunTick;
    }());
    var TimeFunOut = /** @class */ (function () {
        function TimeFunOut() {
            this.alltime = 0;
            this.time = 0;
        }
        TimeFunOut.prototype.update = function (t) {
            this.time += t;
            if (this.time >= this.alltime) {
                this.fun(this.args);
                return true;
            }
            return false;
        };
        return TimeFunOut;
    }());
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Util = /** @class */ (function () {
        function Util() {
        }
        Util.float2int = function (value) {
            return value | 0;
        };
        Util.radian2angle = function (value) {
            return value / Math.PI * 180;
        };
        Util.angle2radian = function (value) {
            return value / 180 * Math.PI;
        };
        Util.makeImage = function () {
            var _img = new Image();
            _img.setAttribute("crossOrigin", "anonymous");
            return _img;
        };
        Util.hexToArgb = function (expColor, is32, color) {
            if (is32 === void 0) { is32 = true; }
            if (color === void 0) { color = null; }
            if (!color) {
                color = new tl3d.Vector3D();
            }
            color.w = is32 ? (expColor >> 24) & 0xFF : 0;
            color.x = (expColor >> 16) & 0xFF;
            color.y = (expColor >> 8) & 0xFF;
            color.z = (expColor) & 0xFF;
            return color;
        };
        Util.hexToArgbNum = function (expColor, is32, color) {
            if (is32 === void 0) { is32 = true; }
            if (color === void 0) { color = null; }
            color = Util.hexToArgb(expColor, is32, color);
            color.scaleBy(1 / 0xFF);
            return color;
        };
        Util.getBaseUrl = function () {
            if (tl3d.Scene_data.supportBlob) {
                return "";
            }
            else {
                return "_base";
            }
        };
        /**描边路径 */
        Util.strokeFilter = function (ctx, width, height, color) {
            var colorVec = Util.hexToArgb(color);
            var imgData = ctx.getImageData(0, 0, width, height);
            var data = imgData.data;
            var targetAry = new Array;
            for (var i = 1; i < width - 1; i++) {
                for (var j = 0; j < height - 1; j++) {
                    var idx = getPiexIdx(i, j);
                    if (data[idx + 3] == 0) {
                        if (getAround(i, j)) {
                            targetAry.push(idx);
                        }
                    }
                }
            }
            for (var i = 0; i < targetAry.length; i++) {
                data[targetAry[i]] = colorVec.x;
                data[targetAry[i] + 1] = colorVec.y;
                data[targetAry[i] + 2] = colorVec.z;
                data[targetAry[i] + 3] = colorVec.w;
            }
            ctx.putImageData(imgData, 0, 0);
            var getPiexIdx = function (x, y) {
                return ((y * width) + x) * 4;
            };
            var getAround = function (x, y) {
                var idx;
                idx = getPiexIdx(x - 1, y);
                if (data[idx + 3] > 0) {
                    return true;
                }
                idx = getPiexIdx(x + 1, y);
                if (data[idx + 3] > 0) {
                    return true;
                }
                idx = getPiexIdx(x, y + 1);
                if (data[idx + 3] > 0) {
                    return true;
                }
                idx = getPiexIdx(x, y - 1);
                if (data[idx + 3] > 0) {
                    return true;
                }
                // idx = getPiexIdx(x - 1, y+1);
                // if (data[idx + 3] > 0) {
                //     return true;
                // }
                // idx = getPiexIdx(x + 1, y+1);
                // if (data[idx + 3] > 0) {
                //     return true;
                // }
                // idx = getPiexIdx(x - 1, y-1);
                // if (data[idx + 3] > 0) {
                //     return true;
                // }
                // idx = getPiexIdx(x + 1, y-1);
                // if (data[idx + 3] > 0) {
                //     return true;
                // }
                return false;
            };
        };
        Util.trim = function (s) {
            return Util.trimRight(Util.trimLeft(s));
        };
        //去掉左边的空白  
        Util.trimLeft = function (s) {
            if (s == null) {
                return "";
            }
            var whitespace = new String(" \t\n\r");
            var str = new String(s);
            if (whitespace.indexOf(str.charAt(0)) != -1) {
                var j = 0, i = str.length;
                while (j < i && whitespace.indexOf(str.charAt(j)) != -1) {
                    j++;
                }
                str = str.substring(j, i);
            }
            return str;
        };
        //去掉右边的空白 www.2cto.com   
        Util.trimRight = function (s) {
            if (s == null)
                return "";
            var whitespace = new String(" \t\n\r");
            var str = new String(s);
            if (whitespace.indexOf(str.charAt(str.length - 1)) != -1) {
                var i = str.length - 1;
                while (i >= 0 && whitespace.indexOf(str.charAt(i)) != -1) {
                    i--;
                }
                str = str.substring(0, i + 1);
            }
            return str;
        };
        Util.getScencdStr = function (timeNum) {
            var m = Math.floor((timeNum / 60 % 60));
            var s = Math.floor(timeNum % 60);
            return String(m < 10 ? "0" : "") + String(m) + ":" + String(s < 10 ? "0" : "") + String(s);
        };
        Util.random = function ($num) {
            return Math.floor(Math.random() * $num);
        };
        Util.randomByItem = function (arr) {
            return arr[Util.random(arr.length)];
        };
        /**
         * 同时获得多个指定区间的随机数
         * 从min到max中随机much个数
         * 包括min
         * 不包括max
         */
        Util.getRandomNumAssgin = function ($much, $min, $max) {
            var posArray = new Array;
            var ary = new Array;
            for (var i_1 = $min; i_1 < $max; i_1++) {
                ary.push(i_1);
            }
            for (var i = 0; i < $much; i++) {
                if ($max > i) {
                    var randomid = Util.random(ary.length);
                    var retAry = ary.splice(randomid, 1);
                    posArray.push(retAry[0]);
                }
            }
            return posArray;
        };
        Util.makeArray = function (a, b) {
            if (!a) {
                //console.log("有错")
            }
            for (var i = 0; i < a.length; i++) {
                b.push(a[i]);
            }
        };
        Util.unZip = function ($aryBuf) {
            var compressed = new Uint8Array($aryBuf);
            //var t = Date.now();
            var inflate = new Zlib.Inflate(compressed);
            var plain = inflate.decompress();
            ////console.log("解压obj",Date.now()-t);
            return plain.buffer;
        };
        Util.getZipByte = function ($byte) {
            var zipLen = $byte.readInt();
            var aryBuf = $byte.buffer.slice($byte.position, $byte.position + zipLen);
            $byte.position += zipLen;
            var zipedBuf = Util.unZip(aryBuf);
            return new tl3d.TLByteArray(zipedBuf);
        };
        Util.getUrlParam = function (name) {
            if (window['wx']) { //小游戏不获取浏览器参数
                return null;
            }
            var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
            var r = window.location.search.substr(1).match(reg);
            if (r != null) {
                return decodeURI(r[2]);
            }
            else {
                return null;
            }
        };
        Util.copy2clipboard = function (val) {
            var inputui = document.createElement("textarea");
            //inputui.type = "text";
            inputui.style.fontSize = '12pt';
            inputui.style.position = "absolute";
            inputui.style["z-index"] = -1;
            inputui.style.background = "transparent";
            inputui.style.border = "transparent";
            inputui.style.color = "white";
            inputui.setAttribute('readonly', '');
            document.body.appendChild(inputui);
            inputui.value = val;
            inputui.select();
            inputui.setSelectionRange(0, inputui.value.length);
            try {
                document.execCommand('copy');
            }
            catch (error) {
                alert("不支持复制");
            }
            setTimeout(function () {
                document.body.removeChild(inputui);
            }, 1000);
        };
        Util.getBit = function ($num, offset) {
            return (Boolean)($num >> (offset & 31) & 1);
        };
        return Util;
    }());
    tl3d.Util = Util;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Curve = /** @class */ (function () {
        function Curve() {
            this.valueV3d = [1, 1, 1, 1];
        }
        Curve.prototype.getValue = function ($t) {
            if (!this.valueVec || this.begintFrame == -1) {
                return this.valueV3d;
            }
            var flag = tl3d.Util.float2int($t / tl3d.Scene_data.frameTime - this.begintFrame);
            if (flag < 0) {
                flag = 0;
            }
            else if (flag > this.maxFrame - this.begintFrame) {
                flag = this.maxFrame - this.begintFrame;
            }
            return this.valueVec[flag];
            /**
    
            if (this.type == 1) {
                this.valueV3d.x = this.valueVec[0][flag];
            } else if (this.type == 2) {
                this.valueV3d.x = this.valueVec[0][flag];
                this.valueV3d.y = this.valueVec[1][flag];
            } else if (this.type == 3) {
                this.valueV3d.x = this.valueVec[0][flag];
                this.valueV3d.y = this.valueVec[1][flag];
                this.valueV3d.z = this.valueVec[2][flag];
            } else if (this.type == 4) {
                this.valueV3d.x = this.valueVec[0][flag];
                this.valueV3d.y = this.valueVec[1][flag];
                this.valueV3d.z = this.valueVec[2][flag];
                this.valueV3d.w = this.valueVec[3][flag];
    
                this.valueV3d.scaleBy(this.valueV3d.w);
    
            }
            return this.valueV3d;
    
             */
        };
        Curve.prototype.setData = function (obj) {
            this.type = obj.type;
            this.maxFrame = obj.maxFrame;
            if (obj.items.length) {
                this.begintFrame = obj.items[0].frame;
            }
            else {
                this.begintFrame = -1;
            }
            var len = obj.values[0].length;
            var ary = new Array;
            for (var i = 0; i < len; i++) {
                var itemAry = new Array;
                if (this.type == 1) {
                    itemAry.push(obj.values[0][i]);
                }
                else if (this.type == 2) {
                    itemAry.push(obj.values[0][i], obj.values[1][i]);
                }
                else if (this.type == 3) {
                    itemAry.push(obj.values[0][i], obj.values[1][i], obj.values[2][i]);
                }
                else if (this.type == 4) {
                    var w = obj.values[3][i];
                    itemAry.push(obj.values[0][i] * w, obj.values[1][i] * w, obj.values[2][i] * w, w);
                }
                ary.push(itemAry);
            }
            this.valueVec = ary;
        };
        return Curve;
    }());
    tl3d.Curve = Curve;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var GroupRes = /** @class */ (function (_super) {
        __extends(GroupRes, _super);
        function GroupRes() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GroupRes.prototype.load = function (url, $fun) {
            var _this = this;
            this._fun = $fun;
            tl3d.LoadManager.getInstance().load(url, tl3d.LoadManager.BYTE_TYPE, function ($byte) {
                _this.loadComplete($byte);
            });
        };
        GroupRes.prototype.loadComplete = function ($byte) {
            var _this = this;
            this.dataAry = new Array;
            this._byte = new tl3d.TLByteArray($byte);
            this._byte.position = 0;
            this.version = this._byte.readInt();
            this.read(function () { _this.readNext(); }); //img
        };
        GroupRes.prototype.readNext = function () {
            this.read(); //obj
            this.read(); //material
            this.read(); //particle;
            var isGroup = this._byte.readBoolean();
            if (isGroup) {
                var length = this._byte.readInt();
                for (var i = 0; i < length; i++) {
                    this.readItem(true);
                }
            }
            else {
                this.readItem(false);
            }
            this._fun();
            this._fun = null;
            this._byte = null;
        };
        GroupRes.prototype.readItem = function (isG) {
            var types = this._byte.readInt();
            var item = new GroupItem();
            item.isGroup = isG;
            if (isG) {
                item.x = this._byte.readFloat();
                item.y = this._byte.readFloat();
                item.z = this._byte.readFloat();
                item.scaleX = this._byte.readFloat();
                item.scaleY = this._byte.readFloat();
                item.scaleZ = this._byte.readFloat();
                item.rotationX = this._byte.readFloat();
                item.rotationY = this._byte.readFloat();
                item.rotationZ = this._byte.readFloat();
            }
            if (types == tl3d.BaseRes.PREFAB_TYPE) {
                item.objUrl = this._byte.readUTF();
                item.materialUrl = this._byte.readUTF();
                if (this.version >= 4) {
                    item.materialInfoArr = this.readMaterialInfo();
                }
                item.types = tl3d.BaseRes.PREFAB_TYPE;
            }
            else if (types == tl3d.BaseRes.SCENE_PARTICLE_TYPE) {
                item.particleUrl = this._byte.readUTF();
                item.types = tl3d.BaseRes.SCENE_PARTICLE_TYPE;
            }
            this.dataAry.push(item);
        };
        GroupRes.prototype.initReg = function () {
            this._objDic = new Object;
            this._materialDic = new Object;
            this._particleDic = new Object;
            for (var i = 0; i < this.dataAry.length; i++) {
                var item = this.dataAry[i];
                if (item.objUrl) {
                    this._objDic[tl3d.Scene_data.fileRoot + item.objUrl] = true;
                }
                if (item.materialUrl) {
                    this._materialDic[tl3d.Scene_data.fileRoot + item.materialUrl] = true;
                }
                if (item.particleUrl) {
                    this._particleDic[tl3d.Scene_data.fileRoot + item.particleUrl] = true;
                }
            }
            for (var key in this._objDic) {
                tl3d.ObjDataManager.getInstance().registerUrl(key);
            }
            for (var key in this._materialDic) {
                tl3d.MaterialManager.getInstance().registerUrl(key);
            }
            for (var key in this._particleDic) {
                tl3d.ParticleManager.getInstance().registerUrl(key);
            }
        };
        GroupRes.prototype.destory = function () {
            _super.prototype.destory.call(this);
            for (var key in this._objDic) {
                tl3d.ObjDataManager.getInstance().releaseUrl(key);
            }
            for (var key in this._materialDic) {
                tl3d.MaterialManager.getInstance().releaseUrl(key);
            }
            for (var key in this._particleDic) {
                tl3d.ParticleManager.getInstance().releaseUrl(key);
            }
            this.dataAry = null;
            this._objDic = null;
            this._particleDic = null;
            this._materialDic = null;
        };
        return GroupRes;
    }(tl3d.BaseRes));
    tl3d.GroupRes = GroupRes;
    var GroupItem = /** @class */ (function (_super) {
        __extends(GroupItem, _super);
        function GroupItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return GroupItem;
    }(tl3d.Object3D));
    tl3d.GroupItem = GroupItem;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ModelRes = /** @class */ (function (_super) {
        __extends(ModelRes, _super);
        function ModelRes() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ModelRes.prototype.load = function (url, $fun) {
            var _this = this;
            this._fun = $fun;
            tl3d.LoadManager.getInstance().load(url, tl3d.LoadManager.BYTE_TYPE, function ($byte) {
                _this.loadComplete($byte);
            });
        };
        ModelRes.prototype.loadComplete = function ($byte) {
            var _this = this;
            this._byte = new tl3d.TLByteArray($byte);
            this._byte.position = 0;
            this.read(function () { _this.readNexte(); }); //img
        };
        ModelRes.prototype.readNexte = function () {
            this.read(); //obj
            this.read(); //material
            this.objUrl = this._byte.readUTF();
            this.materialUrl = this._byte.readUTF();
            if (this._byte.readBoolean()) {
                this.light = new tl3d.LightVo();
                this.light.ambientColor[0] = this._byte.readFloat();
                this.light.ambientColor[1] = this._byte.readFloat();
                this.light.ambientColor[2] = this._byte.readFloat();
                this.light.sunColor[0] = this._byte.readFloat();
                this.light.sunColor[1] = this._byte.readFloat();
                this.light.sunColor[2] = this._byte.readFloat();
                this.light.sunDirect[0] = this._byte.readFloat();
                this.light.sunDirect[1] = this._byte.readFloat();
                this.light.sunDirect[2] = this._byte.readFloat();
            }
            this._fun();
        };
        return ModelRes;
    }(tl3d.BaseRes));
    tl3d.ModelRes = ModelRes;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var RoleRes = /** @class */ (function (_super) {
        __extends(RoleRes, _super);
        function RoleRes() {
            var _this = _super.call(this) || this;
            _this.actionNum = 0;
            _this.actionIndex = 0;
            //资源状态
            _this.resState = "none";
            //开始加载
            _this.NONE = "none";
            //读取mesh
            _this.READ_MESH = "read_mesh";
            //读取动作
            _this.READ_ACTION = "read_action";
            //读取贴图
            _this.READ_IMAGE = "read_image";
            //读取贴图
            _this.READ_IMAGE_LOADING = "read_image_loading";
            //读取材质
            _this.READ_MATERIAL = "read_material";
            //读取粒子
            _this.READ_PARTICLE = "read_particle";
            //读取资源完毕
            _this.READ_COMPLETE = "read_complete";
            //心跳
            _this.updateTick = function () {
                _this.updateState();
            };
            _this.meshBatchNum = 1;
            return _this;
        }
        RoleRes.prototype.load = function (url, $fun) {
            var _this = this;
            this._fun = $fun;
            tl3d.LoadManager.getInstance().load(url, tl3d.LoadManager.BYTE_TYPE, function ($byte) {
                _this.loadComplete($byte);
            });
        };
        //更新资源状态
        RoleRes.prototype.updateState = function () {
            switch (this.resState) {
                case this.READ_MESH: //1.加载三角面
                    // console.log("updateState 1.加载三角面");
                    this.readMesh();
                    break;
                case this.READ_ACTION: //2.读取动作
                    // console.log("updateState 2.读取动作");
                    this.readAction(); //这里是循环多次的
                    break;
                case this.READ_IMAGE: //3.读取贴图
                    this.resState = this.READ_IMAGE_LOADING;
                    // console.log("updateState 3.读取贴图");
                    this.read();
                    break;
                case this.READ_MATERIAL: //4.读取材质
                    // console.log("updateState 4.读取材质");
                    this.read();
                    break;
                case this.READ_PARTICLE: //5.读取粒子
                    // console.log("updateState 5.读取粒子");
                    this.read();
                    break;
                case this.READ_COMPLETE:
                    // console.log("updateState READ_COMPLETE");
                    tl3d.TimeUtil.removeFrameTick(this.updateTick);
                    if (this._fun) {
                        this._fun();
                        this._fun = null;
                    }
                    break;
            }
        };
        //角色配置文件加载完毕
        RoleRes.prototype.loadComplete = function ($byte) {
            this._byte = new tl3d.TLByteArray($byte);
            this._byte.position = 0;
            this.version = this._byte.readInt();
            this.resState = this.READ_MESH; //1.开始加载
            tl3d.TimeUtil.addFrameTick(this.updateTick);
        };
        //读取三角面
        RoleRes.prototype.readMesh = function () {
            this.roleUrl = this._byte.readUTF();
            if (this.version >= 16) { //环境参数
                this.ambientLightColor = new tl3d.Vector3D;
                this.sunLigthColor = new tl3d.Vector3D;
                this.nrmDircet = new tl3d.Vector3D;
                this.ambientLightColor.x = this._byte.readFloat();
                this.ambientLightColor.y = this._byte.readFloat();
                this.ambientLightColor.z = this._byte.readFloat();
                this.ambientLightIntensity = this._byte.readFloat();
                this.ambientLightColor.scaleBy(this.ambientLightIntensity);
                this.sunLigthColor.x = this._byte.readFloat();
                this.sunLigthColor.y = this._byte.readFloat();
                this.sunLigthColor.z = this._byte.readFloat();
                this.sunLigthIntensity = this._byte.readFloat();
                this.sunLigthColor.scaleBy(this.sunLigthIntensity);
                this.nrmDircet.x = this._byte.readFloat();
                this.nrmDircet.y = this._byte.readFloat();
                this.nrmDircet.z = this._byte.readFloat();
            }
            tl3d.MeshDataManager.getInstance().readData(this._byte, this.meshBatchNum, this.roleUrl, this.version);
            //开始读取动作
            this.readActions();
        };
        /**读取动作*/
        RoleRes.prototype.readActions = function () {
            if (this.version >= 30) {
                this.actionByte = tl3d.Util.getZipByte(this._byte);
            }
            else {
                this.actionByte = this._byte;
            }
            this.actionAry = new Array;
            this.actionNum = this.actionByte.readInt();
            this.resState = this.READ_ACTION; //读完mesh读动作
        };
        /**读取单个动作*/
        RoleRes.prototype.readAction = function () {
            if (this.actionIndex >= this.actionNum) { //动作读完就读图片
                this.resState = this.READ_IMAGE;
                return;
            }
            var actionName = this.actionByte.readUTF();
            tl3d.AnimManager.getInstance().readData(this.actionByte, this.roleUrl + actionName);
            this.actionAry.push(actionName);
            this.actionIndex++;
        };
        /**图片读取完毕*/
        RoleRes.prototype.allResCom = function () {
            this.resState = this.READ_MATERIAL; //读完图片读材质
            this.actionByte = null; //动作用完就清空
            this.actionNum = 0;
            this.actionIndex = 0;
        };
        /**读取材质*/
        RoleRes.prototype.readMaterial = function () {
            _super.prototype.readMaterial.call(this);
            this.resState = this.READ_PARTICLE; //读完材质，读粒子
        };
        /**读取粒子*/
        RoleRes.prototype.readParticle = function () {
            _super.prototype.readParticle.call(this);
            this.resState = this.READ_COMPLETE; //读完粒子就结束
        };
        return RoleRes;
    }(tl3d.BaseRes));
    tl3d.RoleRes = RoleRes;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkillRes = /** @class */ (function (_super) {
        __extends(SkillRes, _super);
        function SkillRes() {
            var _this = _super.call(this) || this;
            _this.meshBatchNum = 1;
            return _this;
        }
        SkillRes.prototype.load = function (url, $fun) {
            var _this = this;
            this._fun = $fun;
            tl3d.LoadManager.getInstance().load(url, tl3d.LoadManager.BYTE_TYPE, function ($byte) {
                _this.loadComplete($byte);
            });
        };
        SkillRes.prototype.loadComplete = function ($byte) {
            var _this = this;
            this._byte = new tl3d.TLByteArray($byte);
            this._byte.position = 0;
            this.version = this._byte.readInt();
            this.skillUrl = this._byte.readUTF();
            this.read(function () { _this.readNext(); }); //readimg 
        };
        SkillRes.prototype.readNext = function () {
            this.read(); //readmaterial
            this.read(); //readparticle;
            if (this.version < 27) {
                var str = this._byte.readUTF();
            }
            this.data = this.readData(this._byte);
            this._fun();
        };
        SkillRes.prototype.readData = function ($byte) {
            var len = $byte.readInt();
            var byteData = new Object;
            for (var i = 0; i < len; i++) {
                var $obj = new Object;
                var $name = $byte.readUTF();
                var $action = $byte.readUTF();
                $obj.skillname = $name;
                $obj.action = $action;
                $obj.type = $byte.readFloat();
                if (this.version >= 26) {
                    $obj.blood = $byte.readInt();
                    if ($obj.blood == 0) {
                        $obj.blood = tl3d.SkillVo.defaultBloodTime;
                    }
                }
                else {
                    $obj.blood = tl3d.SkillVo.defaultBloodTime;
                }
                if (this.version >= 32) {
                    var soundTime = $byte.readInt();
                    if (soundTime > 0) {
                        var soundName = $byte.readUTF();
                        $obj.sound = { time: soundTime, name: soundName };
                    }
                }
                if (this.version >= 33) {
                    var shockLen = $byte.readInt();
                    if (shockLen) {
                        var shockAry = new Array;
                        for (var k = 0; k < shockLen; k++) {
                            var shobj = new Object;
                            shobj.time = $byte.readInt();
                            shobj.lasttime = $byte.readInt();
                            shobj.amp = $byte.readFloat();
                            shockAry.push(shobj);
                        }
                        $obj.shock = shockAry;
                    }
                }
                // $obj.data=JSON.parse($byte.readUTF())
                $obj.data = new Array;
                var dLen = $byte.readInt();
                for (var j = 0; j < dLen; j++) {
                    var dataObj = new Object;
                    dataObj.url = $byte.readUTF();
                    dataObj.frame = $byte.readFloat();
                    switch ($obj.type) {
                        case 1:
                            dataObj.beginType = $byte.readInt();
                            if (dataObj.beginType == 0) {
                                dataObj.beginPos = new tl3d.Vector3D();
                                dataObj.beginPos.x = $byte.readFloat();
                                dataObj.beginPos.y = $byte.readFloat();
                                dataObj.beginPos.z = $byte.readFloat();
                            }
                            else if (dataObj.beginType == 1) {
                                dataObj.beginSocket = $byte.readUTF();
                            }
                            dataObj.hitSocket = $byte.readUTF();
                            dataObj.endParticle = $byte.readUTF();
                            dataObj.multype = $byte.readInt();
                            dataObj.speed = $byte.readFloat();
                            break;
                        case 3:
                            dataObj.beginSocket = $byte.readUTF();
                            dataObj.beginType = $byte.readFloat();
                            dataObj.multype = $byte.readFloat();
                            dataObj.speed = $byte.readFloat();
                            break;
                        case 4:
                            if (this.version >= 27) {
                                var hasSocket = $byte.readBoolean();
                                dataObj.hasSocket = hasSocket;
                                if (hasSocket) {
                                    dataObj.socket = $byte.readUTF();
                                }
                                else {
                                    dataObj.pos = this.readV3d($byte);
                                    dataObj.rotation = this.readV3d($byte);
                                }
                            }
                            else {
                                dataObj.hasSocket = false;
                                dataObj.pos = this.readV3d($byte);
                                dataObj.rotation = this.readV3d($byte);
                            }
                            break;
                        default:
                            alert("没有类型readData");
                            break;
                    }
                    $obj.data.push(dataObj);
                }
                byteData[$name] = $obj;
            }
            return byteData;
        };
        SkillRes.prototype.readV3d = function ($byte) {
            var v3d = new tl3d.Vector3D;
            v3d.x = $byte.readFloat();
            v3d.y = $byte.readFloat();
            v3d.z = $byte.readFloat();
            v3d.w = $byte.readFloat();
            return v3d;
        };
        return SkillRes;
    }(tl3d.BaseRes));
    tl3d.SkillRes = SkillRes;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Shadow = /** @class */ (function () {
        function Shadow() {
            this._visible = false;
            this.data = [0, 0, 0, 5];
        }
        Object.defineProperty(Shadow.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            set: function (value) {
                this._visible = value;
                this.display.stateChage();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shadow.prototype, "x", {
            get: function () {
                return this.data[0];
            },
            set: function (value) {
                this.data[0] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shadow.prototype, "y", {
            get: function () {
                return this.data[1];
            },
            set: function (value) {
                this.data[1] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shadow.prototype, "z", {
            get: function () {
                return this.data[2];
            },
            set: function (value) {
                this.data[2] = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Shadow.prototype, "size", {
            get: function () {
                return this.data[3];
            },
            set: function (value) {
                this.data[3] = value;
            },
            enumerable: true,
            configurable: true
        });
        return Shadow;
    }());
    tl3d.Shadow = Shadow;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ShadowManager = /** @class */ (function () {
        function ShadowManager() {
            this._displayList = new Array;
            tl3d.ProgrmaManager.getInstance().registe(tl3d.Display3DShadowShader.Display3DShadowShader, new tl3d.Display3DShadowShader());
        }
        ShadowManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new ShadowManager();
            }
            return this._instance;
        };
        ShadowManager.prototype.addShadow = function () {
            var display = this.getIdleShadow();
            var sd = new tl3d.Shadow();
            display.addShadow(sd);
            return sd;
        };
        ShadowManager.prototype.removeShadow = function (sd) {
            sd.display.removeShadow(sd);
        };
        ShadowManager.prototype.update = function () {
            if (this._displayList.length) {
                tl3d.Scene_data.context3D.setWriteDepth(false);
                for (var i = 0; i < this._displayList.length; i++) {
                    this._displayList[i].update();
                }
                tl3d.Scene_data.context3D.setWriteDepth(true);
            }
        };
        ShadowManager.prototype.getIdleShadow = function () {
            for (var i = 0; i < this._displayList.length; i++) {
                if (this._displayList[i].hasIdle()) {
                    return this._displayList[i];
                }
            }
            var display = new tl3d.Display3dShadow();
            this._displayList.push(display);
            return display;
        };
        return ShadowManager;
    }());
    tl3d.ShadowManager = ShadowManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var LightVo = /** @class */ (function () {
        function LightVo() {
            this.sunDirect = new Array(0, 1, 0);
            this.sunColor = new Array(2, 0, 0);
            this.ambientColor = new Array(0, 0, 0);
        }
        LightVo.prototype.setData = function (sd, sc, ac) {
            this.sunDirect[0] = sd.x;
            this.sunDirect[1] = sd.y;
            this.sunDirect[2] = sd.z;
            this.sunColor[0] = sc.x;
            this.sunColor[1] = sc.y;
            this.sunColor[2] = sc.z;
            this.ambientColor[0] = ac.x;
            this.ambientColor[1] = ac.y;
            this.ambientColor[2] = ac.z;
        };
        return LightVo;
    }());
    tl3d.LightVo = LightVo;
})(tl3d || (tl3d = {}));
var Test = /** @class */ (function () {
    function Test() {
    }
    Test.prototype.readData = function ($bytes) {
        this._byte = $bytes;
        this.type = this._byte.readShort();
        this.name = this._byte.readUTF();
        this.age = this._byte.readInt();
    };
    Test.prototype.writeData = function () {
        this._byte.writeShort(Test.IMG_TYPE);
        this._byte.writeUTF(this.name);
        var sss = 90;
        this._byte.writeInt(sss);
    };
    Test.IMG_TYPE = 1;
    Test.OBJS_TYPE = 2;
    Test.MATERIAL_TYPE = 3;
    return Test;
}());

(function (tl3d) {
    var CapsuleVo = /** @class */ (function () {
        function CapsuleVo($radius, $height) {
            this.radius = $radius;
            this.height = $height;
        }
        return CapsuleVo;
    }());
    tl3d.CapsuleVo = CapsuleVo;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var CollisionVo = /** @class */ (function (_super) {
        __extends(CollisionVo, _super);
        function CollisionVo($x, $y, $z) {
            if ($x === void 0) { $x = 0; }
            if ($y === void 0) { $y = 0; }
            if ($z === void 0) { $z = 0; }
            return _super.call(this) || this;
        }
        return CollisionVo;
    }(tl3d.Object3D));
    tl3d.CollisionVo = CollisionVo;
    var CollisionItemVo = /** @class */ (function () {
        function CollisionItemVo() {
        }
        return CollisionItemVo;
    }());
    tl3d.CollisionItemVo = CollisionItemVo;
    var CollisionType = /** @class */ (function () {
        function CollisionType() {
        }
        CollisionType.Polygon = 0;
        CollisionType.BOX = 1;
        CollisionType.BALL = 2; //球体
        CollisionType.Cylinder = 3; //圆柱
        CollisionType.Cone = 4; //圆锥
        return CollisionType;
    }());
    tl3d.CollisionType = CollisionType;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var DualQuatFloat32Array = /** @class */ (function () {
        function DualQuatFloat32Array() {
        }
        return DualQuatFloat32Array;
    }());
    tl3d.DualQuatFloat32Array = DualQuatFloat32Array;
    var AnimData = /** @class */ (function () {
        function AnimData() {
            this.inLoop = 0;
            this.inter = new Array;
            this.bounds = new Array;
            this.nameHeight = 0;
            this.posAry = new Array;
            this.hasProcess = false;
        }
        AnimData.prototype.processMesh = function ($skinMesh) {
            if (this.hasProcess) {
                //console.log("has process logic error");
                return;
            }
            this.makeArrBoneQPAry($skinMesh);
            this.hasProcess = true;
        };
        AnimData.prototype.makeArrBoneQPAry = function ($skinMesh) {
            this.meshBoneQPAryDic = new tl3d.Dictionary([]);
            for (var k = 0; k < $skinMesh.meshAry.length; k++) {
                var $conleM = this.conleMatrixArr();
                for (var i = 0; i < $conleM.length; i++) {
                    var frameAry = $conleM[i];
                    for (var j = 0; j < frameAry.length; j++) {
                        if ($skinMesh.meshAry[k].bindPosMatrixAry[j]) {
                            frameAry[j].prepend($skinMesh.meshAry[k].bindPosMatrixAry[j]);
                        }
                    }
                }
                var temp = this.makeFrameDualQuatFloatArray($skinMesh, $conleM);
                this.meshBoneQPAryDic[$skinMesh.meshAry[k].uid] = temp;
                this.boneQPAry = temp; //存一下到原来数据中
            }
            this.matrixAry = $conleM; //将最后一个回传给插孔
        };
        AnimData.prototype.getBoneQPAryByMesh = function ($mesh) {
            return this.meshBoneQPAryDic[$mesh.uid];
        };
        AnimData.prototype.conleMatrixArr = function () {
            var $arr = new Array();
            for (var i = 0; i < this.matrixAry.length; i++) {
                var frameAry = this.matrixAry[i];
                var temp = new Array();
                for (var j = 0; j < frameAry.length; j++) {
                    temp.push(frameAry[j].clone());
                }
                $arr.push(temp);
            }
            return $arr;
        };
        AnimData.prototype.makeFrameDualQuatFloatArray = function ($skinMesh, $matrixAry) {
            var $backArr = new Array();
            var tempMatrix = new tl3d.Matrix3D();
            for (var i = 0; i < $skinMesh.meshAry.length; i++) {
                var $frameDualQuat = new Array;
                var newIDBoneArr = $skinMesh.meshAry[i].boneNewIDAry;
                for (var j = 0; j < $matrixAry.length; j++) {
                    var baseBone = $matrixAry[j];
                    var $DualQuatFloat32Array = new DualQuatFloat32Array;
                    $DualQuatFloat32Array.quat = new Float32Array(newIDBoneArr.length * 4);
                    $DualQuatFloat32Array.pos = new Float32Array(newIDBoneArr.length * 3);
                    for (var k = 0; k < newIDBoneArr.length; k++) {
                        var $m = baseBone[newIDBoneArr[k]].clone(tempMatrix);
                        $m.appendScale(-1, 1, 1); //特别标记，因为四元数和矩阵运算结果不一
                        var $q = new tl3d.Quaternion();
                        $q.fromMatrix($m);
                        var $p = $m.position;
                        $DualQuatFloat32Array.quat[k * 4 + 0] = $q.x;
                        $DualQuatFloat32Array.quat[k * 4 + 1] = $q.y;
                        $DualQuatFloat32Array.quat[k * 4 + 2] = $q.z;
                        $DualQuatFloat32Array.quat[k * 4 + 3] = $q.w;
                        $DualQuatFloat32Array.pos[k * 3 + 0] = $p.x;
                        $DualQuatFloat32Array.pos[k * 3 + 1] = $p.y;
                        $DualQuatFloat32Array.pos[k * 3 + 2] = $p.z;
                    }
                    $frameDualQuat.push($DualQuatFloat32Array);
                }
                $backArr.push($frameDualQuat);
            }
            return $backArr;
        };
        return AnimData;
    }());
    tl3d.AnimData = AnimData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var BoneSocketData = /** @class */ (function () {
        function BoneSocketData() {
        }
        return BoneSocketData;
    }());
    tl3d.BoneSocketData = BoneSocketData;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var SkinMesh = /** @class */ (function (_super) {
        __extends(SkinMesh, _super);
        function SkinMesh() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.meshAry = new Array;
            _this.fileScale = 1;
            _this.tittleHeight = 0;
            _this.hitBox = new tl3d.Vector2D(0, 0);
            _this.type = 0;
            _this.animDic = new Object;
            _this.ready = false;
            _this.hasDestory = false;
            return _this;
        }
        SkinMesh.prototype.makeHitBoxItem = function () {
            this.hitPosItem = new Array;
            var w = this.hitBox.x;
            var h = this.hitBox.y;
            var a = new tl3d.Vector3D(-w, 0, -w);
            var b = new tl3d.Vector3D(w, 0, -w);
            var c = new tl3d.Vector3D(w, 0, w);
            var d = new tl3d.Vector3D(-w, 0, w);
            this.hitPosItem.push(a);
            this.hitPosItem.push(b);
            this.hitPosItem.push(c);
            this.hitPosItem.push(d);
            var a1 = new tl3d.Vector3D(-w, h, -w);
            var b1 = new tl3d.Vector3D(w, h, -w);
            var c1 = new tl3d.Vector3D(w, h, w);
            var d1 = new tl3d.Vector3D(-w, h, w);
            this.hitPosItem.push(a1);
            this.hitPosItem.push(b1);
            this.hitPosItem.push(c1);
            this.hitPosItem.push(d1);
        };
        SkinMesh.prototype.addMesh = function ($mesh) {
            $mesh.uid = this.meshAry.length;
            this.meshAry.push($mesh);
        };
        SkinMesh.prototype.loadParticle = function () {
        };
        SkinMesh.prototype.loadMaterial = function ($fun) {
            if ($fun === void 0) { $fun = null; }
            for (var i = 0; i < this.meshAry.length; i++) {
                this.loadByteMeshDataMaterial(this.meshAry[i], $fun);
            }
        };
        SkinMesh.prototype.loadByteMeshDataMaterial = function ($meshData, $fun) {
            if ($fun === void 0) { $fun = null; }
            var url = tl3d.Scene_data.fileRoot + $meshData.materialUrl;
            url = url.replace("_byte.txt", ".txt");
            url = url.replace(".txt", "_byte.txt");
            tl3d.MaterialManager.getInstance().getMaterialByte(url, function ($material) {
                $meshData.material = $material;
                if ($material.usePbr) {
                    tl3d.MeshDataManager.getInstance().uploadPbrMesh($meshData, $material.useNormal);
                }
                else if ($material.lightProbe || $material.directLight) {
                    tl3d.MeshDataManager.getInstance().uploadPbrMesh($meshData, false);
                }
                if ($meshData.materialParamData) {
                    $meshData.materialParam = new tl3d.MaterialBaseParam();
                    $meshData.materialParam.setData($meshData.material, $meshData.materialParamData);
                }
                if ($fun) {
                    $fun($material);
                }
            }, null, true, tl3d.MaterialAnimShader.MATERIAL_ANIM_SHADER, tl3d.MaterialAnimShader);
        };
        SkinMesh.prototype.setAction = function (actionAry, roleUrl) {
            this.animUrlAry = new Array;
            for (var i = 0; i < actionAry.length; i++) {
                var name = actionAry[i];
                var url = roleUrl + actionAry[i];
                var anim = tl3d.AnimManager.getInstance().getAnimDataImmediate(url);
                anim.processMesh(this);
                this.animDic[name] = anim;
                this.animUrlAry.push(url);
            }
        };
        SkinMesh.prototype.destory = function () {
            if (this.hasDestory) {
                return;
            }
            if (this.allParticleDic) {
                for (var key in this.allParticleDic) {
                    tl3d.ParticleManager.getInstance().releaseUrl(key);
                }
                this.allParticleDic = null;
            }
            for (var i = 0; i < this.meshAry.length; i++) {
                this.meshAry[i].destory();
            }
            this.meshAry.length = 0;
            this.meshAry = null;
            this.boneSocketDic = null;
            if (this.animUrlAry) {
                for (var i = 0; i < this.animUrlAry.length; i++) {
                    tl3d.AnimManager.getInstance().clearAnim(this.animUrlAry[i]);
                }
            }
            for (var key in this.animDic) {
                delete this.animDic[key];
            }
            this.animDic = null;
            this.hasDestory = true;
        };
        return SkinMesh;
    }(tl3d.ResCount));
    tl3d.SkinMesh = SkinMesh;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Module = /** @class */ (function () {
        function Module() {
            /**
                 * processor字典
                 */
            this.processorMap = new Object();
        }
        Module.prototype.getModuleName = function () {
            throw new Error("namespace必须复写命名");
            //return "";
        };
        /**
        * 注册的Processor的集合
        * 请注意：返回为Processor的实例数组
        * @return
        *
        */
        Module.prototype.listProcessors = function () {
            return null;
        };
        /**
         * 模块初始化
         */
        Module.prototype.onRegister = function () {
        };
        /**
        * 注册所有的Processor
        */
        Module.prototype.registerProcessors = function () {
            //注册Processor
            var processorArr = this.listProcessors();
            if (processorArr != null && processorArr.length > 0) {
                for (var i = 0; i < processorArr.length; i++) {
                    this.registerProcessor(processorArr[i]);
                }
            }
        };
        /**
        * 注册Processor
        * @param $processor
        */
        Module.prototype.registerProcessor = function ($processor) {
            //单例
            if (this.processorMap[$processor.getName()] != null) {
                throw new Error("同一namespace不能注册两个相同的Processor");
            }
            this.processorMap[$processor.getName()] = $processor;
            $processor.registerEvents();
            //NetManager.getInstance().reg($processor);
        };
        /**
        * 注册namespace
        * @param $namespace
        */
        Module.registerModule = function ($namespace) {
            //单例
            if (Module.namespaceMap[$namespace.getModuleName()] != null) {
                throw new Error("不能注册两个相同的namespace：" + $namespace.getModuleName());
            }
            Module.namespaceMap[$namespace.getModuleName()] = $namespace;
            $namespace.registerProcessors();
            $namespace.onRegister();
        };
        /**
        * namespace字典
        */
        Module.namespaceMap = new Object();
        return Module;
    }());
    tl3d.Module = Module;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ModuleEventManager = /** @class */ (function () {
        function ModuleEventManager() {
        }
        ModuleEventManager.addEvents = function (ary, $fun, $thisObj) {
            for (var i = 0; i < ary.length; i++) {
                ModuleEventManager._instance.addEventListener(ary[i].type, $fun, $thisObj);
            }
        };
        ModuleEventManager.dispatchEvent = function ($event) {
            ModuleEventManager._instance.dispatchEvent($event);
        };
        ModuleEventManager.addEvent = function (type, listener, thisObject) {
            ModuleEventManager._instance.addEventListener(type, listener, thisObject);
        };
        ModuleEventManager.removeEvent = function (type, listener, thisObject) {
            ModuleEventManager._instance.removeEventListener(type, listener, thisObject);
        };
        ModuleEventManager.removeEventByName = function (type) {
            ModuleEventManager._instance.removeEventListenerByName(type);
        };
        ModuleEventManager.removeEventByNameAndTarget = function (type, thisObject) {
            ModuleEventManager._instance.removeEventListenerByNameAndTarget(type, thisObject);
        };
        ModuleEventManager.removeEventByTarget = function (thisObject) {
            ModuleEventManager._instance.removeEventListenerByTarget(thisObject);
        };
        ModuleEventManager._instance = new tl3d.EventDispatcher();
        return ModuleEventManager;
    }());
    tl3d.ModuleEventManager = ModuleEventManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Processor = /** @class */ (function () {
        function Processor() {
        }
        Processor.prototype.getName = function () {
            throw new Error("process必须复写命名");
            //return "";
        };
        /**
        * 解析事件，之后交给处理函数
        * @param $notification
        */
        Processor.prototype.receivedModuleEvent = function ($event) {
        };
        /**
        * 监听的事件类的集合
        * 请注意：返回为事件的CLASS(这些CLASS必须继承自namespaceEvent)的数组
        * @return
        *
        */
        Processor.prototype.listenModuleEvents = function () {
            return null;
        };
        Processor.prototype.registerEvents = function () {
            //注册消息监听
            var meClassArr = this.listenModuleEvents();
            if (meClassArr != null && meClassArr.length > 0) {
                tl3d.ModuleEventManager.addEvents(meClassArr, this.receivedModuleEvent, this);
            }
        };
        Processor.prototype.getHanderMap = function () {
            var obj = new Object;
            return obj;
        };
        return Processor;
    }());
    tl3d.Processor = Processor;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Scene_data = tl3d.Scene_data;
    var CanvasPostionModel = /** @class */ (function () {
        function CanvasPostionModel() {
            this.lastPostionV2d = new tl3d.Vector2D;
            this._lastMousePos = new tl3d.Vector2D();
            this.tureMoveV2d = new tl3d.Vector2D(0, 0);
            this.initSceneFocueEvent();
        }
        CanvasPostionModel.getInstance = function () {
            if (!this._instance) {
                this._instance = new CanvasPostionModel();
            }
            return this._instance;
        };
        CanvasPostionModel.prototype.initSceneFocueEvent = function () {
            Scene_data.uiBlankStage.addEventListener(tl3d.InteractiveEvent.Down, this.onMouseDown, this);
            Scene_data.uiBlankStage.addEventListener(tl3d.InteractiveEvent.Up, this.onMouseUp, this);
            Scene_data.uiBlankStage.addEventListener(tl3d.InteractiveEvent.Move, this.onMouseMove, this);
        };
        CanvasPostionModel.prototype.onMouseMove = function ($evt) {
            if (this._isMouseDown) {
                this.tureMoveV2d.x = this.lastPostionV2d.x + $evt.x - this._lastMousePos.x;
                this.tureMoveV2d.y = this.lastPostionV2d.y + $evt.y - this._lastMousePos.y;
                this.resetSize();
            }
        };
        CanvasPostionModel.prototype.onMouseDown = function ($evt) {
            this._lastMousePos.x = $evt.x;
            this._lastMousePos.y = $evt.y;
            this.lastPostionV2d = new tl3d.Vector2D(this.tureMoveV2d.x, this.tureMoveV2d.y);
            this._isMouseDown = true;
        };
        CanvasPostionModel.prototype.onMouseUp = function ($evt) {
            this._isMouseDown = false;
        };
        CanvasPostionModel.prototype.resetSize = function () {
            var $nScale = (0.25 / tl3d.Override2dEngine.htmlScale);
            Scene_data.focus3D.x = 0 + Scene_data.stageWidth / 2 * $nScale;
            Scene_data.focus3D.z = 0 - Scene_data.stageHeight / 2 * $nScale / (Math.sin(CanvasPostionModel.scene2dRotation45 * Math.PI / 180));
            Scene_data.focus3D.x -= this.tureMoveV2d.x * $nScale;
            Scene_data.focus3D.z += this.tureMoveV2d.y * $nScale / (Math.sin(CanvasPostionModel.scene2dRotation45 * Math.PI / 180));
            tl3d.Ground2dBaseSprite.perentpos = this.tureMoveV2d;
        };
        CanvasPostionModel.scene2dRotation45 = 45;
        return CanvasPostionModel;
    }());
    tl3d.CanvasPostionModel = CanvasPostionModel;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Scene_data = tl3d.Scene_data;
    var Ground2dBaseShader = /** @class */ (function (_super) {
        __extends(Ground2dBaseShader, _super);
        function Ground2dBaseShader() {
            return _super.call(this) || this;
        }
        Ground2dBaseShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "u2Texture");
        };
        Ground2dBaseShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Position;" +
                "attribute vec2 u2Texture;" +
                "varying vec2 v_texCoord;" +
                "uniform vec4 movesize;" +
                "void main(void)" +
                "{" +
                "   v_texCoord = vec2(u2Texture.x, u2Texture.y);" +
                "   vec4 vt0= vec4(v3Position, 1.0);" +
                "   vt0.xy*=movesize.zw;" +
                "   vt0.xy+=movesize.xy;" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        Ground2dBaseShader.prototype.getFragmentShaderString = function () {
            var $str = "precision mediump float;\n" +
                "uniform sampler2D s_texture;\n" +
                "varying vec2 v_texCoord;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                "gl_FragColor =infoUv;\n" +
                "}";
            return $str;
        };
        Ground2dBaseShader.Ground2dBaseShader = "Ground2dBaseShader";
        return Ground2dBaseShader;
    }(tl3d.Shader3D));
    tl3d.Ground2dBaseShader = Ground2dBaseShader;
    var Ground2dBaseSprite = /** @class */ (function (_super) {
        __extends(Ground2dBaseSprite, _super);
        function Ground2dBaseSprite() {
            var _this = _super.call(this) || this;
            _this.x = 0;
            _this.y = 0;
            _this.width = 100;
            _this.height = 100;
            _this.initData();
            return _this;
        }
        Ground2dBaseSprite.prototype.initData = function () {
            tl3d.ProgrmaManager.getInstance().registe(Ground2dBaseShader.Ground2dBaseShader, new Ground2dBaseShader);
            this.shader = tl3d.ProgrmaManager.getInstance().getProgram(Ground2dBaseShader.Ground2dBaseShader);
            this.program = this.shader.program;
            this.objData = new tl3d.ObjData;
            this.objData.vertices = new Array();
            this.objData.vertices.push(0, -1, 0);
            this.objData.vertices.push(1, -1, 0);
            this.objData.vertices.push(1, 0, 0);
            this.objData.vertices.push(0, 0, 0);
            this.objData.uvs = new Array();
            this.objData.uvs.push(0, 1);
            this.objData.uvs.push(1, 1);
            this.objData.uvs.push(1, 0);
            this.objData.uvs.push(0, 0);
            this.objData.indexs = new Array();
            this.objData.indexs.push(0, 1, 2);
            this.objData.indexs.push(0, 2, 3);
            this.loadTexture();
            this.upToGpu();
        };
        Ground2dBaseSprite.prototype.loadTexture = function () {
            var $ctx = tl3d.UIManager.getInstance().getContext2D(128, 128, false);
            $ctx.fillStyle = "rgb(255,255,255)";
            $ctx.fillRect(0, 0, 128, 128);
            this._uvTextureRes = tl3d.TextureManager.getInstance().getCanvasTexture($ctx);
        };
        Ground2dBaseSprite.prototype.setPicUrl = function ($url) {
            var _this = this;
            //  var $url: string = Scene_data.fileRoot + "pan/zymap2d/scene/1007/maps/0_0.jpg"
            tl3d.TextureManager.getInstance().getTexture($url, function ($texture) {
                _this._uvTextureRes = $texture;
            });
        };
        Ground2dBaseSprite.prototype.upToGpu = function () {
            if (this.objData.indexs.length) {
                this.objData.treNum = this.objData.indexs.length;
                this.objData.vertexBuffer = Scene_data.context3D.uploadBuff3D(this.objData.vertices);
                this.objData.uvBuffer = tl3d.Scene_data.context3D.uploadBuff3D(this.objData.uvs);
                this.objData.indexBuffer = tl3d.Scene_data.context3D.uploadIndexBuff3D(this.objData.indexs);
            }
        };
        Ground2dBaseSprite.prototype.update = function () {
            if (this.objData && this.objData.indexBuffer && this._uvTextureRes) {
                tl3d.Scene_data.context3D.setProgram(this.program);
                tl3d.Scene_data.context3D.setVa(0, 3, this.objData.vertexBuffer);
                tl3d.Scene_data.context3D.setVa(1, 2, this.objData.uvBuffer);
                tl3d.Scene_data.context3D.setVc4fv(this.shader, "movesize", this.getMoveSizeData());
                tl3d.Scene_data.context3D.setRenderTexture(this.shader, "s_texture", this._uvTextureRes.texture, 0);
                tl3d.Scene_data.context3D.drawCall(this.objData.indexBuffer, this.objData.treNum);
            }
        };
        Ground2dBaseSprite.prototype.getMoveSizeData = function () {
            var $tx = (this.x + Ground2dBaseSprite.perentpos.x) / (Scene_data.stageWidth / 2) - 1;
            var $ty = 1 - (this.y + Ground2dBaseSprite.perentpos.y) / (Scene_data.stageHeight / 2);
            var $tw = this.width / (Scene_data.stageWidth / 2);
            var $th = this.height / (Scene_data.stageHeight / 2);
            return [$tx, $ty, $tw, $th];
        };
        Ground2dBaseSprite.perentpos = new tl3d.Vector2D();
        return Ground2dBaseSprite;
    }(tl3d.Display3D));
    tl3d.Ground2dBaseSprite = Ground2dBaseSprite;
    var GroundModel = /** @class */ (function () {
        function GroundModel() {
            this._groundItem = new Array();
        }
        GroundModel.getInstance = function () {
            if (!this._instance) {
                this._instance = new GroundModel();
            }
            return this._instance;
        };
        GroundModel.prototype.update = function () {
            Scene_data.context3D.setWriteDepth(false);
            Scene_data.context3D.setDepthTest(false);
            for (var i = 0; i < this._groundItem.length; i++) {
                this._groundItem[i].update();
            }
        };
        GroundModel.prototype.addGroundPicByeUrl = function ($url, $rect) {
            if ($url === void 0) { $url = null; }
            if ($rect === void 0) { $rect = null; }
            var $dis = new Ground2dBaseSprite();
            if ($url) {
                $dis.setPicUrl($url);
            }
            if ($rect) {
                $dis.x = $rect.x;
                $dis.y = $rect.y;
                $dis.width = $rect.width;
                $dis.height = $rect.height;
            }
            this._groundItem.push($dis);
            return $dis;
        };
        return GroundModel;
    }());
    tl3d.GroundModel = GroundModel;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var Scene_data = tl3d.Scene_data;
    var OverrideEngine = /** @class */ (function (_super) {
        __extends(OverrideEngine, _super);
        function OverrideEngine() {
            return _super.call(this) || this;
        }
        OverrideEngine.initConfig = function () {
            var _this = this;
            tl3d.Engine.init = function ($caves) { _this.init($caves); }; //更换引擎初始化
            tl3d.Engine.resetSize = function (width, height) { _this.resetSize(width, height); }; //更尺寸变化
        };
        OverrideEngine.resetSize = function (width, height) {
            Scene_data.stageWidth = width;
            tl3d.Scene_data.stageHeight = height;
            Scene_data.canvas3D.width = Scene_data.stageWidth;
            Scene_data.canvas3D.height = Scene_data.stageHeight;
            Scene_data.context3D.resetSize(Scene_data.stageWidth, Scene_data.stageHeight);
            tl3d.UIManager.getInstance().resize();
            tl3d.Engine.resetViewMatrx3D();
        };
        OverrideEngine.init = function ($caves) {
            Scene_data.vpMatrix = new tl3d.Matrix3D;
            Scene_data.canvas3D = $caves;
            Scene_data.context3D = new tl3d.Context3D();
            Scene_data.context3D.init($caves);
            tl3d.UIManager.getInstance().init();
            Scene_data.cam3D = new tl3d.Camera3D;
            Scene_data.focus3D = new tl3d.Object3D;
            Scene_data.focus3D.rotationY = 135;
            Scene_data.focus3D.rotationX = -45;
            Scene_data.light = new tl3d.LightVo();
            tl3d.TimeUtil.init();
            //todo packageapp
            Scene_data.supportBlob = false;
        };
        return OverrideEngine;
    }(tl3d.Engine));
    tl3d.OverrideEngine = OverrideEngine;
})(tl3d || (tl3d = {}));
/// <reference path="../../scene3d/override/OverrideEngine.ts" />

(function (tl3d) {
    var Scene_data = tl3d.Scene_data;
    var Override2dEngine = /** @class */ (function (_super) {
        __extends(Override2dEngine, _super);
        function Override2dEngine() {
            return _super.call(this) || this;
        }
        Override2dEngine.initConfig = function () {
            var _this = this;
            tl3d.Engine.init = function ($caves) { _this.init($caves); }; //更换引擎初始化
            tl3d.Engine.resetSize = function (width, height) { _this.resetSize(width, height); }; //更尺寸变化
            tl3d.Engine.resetViewMatrx3D = function () { _this.resetViewMatrx3D(); };
        };
        Override2dEngine.resetSize = function (width, height) {
            if (isNaN(width)) {
                width = document.body.clientWidth;
            }
            if (isNaN(height)) {
                height = document.body.clientHeight;
            }
            tl3d.Scene_data.stageWidth = width;
            Scene_data.stageHeight = height;
            Scene_data.context3D.resetSize(Scene_data.stageWidth, Scene_data.stageHeight);
            tl3d.UIManager.getInstance().resize();
            tl3d.Engine.resetViewMatrx3D();
            tl3d.CanvasPostionModel.getInstance().resetSize();
        };
        Override2dEngine.init = function ($caves) {
            tl3d.OverrideEngine.init($caves);
            tl3d.Scene_data.focus3D.x = 0;
            Scene_data.focus3D.y = 0;
            Scene_data.focus3D.z = 0;
            tl3d.Scene_data.focus3D.rotationY = 0;
            Scene_data.focus3D.rotationX = -45;
            tl3d.Scene_data.cam3D.distance = 250;
        };
        Override2dEngine.resetViewMatrx3D = function () {
            if (Scene_data.viewMatrx3D) {
                Scene_data.viewMatrx3D.identity();
            }
            else {
                Scene_data.viewMatrx3D = new tl3d.Matrix3D;
            }
            var fovw = tl3d.Scene_data.stageWidth;
            var fovh = tl3d.Scene_data.stageHeight;
            tl3d.Scene_data.sceneViewHW = Math.max(fovw, fovh);
            Scene_data.viewMatrx3D.appendScale(1 / Scene_data.sceneViewHW * 2, 1 / Scene_data.sceneViewHW * 2, 1 / 1000);
            Scene_data.viewMatrx3D.appendScale(1 * (Scene_data.sceneViewHW / fovw * 2), fovw / fovh * (Scene_data.sceneViewHW / fovw * 2), 1);
            tl3d.Scene_data.viewMatrx3D.appendScale(2 * this.htmlScale, 2 * this.htmlScale, 1);
        };
        Override2dEngine.htmlScale = 0.5;
        return Override2dEngine;
    }(tl3d.OverrideEngine));
    tl3d.Override2dEngine = Override2dEngine;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ExpTextJumpUiDrawAndRefreash256 = /** @class */ (function (_super) {
        __extends(ExpTextJumpUiDrawAndRefreash256, _super);
        function ExpTextJumpUiDrawAndRefreash256() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ExpTextJumpUiDrawAndRefreash256.prototype.drawTxtBydigitalAndtext = function ($vo) {
            var rec = this.parent.uiAtlas.getRec(this.textureStr);
            var ctx = tl3d.UIManager.getInstance().getContext2D(rec.pixelWitdh, rec.pixelHeight, false);
            var picid = $vo.type;
            var $width = 50;
            var $height = 25;
            var txtcolor;
            if ($vo.type == tl3d.TextJumpType.EXPERIENCE) {
                txtcolor = tl3d.ArtFont.num54;
            }
            var distion = tl3d.ArtFont.getInstance().getAirFontWidth(ctx, String(this._data.str), txtcolor);
            distion += $width;
            tl3d.UiDraw.cxtDrawImg(ctx, "TYPE" + picid, new tl3d.Rectangle(rec.pixelWitdh - distion, rec.pixelHeight - $height, $width, $height), tl3d.UIData.publicUi);
            tl3d.ArtFont.getInstance().writeFontToCtxLeft(ctx, String(this._data.str), txtcolor, rec.pixelWitdh - distion + $width + 2, rec.pixelHeight - $height);
            tl3d.TextureManager.getInstance().updateTexture(this.parent.uiAtlas.texture, rec.pixelX, rec.pixelY, ctx);
            return distion;
        };
        return ExpTextJumpUiDrawAndRefreash256;
    }(tl3d.ExpTextJumpUiDrawAndRefreash));
    tl3d.ExpTextJumpUiDrawAndRefreash256 = ExpTextJumpUiDrawAndRefreash256;
    var OverrideBloodManager = /** @class */ (function (_super) {
        __extends(OverrideBloodManager, _super);
        function OverrideBloodManager() {
            var _this = _super.call(this) || this;
            _this._jumpText256_256 = new tl3d.AlphaUiContianer(ExpTextJumpUiDrawAndRefreash256, new tl3d.Rectangle(0, 0, 256, 256), 2);
            _this.uiContianerItem.push(_this._jumpText256_256);
            return _this;
        }
        OverrideBloodManager.prototype.setExpJump256_256Num = function ($textJumpUiVo) {
            this._jumpText256_256.showTemp($textJumpUiVo);
            // console.log($textJumpUiVo)
        };
        return OverrideBloodManager;
    }(tl3d.BloodManager));
    tl3d.OverrideBloodManager = OverrideBloodManager;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ProgrmaManager = tl3d.ProgrmaManager;
    var TextureManager = tl3d.TextureManager;
    var Scene_data = tl3d.Scene_data;
    var ObjDataManager = tl3d.ObjDataManager;
    var Shader3D = tl3d.Shader3D;
    var Display3DSprite = tl3d.Display3DSprite;
    var BaseRes = tl3d.BaseRes;
    var DirectShadowDisplay3DShader = /** @class */ (function (_super) {
        __extends(DirectShadowDisplay3DShader, _super);
        function DirectShadowDisplay3DShader() {
            return _super.call(this) || this;
        }
        DirectShadowDisplay3DShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "v2CubeTexST");
            $context.bindAttribLocation(this.program, 2, "v3Normal");
        };
        DirectShadowDisplay3DShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Position;" +
                "attribute vec2 v2CubeTexST;" +
                "varying vec2 v0;" +
                "varying vec3 v_PositionFromLight;" +
                "varying vec3 v2;" +
                "varying float cosTheta;" +
                "varying float onsunFace;" +
                "varying vec3 ambientColorF;" +
                "attribute vec3 v3Normal;" +
                "uniform vec3 sunDirect;" +
                "uniform vec3 sunColor;" +
                "uniform vec3 ambientColor;" +
                "uniform mat4 vpMatrix3D;" +
                "uniform mat4 posMatrix3D;" +
                "uniform mat4 shadowViewMatx3D;" +
                "uniform mat3 rotationMatrix3D;" +
                "void main(void){;" +
                "ambientColorF =ambientColor;" +
                "v0 = vec2(v2CubeTexST.x, v2CubeTexST.y); " +
                "vec4 vt0= vec4(v3Position, 1.0);" +
                "vt0 = posMatrix3D * vt0;" +
                "vt0 = vpMatrix3D * vt0;" +
                "   vec4 vt1= vec4(v3Position, 1.0);" +
                "   vt1 = posMatrix3D * vt1;" +
                "   vt1 = shadowViewMatx3D * vt1;" +
                "   v_PositionFromLight = vec3(vt1.x, vt1.y,vt1.z);" +
                "vec3 n = rotationMatrix3D * v3Normal;" +
                "float suncos = dot(n.xyz,sunDirect.xyz);" +
                "onsunFace = suncos;" +
                "cosTheta =1.0-abs(suncos);" +
                "suncos = clamp(suncos,0.0,1.0);" +
                "v2 = sunColor * suncos ;" +
                "gl_Position = vt0;" +
                "}";
            return $str;
        };
        DirectShadowDisplay3DShader.prototype.getFragmentShaderString = function () {
            var $str = "precision mediump float;\n" +
                "uniform sampler2D fs0;\n" +
                "uniform sampler2D fs1;\n" +
                "varying vec2 v0;\n" +
                "varying vec3 v_PositionFromLight;\n" +
                "varying vec3 v2;" +
                "varying float cosTheta;" +
                "varying float onsunFace;" +
                "varying vec3 ambientColorF;" +
                "void main(void)\n" +
                "{\n" +
                "vec4 ft5 = texture2D(fs1, v_PositionFromLight.xy); " + //深度图采样
                "float  bias  = 0.01*cosTheta; " +
                "bias = clamp(bias, 0.003, 0.01); " +
                "float visibility = (v_PositionFromLight.z > ft5.x + bias) ? 0.9 : 1.0;\n" + //深度判断
                "visibility =onsunFace<0.0?1.0:visibility ; " +
                "vec4 ft0 = texture2D(fs0, v0); " + //正常纹理采样
                "vec4 ft1 = vec4(v2.xyz, 1.0); " + //法线值
                //  "ft0.xyz = ft1.xyz*ft0.xyz; " +
                "vec4 ft2 = vec4(1, 1, 1, 1); " +
                "float isalp = (ft5.z >0.1254) ? 1.0 : 0.2;\n" + //深度判断1254=  1236
                "gl_FragColor = vec4((ft1.xyz*visibility+ambientColorF.xyz)*ft0.rgb , 1.0); " +
                //    "gl_FragColor = vec4(ft1.xyz+ambientColorF.xyz, 1.0); " +
                "}";
            return $str;
        };
        DirectShadowDisplay3DShader.DirectShadowDisplay3DShader = "DirectShadowDisplay3DShader";
        return DirectShadowDisplay3DShader;
    }(Shader3D));
    tl3d.DirectShadowDisplay3DShader = DirectShadowDisplay3DShader;
    var DirectShadowDisplay3DSprite = /** @class */ (function (_super) {
        __extends(DirectShadowDisplay3DSprite, _super);
        function DirectShadowDisplay3DSprite() {
            var _this = _super.call(this) || this;
            _this.needScanShadow = true;
            _this.nrmFlag = 0;
            _this.initData();
            return _this;
        }
        DirectShadowDisplay3DSprite.prototype.initData = function () {
            ProgrmaManager.getInstance().registe(DirectShadowDisplay3DShader.DirectShadowDisplay3DShader, new DirectShadowDisplay3DShader);
            this.modelShder = ProgrmaManager.getInstance().getProgram(DirectShadowDisplay3DShader.DirectShadowDisplay3DShader);
        };
        DirectShadowDisplay3DSprite.prototype.setObjUrl = function (value) {
            var _this = this;
            ObjDataManager.getInstance().getObjData(Scene_data.fileRoot + value, function ($obj) {
                _this.objData = $obj;
            });
        };
        DirectShadowDisplay3DSprite.prototype.update = function () {
            for (var i = 0; i < this.groupItem.length; i++) {
                this.drawTemp(this.groupItem[i]);
            }
        };
        DirectShadowDisplay3DSprite.prototype.drawTemp = function ($dis) {
            if (!(this._scene).fbo || !tl3d.ShadowModel.shadowViewMatx3D) {
                return;
            }
            var $objdata = $dis.objData;
            var $shader = this.modelShder;
            if ($objdata && $objdata.indexBuffer && this._uvTextureRes) {
                Scene_data.context3D.setProgram($shader.program);
                Scene_data.context3D.setVc3fv($shader, "sunDirect", (this._scene).light.sunDirect);
                Scene_data.context3D.setVc3fv($shader, "sunColor", (this._scene).light.sunColor);
                Scene_data.context3D.setVc3fv($shader, "ambientColor", (this._scene).light.ambientColor);
                Scene_data.context3D.setVcMatrix4fv($shader, "shadowViewMatx3D", tl3d.ShadowModel.shadowViewMatx3D.m);
                Scene_data.context3D.setVcMatrix3fv($shader, "rotationMatrix3D", $dis._rotationData);
                Scene_data.context3D.setVcMatrix4fv($shader, "vpMatrix3D", Scene_data.vpMatrix.m);
                Scene_data.context3D.setVcMatrix4fv($shader, "posMatrix3D", this.posMatrix.m);
                Scene_data.context3D.renderContext.bindBuffer(Scene_data.context3D.renderContext.ARRAY_BUFFER, $objdata.vertexBuffer);
                Scene_data.context3D.setVaOffset(0, 3, $objdata.stride, 0);
                Scene_data.context3D.setVaOffset(1, 2, $objdata.stride, $objdata.uvsOffsets);
                Scene_data.context3D.setVaOffset(2, 3, $objdata.stride, $objdata.normalsOffsets);
                Scene_data.context3D.setRenderTexture($shader, "fs0", this._uvTextureRes.texture, 0);
                Scene_data.context3D.setRenderTexture($shader, "fs1", (this._scene).fbo.texture, 1);
                Scene_data.context3D.drawCall($objdata.indexBuffer, $objdata.treNum);
            }
        };
        DirectShadowDisplay3DSprite.prototype.updateRotationMatrix = function () {
            _super.prototype.updateRotationMatrix.call(this);
            for (var i = 0; this.groupItem && i < this.groupItem.length; i++) {
                var $dis = this.groupItem[i];
                if ($dis && $dis._rotationData) {
                    if ($dis._rotationData) {
                        this._rotationMatrix.getRotaion($dis._rotationData);
                    }
                }
            }
        };
        DirectShadowDisplay3DSprite.prototype.setPicUrl = function ($str) {
            var _this = this;
            TextureManager.getInstance().getTexture(Scene_data.fileRoot + $str, function ($texture) {
                _this._uvTextureRes = $texture;
            });
        };
        DirectShadowDisplay3DSprite.prototype.setModelById = function ($str) {
            var _this = this;
            this.groupItem = new Array();
            this._scene.groupDataMgr.getGroupData(Scene_data.fileRoot + tl3d.UnitFunction.getModelUrl($str), function (groupRes) {
                for (var i = 0; i < groupRes.dataAry.length; i++) {
                    var item = groupRes.dataAry[i];
                    if (item.types == BaseRes.PREFAB_TYPE) {
                        var $dis = new Display3DSprite();
                        $dis.setObjUrl(item.objUrl);
                        $dis._rotationData = new Float32Array(9);
                        _this.groupItem.push($dis);
                        if (item.materialInfoArr && item.materialInfoArr.length) {
                            _this.setPicUrl(item.materialInfoArr[0].url);
                        }
                        else {
                            console.log("没有指定贴图");
                        }
                    }
                }
                _this.updateRotationMatrix();
            });
        };
        return DirectShadowDisplay3DSprite;
    }(Display3DSprite));
    tl3d.DirectShadowDisplay3DSprite = DirectShadowDisplay3DSprite;
})(tl3d || (tl3d = {}));

(function (tl3d) {
    var ProgrmaManager = tl3d.ProgrmaManager;
    var UIManager = tl3d.UIManager;
    var Vector3D = tl3d.Vector3D;
    var TextureManager = tl3d.TextureManager;
    var Scene_data = tl3d.Scene_data;
    var Shader3D = tl3d.Shader3D;
    var Matrix3D = tl3d.Matrix3D;
    var FBO = tl3d.FBO;
    var MathClass = tl3d.MathClass;
    var BaseShadowShader = /** @class */ (function (_super) {
        __extends(BaseShadowShader, _super);
        function BaseShadowShader() {
            return _super.call(this) || this;
        }
        BaseShadowShader.prototype.binLocation = function ($context) {
            $context.bindAttribLocation(this.program, 0, "v3Position");
            $context.bindAttribLocation(this.program, 1, "u2Texture");
        };
        BaseShadowShader.prototype.getVertexShaderString = function () {
            var $str = "attribute vec3 v3Position;" +
                "attribute vec2 u2Texture;" +
                "uniform mat4 vpMatrix3D;" +
                "uniform mat4 posMatrix3D;" +
                "varying vec2 v_texCoord;" +
                "void main(void)" +
                "{" +
                "   v_texCoord = vec2(u2Texture.x, u2Texture.y);" +
                "   vec4 vt0= vec4(v3Position, 1.0);" +
                "   vt0 = posMatrix3D * vt0;" +
                "   vt0 = vpMatrix3D * vt0;" +
                "   gl_Position = vt0;" +
                "}";
            return $str;
        };
        BaseShadowShader.prototype.getFragmentShaderString = function () {
            var $str = "precision mediump float;\n" +
                "uniform sampler2D s_texture;\n" +
                "varying vec2 v_texCoord;\n" +
                "void main(void)\n" +
                "{\n" +
                "vec4 infoUv = texture2D(s_texture, v_texCoord.xy);\n" +
                "gl_FragColor = vec4(gl_FragCoord.z,gl_FragCoord.z,0.1236,1);\n" +
                "}";
            return $str;
        };
        BaseShadowShader.BaseShadowShader = "BaseShadowShader";
        return BaseShadowShader;
    }(Shader3D));
    tl3d.BaseShadowShader = BaseShadowShader;
    var ShadowModel = /** @class */ (function () {
        function ShadowModel() {
            this.sunRotationX = -90;
            this.sunRotationY = 0;
            this.sunDistens100 = 200;
            this.isNeedMake = true;
            this._visible = true;
        }
        ShadowModel.getInstance = function () {
            if (!this._instance) {
                this._instance = new ShadowModel();
            }
            return this._instance;
        };
        ShadowModel.prototype.getFBO = function () {
            FBO.fw = 1024;
            FBO.fh = 1024;
            //FBO.fw = 2048
            //FBO.fh = 2048
            this.renderContext = Scene_data.context3D.renderContext;
            var gl = Scene_data.context3D.renderContext;
            var fbo = new FBO();
            fbo.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, FBO.fw, FBO.fh, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            fbo.frameBuffer = gl.createFramebuffer();
            fbo.depthBuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.depthBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, FBO.fw, FBO.fh);
            return fbo;
        };
        ShadowModel.prototype.updateDepthTexture = function (fbo) {
            var gl = Scene_data.context3D.renderContext;
            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.frameBuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, fbo.texture, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, fbo.depthBuffer);
        };
        //创建可引用的阴影贴图  （-1~+1）=》（0~1）;
        ShadowModel.prototype.makeUseShadowView = function () {
            // Scene_data.viewMatrx3D.identity();
            // Scene_data.viewMatrx3D.appendScale(1 / 250, 1 / 250, 1 / (this.sunDistens100 * 2));
            Scene_data.viewMatrx3D.appendTranslation(1, 1, 1); //+1
            Scene_data.viewMatrx3D.appendScale(0.5, 0.5, 0.5); //*0.5
            MathClass.updateVp();
            ShadowModel.shadowViewMatx3D = Scene_data.vpMatrix.clone();
        };
        ShadowModel.prototype.setShowdowVisible = function (value) {
            this._visible = value;
            console.log("开关阴影", this._visible);
        };
        ShadowModel.prototype.updateDepth = function ($scene) {
            ShadowModel.getInstance().sunRotationY = 45;
            if (!($scene).fbo) {
                ($scene).fbo = this.getFBO(); //512*512
            }
            if (!this._visible) {
                return;
            }
            var $cloneVp = Scene_data.vpMatrix.clone();
            var $cloneView = Scene_data.viewMatrx3D.clone();
            this.updateDepthTexture(($scene).fbo);
            this.renderContext.viewport(0, 0, FBO.fw, FBO.fh);
            this.renderContext.clearColor(1, 1, 1, 1);
            this.renderContext.clearDepth(1.0);
            this.renderContext.enable(this.renderContext.DEPTH_TEST);
            this.renderContext.depthMask(true);
            this.renderContext.frontFace(this.renderContext.CW);
            this.renderContext.clear(this.renderContext.COLOR_BUFFER_BIT | this.renderContext.DEPTH_BUFFER_BIT);
            Scene_data.context3D.setWriteDepth(true);
            Scene_data.context3D.setDepthTest(true);
            Scene_data.viewMatrx3D.identity();
            Scene_data.viewMatrx3D.appendScale(1 / 500, 1 / 500, 1 / 600);
            Scene_data.cam3D.cameraMatrix.identity();
            Scene_data.cam3D.cameraMatrix.prependRotation(this.sunRotationX, Vector3D.X_AXIS);
            Scene_data.cam3D.cameraMatrix.prependRotation(this.sunRotationY, Vector3D.Y_AXIS);
            Scene_data.cam3D.cameraMatrix.prependTranslation(-Scene_data.focus3D.x, 0, -Scene_data.focus3D.z);
            var $sunNrm = new Vector3D(0, 0, -1);
            var $m = new Matrix3D;
            $m.appendRotation(-this.sunRotationX, Vector3D.X_AXIS);
            $m.appendRotation(-this.sunRotationY, Vector3D.Y_AXIS);
            $sunNrm = $m.transformVector($sunNrm);
            $sunNrm.normalize();
            //  ($scene).light.setData($sunNrm, new Vector3D(0.5, 0.5, 0.5), new Vector3D(0.5, 0.5, 0.5));
            ($scene).light.sunDirect[0] = $sunNrm.x;
            ($scene).light.sunDirect[1] = $sunNrm.y;
            ($scene).light.sunDirect[2] = $sunNrm.z;
            MathClass.updateVp();
            ShadowModel.shadowViewMatx3D = Scene_data.vpMatrix.clone();
            Scene_data.context3D.setProgram(null);
            for (var i = 0; i < $scene.displaySpriteList.length; i++) {
                var $a = $scene.displaySpriteList[i];
                this.drawTempSprite($a.objData, $a.posMatrix);
            }
            for (var j = 0; j < $scene.displayList.length; j++) {
                var $b = $scene.displayList[j];
                if ($b && $b.needScanShadow) {
                    for (var k = 0; k < $b.groupItem.length; k++) {
                        this.drawTempSprite($b.groupItem[k].objData, $b.posMatrix);
                    }
                }
            }
            var gl = Scene_data.context3D.renderContext;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            //  console.log("扫描深度")
            this.makeUseShadowView();
            Scene_data.context3D.resetSize(Scene_data.stageWidth, Scene_data.stageHeight);
            Scene_data.vpMatrix = $cloneVp;
            Scene_data.viewMatrx3D = $cloneView;
        };
        ShadowModel.prototype.drawTempSprite = function ($objdata, $posMatrix) {
            ProgrmaManager.getInstance().registe(BaseShadowShader.BaseShadowShader, new BaseShadowShader);
            var $shader = ProgrmaManager.getInstance().getProgram(BaseShadowShader.BaseShadowShader);
            if (!this._uvTextureRes) {
                var $ctx = UIManager.getInstance().getContext2D(128, 128, false);
                $ctx.fillStyle = "rgb(255,0,255)";
                $ctx.fillRect(0, 0, 128, 128);
                this._uvTextureRes = TextureManager.getInstance().getCanvasTexture($ctx);
            }
            Scene_data.context3D.setProgram($shader.program);
            Scene_data.context3D.setVcMatrix4fv($shader, "vpMatrix3D", Scene_data.vpMatrix.m);
            Scene_data.context3D.setVcMatrix4fv($shader, "posMatrix3D", $posMatrix.m);
            var tf = Scene_data.context3D.pushVa($objdata.vertexBuffer);
            Scene_data.context3D.setVaOffset(0, 3, $objdata.stride, 0);
            Scene_data.context3D.setVaOffset(1, 2, $objdata.stride, $objdata.uvsOffsets);
            Scene_data.context3D.setRenderTexture($shader, "s_texture", this._uvTextureRes.texture, 0);
            Scene_data.context3D.drawCall($objdata.indexBuffer, $objdata.treNum);
        };
        return ShadowModel;
    }());
    tl3d.ShadowModel = ShadowModel;
})(tl3d || (tl3d = {}));
